<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第6章 纹理化 Chapter 6 Texturing“所需要做的仅是为了使渲染图像看起来正确。” —— 吉姆·布林  (注：吉姆·布林，美国计算机科学家，他的 Blinn-Phong 着色模型在业内无人不知，无人不晓）">
<meta property="og:type" content="article">
<meta property="og:title" content="RealTimeRendering 6">
<meta property="og:url" content="http://example.com/2021/03/08/RealTimeRender4/6/index.html">
<meta property="og:site_name" content="XiMo">
<meta property="og:description" content="第6章 纹理化 Chapter 6 Texturing“所需要做的仅是为了使渲染图像看起来正确。” —— 吉姆·布林  (注：吉姆·布林，美国计算机科学家，他的 Blinn-Phong 着色模型在业内无人不知，无人不晓）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200824220946760.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200826181718513.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200826182415772.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200827213005451.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200928133807336.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200928201758635.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200928201544116.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?2%5E%7Bm%7D%20%5Ctimes%202%5E%7Bn%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?16384%5E%7B2%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200929140934974.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200929201152604.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%28p_%7Bu%7D%2Cp_%7Bv%7D%29">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Ctextbf%7Bb%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200929204338140.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200929211708780.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200929210646648.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200929210940928.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200929211441822.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200929212047552.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200930152151253.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B2%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?2%5Ctimes%20%5Cfrac%7B1%7D%7B2%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200930211150733.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020093022224692.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201003135530567.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?x_%7Bll%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?y_%7Bll%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?x_%7Bll%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?y_%7Bll%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201004150203520.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201004154910128.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201004165656628.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5E%7B2%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201004174647308.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?512%5E%7B2%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?1024%5E%7B2%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201008013610956.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201009134449683.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201009135120508.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201009203616521.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Ctextbf%7Bn%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Ctextbf%7Bn%7D_%7Bc%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201009203803303.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?RGB%5Crightarrow%20YC_%7Bo%7DC_%7Bg%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201009204034796.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?Y">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?C_%7Bo%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?C_%7Bg%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201009204105406.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?YC_%7Bo%7DC_%7Bg%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?YC_%7Bo%7DC_%7Bg%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?RGB%5Crightarrow%20YC_%7Bo%7DC_%7Bg%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201009205009234.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?YC_%7Bo%7DC_%7Bg%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?C_%7Bo%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?C_%7Bg%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?Y">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?YC_%7Bo%7DC_%7Bg%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?Y">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?C_%7Bo%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?C_%7Bg%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?Y">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?C_%7Bo%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?C_%7Bg%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?YC_%7Bo%7DC_%7Bg%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201009212839436.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201010135947264.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201010194131797.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020101020055954.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201010195003385.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bt%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201010200420580.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201010200715969.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20c_%7Bk%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201010195959778.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20n_%7Bk%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bt%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bt%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bk%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bt%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20c_%7Bk%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20c_%7B0%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bt%7D/%5Calpha_%7Bk%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020101213530984.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201012135819947.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bk%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201012205129202.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201012204928963.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bu%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bv%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bu%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bv%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201013135554191.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bu%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bv%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201013191652136.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201013192145510.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201013192935872.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201013195347205.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201013200829228.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201013200848674.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020101320223670.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bp%7D_%7Badj%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20v_%7Bz%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D_%7Bxy%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bp%7D_%7Badj%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201013201951462.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201013202614178.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201013202719775.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20v_%7Bz%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201014135617529.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201014211255740.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202010142152137.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201014221339230.png">
<meta property="article:published_time" content="2021-03-08T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-31T16:00:00.000Z">
<meta property="article:author" content="VisionXie">
<meta property="article:tag" content="渲染">
<meta property="article:tag" content="RealTimeRendering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200824220946760.png">

<link rel="canonical" href="http://example.com/2021/03/08/RealTimeRender4/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RealTimeRendering 6 | XiMo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XiMo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">醉后不知天在水，满船清梦压星河。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>All<span class="badge">30</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/08/RealTimeRender4/6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="VisionXie">
      <meta itemprop="description" content="生活在树上，始终热爱大地，升入天空。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiMo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RealTimeRendering 6
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-09 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-09T00:00:00+08:00">2021-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-01 00:00:00" itemprop="dateModified" datetime="2021-04-01T00:00:00+08:00">2021-04-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RealTimeRendering/" itemprop="url" rel="index"><span itemprop="name">RealTimeRendering</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    
      <a title="changyan" href="/2021/03/08/RealTimeRender4/6/#SOHUCS" itemprop="discussionUrl">
        <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2021/03/08/RealTimeRender4/6/" itemprop="commentCount"></span>
      </a>
    
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第6章-纹理化-Chapter-6-Texturing"><a href="#第6章-纹理化-Chapter-6-Texturing" class="headerlink" title="第6章 纹理化 Chapter 6 Texturing"></a><strong>第6章 纹理化</strong> <strong>Chapter 6 Texturing</strong></h1><p>“所需要做的仅是为了使渲染图像看起来正确。” —— 吉姆·布林</p>
<blockquote>
<p>(注：吉姆·布林，美国计算机科学家，他的 Blinn-Phong 着色模型在业内无人不知，无人不晓）</p>
</blockquote>
<span id="more"></span>
<p>表面的质感就是外观和感觉 —— 只要想一想油画的质感就知道了。在计算机图形学中，纹理化是获取表面并使用某些图片、函数或其他数据源在每个位置修改其外观的过程。例如，显示砖墙时，我们不是精确地去表示砖墙的几何形状，而是将砖墙的彩色图片应用于两个三角形组成的矩形上。查看矩形时，彩色图片会显示在矩形所在的位置。除非观察者很靠近墙壁，否则缺少的几何细节是不会引起注意的。</p>
<p>然而，某些带纹理的砖墙可能会因为缺乏几何形状而无法令人信服。例如，如果砂浆应该是哑光的（matte），而砖块是光滑的（glossy），则观察者会注意到两种材料的粗糙度相同。为了产生更令人信服的体验，我们可以在表面上应用第二个图片纹理。根据表面上的位置，此纹理可以更改墙壁的粗糙度，而不是更改表面的颜色。现在，砖和灰浆的图片纹理具有颜色，而新纹理具有粗糙度值。</p>
<p>观看者可能会看到现在所有砖块都是光滑的，而砂浆不是，但是请注意，每个砖块表面看起来都非常平坦。这看起来是不对的，因为砖的表面通常会有一些不规则的起伏。通过应用凹凸贴图（bump mapping），我们就可以改变砖块的着色法线，以便在渲染砖块时，使它们看起来并不十分平滑。这种纹理会扰动矩形原始表面法线的方向，以用于计算光照。</p>
<p>然而从低角度观看，这种凹凸不平的错觉可能会瓦解。砖块应突出在砂浆上方，以使其看不见。即使从直视角度看，砖块也应该将阴影投射到砂浆上。视差贴图（Parallax mapping）使用一张纹理让平面在渲染时似乎变形了，而视差遮蔽贴图（parallax occlusion mapping）将射线投射到高度场纹理上以提高真实感。位移贴图（Displacement mapping）通过修改形成模型的三角形高度来真正位移曲面。图 6.1 显示了带有颜色纹理和凹凸贴图的示例。</p>
<img alt="" height="832" src="https://img-blog.csdnimg.cn/20200824220946760.png" width="811">

<blockquote>
<p>图6.1 纹理化。将颜色和凹凸贴图应用于此鱼以增加其视觉细节水平。（图片由Elinor Quittner提供。）</p>
</blockquote>
<p>这些是可以通过纹理解决的问题类型的示例，使用了越来越复杂的算法。在本章中，将详细介绍纹理化技术。首先，会介绍纹理化过程的一般框架。接下来，我们会专注于使用图片对表面进行纹理化处理，因为这是实时工作中最流行的纹理化形式。简要讨论了程序纹理，然后说明了使纹理影响表面的一些常用方法。</p>
<h2 id="6-1-纹理化管线-The-Texturing-Pipeline"><a href="#6-1-纹理化管线-The-Texturing-Pipeline" class="headerlink" title="6.1 纹理化管线 The Texturing Pipeline"></a>6.1 纹理化管线 The Texturing Pipeline</h2><p>纹理化是一种用于有效地对表面材质的变化建模的技术**(?)**。探讨纹理化的一种方法是去思考单个着色像素在此过程中会发生什么。如上一章所述，我们通过考虑材料的颜色和灯光以及其他因素来计算着色。如上一章所述，通过考虑材质的颜色和灯光以及其他因素来计算着色。如果存在半透明物体的话，透明度也会影响采样。我们通过修改着色方程式中使用的值来进行纹理化。这些值的更改方式通常基于表面上的位置。因此，对于砖墙的示例，我们会根据表面位置，用砖墙图片中的相应颜色替换表面上任何点的颜色。图片纹理中的像素通常称为纹理像素（texels）（注：简称纹素），以区别于屏幕上的像素。粗糙度纹理会修改粗糙度值，而凹凸纹理会更改着色法线的方向，因此每个图片纹理都会改变着色方程式的结果。</p>
<p>纹理化过程可以通过概括的纹理管线来描述。稍后我们将介绍许多术语，但请振作精神：管线的每个部分都将被详细介绍。</p>
<p>在空间中的位置是纹理化过程的起点。该位置可以位于世界空间中，但通常位于模型的参照系中，因此随着模型的移动，纹理也随之移动。用 Kershaw 的术语 <strong>[884]</strong>  来描述，此空间点上已应用了投影函数（projector function），以便获得一组被称为纹理坐标（texture coordinates）的数值，这些数值将用于访问纹理。此过程称为映射（mapping），也通常被称为纹理映射（texture mapping）。有时纹理图片本身就被称为纹理贴图（texture map），尽管严格来说这并非正确。</p>
<p>在将这些新值用于访问纹理之前，可以使用一个或多个匹配函数将纹理坐标转换为纹理空间。这些纹理空间的位置用于从纹理中获取值，例如，它们可以是图片纹理中的数组索引，以便检索像素。然后，取回的值可能会通过值转换函数再次进行转换，最后，这些新值将用于修改曲面的某些属性，例如材质或着色法线。图 6.2 详细展示了应用单个纹理的过程。管线复杂的原因是每个步骤都为用户提供了有用的控件。应该注意的是，并非所有步骤都需要始终保持激活。</p>
<img alt="" height="184" src="https://img-blog.csdnimg.cn/20200826181718513.png" width="740">

<blockquote>
<p>图 6.2 单个纹理的概括纹理管线。</p>
</blockquote>
<img alt="" height="357" src="https://img-blog.csdnimg.cn/20200826182415772.png" width="733">

<blockquote>
<p>图 6.3 砖墙的管线。</p>
</blockquote>
<p>我们使用该管线，当三角形具有砖墙纹理并且在其表面上生成样本时，具体发生的事情如图（见图 6.3）。首先找到对象的局部参照系中的（x，y，z）位置； 假设是（−2.3，7.1，88.2）。然后将投影函数应用于此位置。正如世界地图是将三维对象投影到二维中一样，此处的投投影函数通常将（x，y，z）向量更改为二维向量（u，v）。此示例中使用的投影函数等效于正交投影（第2.3.1节），其作用类似于幻灯片投影仪，将砖墙图片照在三角形的表面上。回到墙这边，可以将其表面上的一个点转换为一对值，范围从 0 到 1 。这里假设获得的值为（0.32，0.29）。这些纹理坐标将用于查找此位置的图像颜色。我们砖墙纹理的分辨率为 256 × 256，因此匹配函数会将（u，v）分别乘以 256，得出（81.92，74.24）。弃掉小数点，在砖墙图片中对应像素为（81，74），它的颜色为（0.9，0.8，0.7）。纹理颜色位于 sRGB 颜色空间中，因此，如果要在着色方程式中使用该颜色，则将其转换为线性空间，得到（0.787，0.604，0.448）（第5.6节）。</p>
<h3 id="6-1-1-投影函数-The-Projector-Function"><a href="#6-1-1-投影函数-The-Projector-Function" class="headerlink" title="6.1.1 投影函数 The Projector Function"></a>6.1.1 投影函数 The Projector Function</h3><p>纹理处理的第一步是获取表面的位置并将其投影到纹理坐标空间中，通常是二维（u，v）空间。建模包（Modeling packages）通常允许美术师定义每个顶点的（u，v）坐标。这些可以从投影函数或网格展开算法来初始化。美工可以用编辑顶点位置的相同方式来编辑（u，v）坐标。投影函数通常通过将空间中的三维点转换为纹理坐标来工作。建模程序中常用的投影函数包括球形投影，圆柱形投影和平面投影 <strong>[141、884、970]</strong> 。</p>
<img alt="" height="432" src="https://img-blog.csdnimg.cn/20200827213005451.png" width="740">

<blockquote>
<p>图 6.4 不同的纹理投影。从左到右显示了球形，圆柱形，平面和自然（u，v）投影。底行显示了应用于单个对象（没有自然投影）的所有这些投影。</p>
</blockquote>
<p>其他的输入可用于投影函数。例如，可以使用表面法线来选择将六个平面投影方向中的哪个用于该表面。面部相接处的接缝处会出现纹理匹配问题； Geiss <strong>[521，522]</strong>  讨论了一种将它们混合的技术。Tarini 等人 <strong>[1740]</strong>  描述了多立方体贴图（polycube maps），其中一个模型被映射到一组立方体投影，而不同体积的空间映射到不同的立方体。</p>
<p>其他投影函数则不进行投影，但是它们是表面创建和细分（surface creation and tessellation）的隐含部分。例如，参数化曲面具有自然的（u，v）值集作为其定义的一部分。见图 6.4。纹理坐标也可以根据各种不同的参数生成，例如视图方向，表面温度或其他任何你能想到的参数。投影函数的目标是生成纹理坐标。将它们推导为位置的函数只是生成纹理坐标的一种方法。</p>
<p>非交互式渲染器通常将这些投影函数称为渲染过程本身的一部分。单个投影函数可能就足以满足整个模型的需要，但美术人员通常必须使用工具来划分模型并分别应用各种投影函数 <strong>[1345]</strong> 。参见图 6.5。</p>
<img alt="" height="438" src="https://img-blog.csdnimg.cn/20200928133807336.png" width="740">

<blockquote>
<p>图 6.5 各种纹理投影是如何被应用在单个模型上。盒式映射（Box mapping）由六个平面映射组成，每个盒子面都有一个映射。（图片由 Tito Pag´an 提供。）</p>
</blockquote>
<p>在实时渲染中，通常在建模阶段应用投影函数，并将投影结果存储在顶点上。然而并非总是如此; 有时在顶点或像素着色器中应用投影函数也是有利的。这么做可以提高精度，并有助于启用各种效果，包括动画（第6.4节）。一些渲染方法，例如环境映射（environment mapping）（第10.4节），具有自己的专用的投影函数，并且这些函数都会逐像素进行计算。</p>
<p>球形投影（图 6.4 的左侧）将点投射到以某个点为中心的假想球体上。此投影与 Blinn 和 Newell 的环境映射方案（第10.4.1节）中使用的投影相同，因此第 407 页的公式 10.30 描述了此函数。这种投影方法也遇到了该部分所述的相同的顶点插值问题。</p>
<p>圆柱形投影计算的 u 纹理坐标与球形投影相同，而 v 纹理坐标计算为沿圆柱轴的距离。此投影对于具有自然轴的对象，例如旋转表面（surfaces of revolution），是很有用的。另外，当曲面与圆柱轴接近垂直时，会发生变形现象。</p>
<p>平面投影就像 X 射线一样，沿着一个方向进行平行投影，并将纹理应用于所有表面。它使用正交投影（第4.7.1节）。举个例子，这种类型的投影可用于贴花（decals）（第20.2节）。</p>
<p>由于投影方向边缘的曲面存在严重的变形，因此美术人员通常必须手动将模型分解为近似平面的部分。还有一些工具可通过展开网格，或是创建一组接近最佳的平面投影来帮助其最大程度地减少变形，或者通过其他方式辅助此过程。我们的目标是使每个多边形在纹理区域中享有更公平的份额，同时还要保持尽可能多的网格连接。连接性很重要，因为采样伪像（artifacts）可以沿着纹理的各个单独部分相遇的边缘出现。具有良好展开效果的网格也可以简化美术人员的工作 <strong>[970，1345]</strong> 。16.2.1 节讨论了纹理变形如何对渲染产生不利影响。图 6.6 展示了用于创建图 6.5 中的雕像的工作空间。这种展开过程是网格参数化这一较大研究领域的一个方面。有兴趣的读者可以参考 Hormann 等人的 SIGGRAPH 课程笔记。**[774]** 。</p>
<img alt="" height="377" src="https://img-blog.csdnimg.cn/20200928201758635.png" width="738">

<blockquote>
<p>图 6.6  雕像模型的几个较小的纹理，保存为两个较大的纹理。右图显示了三角形网格如何展开并显示在纹理上以帮助其创建。（图片由Tito Pag´an提供。）</p>
</blockquote>
<p>纹理坐标空间并不总是二维平面。有时是三维体积。在这种情况下，纹理坐标表示为三元向量（u，v，w），其中 w 为沿投影方向的深度。其他系统最多使用四个坐标，通常指定为（s，t，r，q）**[885]** ； q 用作齐次坐标中的第四个值。它的作用类似于电影或幻灯片的投影仪，投影纹理的大小随距离而增加。举个例子，对于将装饰性聚光图案（称为 gobo）投影到舞台或其他表面上来说，它是很有用的 <strong>[1597]</strong> 。</p>
<p>纹理坐标空间的另一种重要类型是方向型，其空间中的每个点都可以通过输入方向访问。可视化这种空间的一种方法是将其作为单位球面上的点，每个点上的法线表示用于访问该位置纹理的方向。使用方向参数化的最常见纹理类型是立方体贴图（cube map ）（第6.2.4节）。</p>
<p>另外还值得注意的是，一维纹理图像和函数也有其用途。例如，在地形模型上，可以通过其高度确定颜色，例如低地是绿色，山峰是白色。线条也可以进行纹理化；其中一种用法是将雨水渲染为一组带有半透明图像的长线。此外，这种纹理对于从一个值转换为另一值，即作为查找表，也是有用的。</p>
<p>由于可以将多个纹理应用于一个表面，因此可能需要定义多组纹理坐标。但如果是应用坐标值的话，思路是相同的：这些纹理坐标在表面上插值并用于检索纹理值。然而在插值之前，这些纹理坐标会由匹配函数转换。</p>
<h3 id="6-1-2-匹配函数-The-Corresponder-Function"><a href="#6-1-2-匹配函数-The-Corresponder-Function" class="headerlink" title="6.1.2 匹配函数 The Corresponder Function"></a>6.1.2 匹配函数 The Corresponder Function</h3><p>匹配函数们将纹理坐标转换为纹理空间位置。它们提供了将纹理应用于表面的灵活性。匹配函数的一个应用案例就是使用 API 选择现有纹理的一部分进行显示；只有该子图像才会传递到后续操作流程中使用。</p>
<p>匹配函数的另一种类型是矩阵变换，可以将其应用于顶点或像素着色器。这样就可以在表面上平移，旋转，缩放，剪切或投影纹理。正如第 4.1.5 节所述，转换的顺序很重要。但令人惊讶的是，纹理转换的顺序必须与预期的顺序相反。这是因为纹理变换实际上会影响确定查看图像位置的空间。图像本身并不是要转换的对象；定义图片位置的空间正在被更改。</p>
<p>还有另一类匹配函数控制应用图像的方式。我们知道图像将出现在（u，v）处于 [0，1] 范围内的表面上。但是超出此范围会发生什么？此情况下匹配函数会确定其具体行为。在OpenGL中，这种类型的匹配函数被称为“包装模式”（wrapping mode）；在DirectX 中，它被称为“纹理寻址模式”（texture addressing mode）。这种类型的常见匹配函数分别是：</p>
<ul>
<li>包裹（wrap)（DirectX），重复（repeat）（OpenGL），或图块 —— 图像在整个表面上重复；在算法上，将丢弃纹理坐标的整数部分。此函数对于使材质的图像重复并覆盖表面很有用，并且这通常是默认设置。</li>
<li>镜像（mirror）—— 图像在整个表面上重复，但在其他每个重复上都被镜像（翻转）。例如，图像通常从0到1出现，然后在1和2之间反转，然后在 2 和 3 之间正常，然后反转，依此类推。这可以让纹理边缘带有连续性。</li>
<li>夹取（clamp）（DirectX）或夹取到边缘（clamp to edge）（OpenGL）—— 超出 [0，1] 范围的值都将被夹取到该范围。这会导致图像纹理的边缘像素不断重复。此函数对于在纹理的边缘附近采用双线性插值时，避免意外地从纹理的相对边缘进行采样 <strong>[885]</strong>  很有用。</li>
<li>边框（border）（DirectX）或夹取到边框（clamp to border）（OpenGL）—— [0，1] 以外的纹理坐标使用单独定义的边框颜色进行渲染。例如，由于纹理的边缘将与边框颜色平滑融合，因此该函数可以很好地将贴图渲染到单色表面上。<img alt="" height="196" src="https://img-blog.csdnimg.cn/20200928201544116.png" width="747"></li>
</ul>
<blockquote>
<p>图6.7 图像纹理的包裹、镜像、夹取、边框函数的效果。</p>
</blockquote>
<p>如图 6.7。可以为每个纹理轴不同地分配这些匹配函数，例如，纹理可以沿 u 轴重复并固定在 v 轴上。在 DirectX 中，还有一个单次镜像模式（mirror once mode），该模式沿着纹理坐标的零值镜像一次纹理，然后进行夹取，这对于对称贴花很有用。</p>
<p>重复平铺纹理是向场景添加更多视觉细节的廉价方法。但是，这种技术在重复大约三遍纹理后通常看起来并不令人信服，因为眼睛会挑选出重复图案。避免此类周期性问题的常见解决方案是将纹理值与另一个非平铺纹理组合。如在 Andersson <strong>[40]</strong>  描述的商业地形绘制系统中所见，这种方法可以被大大地扩展。在该系统中，会基于地形类型，高度，坡度和其他因素组合多个纹理。纹理图像还会与场景中放置几何模型位置相绑定，例如灌木和岩石。</p>
<p>避免周期性的另一种选择是使用着色器程序来实现专门的匹配函数，该函数随机地重新组合纹理图案或图块。王浩瓷砖（Wang tiles）是这种方法的一个例子。一个王浩瓷砖集是一小组具有匹配边缘的正方形瓦片。在纹理化过程中 <strong>[1860]</strong>  会随机选择图块。Lefebvre 和 Neyret <strong>[1016]</strong>  使用相关的纹理读取和表格来实现相似类型的匹配函数，以避图案重复。</p>
<p>应用的最后一个匹配函数边框（border）是隐含的，它是从图像的大小得出的。通常在 u 和 v 的 [0，1] 范围内应用纹理。如砖墙案例所示，通过在该范围内将纹理坐标乘以图像的分辨率，可以获取像素位置。能够在 [0，1] 范围内指定（u，v）值的优点在于，可以交换具有不同分辨率的图像纹理，而不必更改存储在模型顶点处的值。</p>
<h3 id="6-1-3-纹理值-Texture-Values"><a href="#6-1-3-纹理值-Texture-Values" class="headerlink" title="6.1.3 纹理值 Texture Values"></a>6.1.3 纹理值 Texture Values</h3><p>在使用匹配函数生成纹理空间坐标之后，会使用坐标去获取纹理值。对于图像纹理，这是通过访问纹理，并通过从图像中检索纹素信息来完成的。此过程将在 6.2 节中得到广泛的解决。图像纹理构成了实时渲染中绝大多数的纹理使用，但是也可以使用程序化函数（procedural functions）。在程序纹理化的情况下，从纹理空间位置获取纹理值的过程不涉及存储器查找，而是函数的计算。程序化纹理将在 6.3 节中进一步描述。</p>
<p>最直接的纹理值是用于替换或修改表面颜色的 RGB 三元组。类似地，可以返回单个灰度值。另一种要返回的数据是RGBα，如 5.5 节所述。α（α）值通常是颜色的不透明度，它确定颜色可能影响像素的程度。综上所述，也就是说，我们可以存储任何其他值，例如表面粗糙度。我们可以在图像纹理中存储许多其他类型的数据，这将在详细讨论凹凸贴图（bump mapping）时看到（第 6.7 节）。</p>
<p>从纹理返回的值可以在使用前进行转换。这些转换可以在着色器程序中执行。一个常见的例子是将数据从无符号范围（0.0 到 1.0）重新映射到有符号范围（-1.0 到 1.0），该范围用于对存储在颜色纹理中的法线进行着色。</p>
<h2 id="6-2-图像纹理化-Image-Texturing"><a href="#6-2-图像纹理化-Image-Texturing" class="headerlink" title="6.2 图像纹理化 Image Texturing"></a>6.2 图像纹理化 Image Texturing</h2><p>在图像纹理化中，会将二维图像有效地粘贴到一个或多个三角形的表面上。我们已经完成了计算纹理空间位置的过程。现在，我们将解决在给定位置信息后，从图像纹理获取纹理值的相关问题和算法。在本章的其余部分中，图像纹理将简称为纹理（texture ）。另外，当我们在此处引用像素单元（pixel’s cell）时，是指围绕该像素的屏幕网格单元。如第 5.4.1 节所述，像素实际上是显示的颜色值，该颜色值可能（并且应该为了更好的质量）受到与其关联的网格单元外部的样本的影响。</p>
<p>在本节中，我们特别关注快速采样和纹理图像的滤波方法。第5.4.2节讨论了混叠的问题，特别是在渲染对象边缘方面。纹理也可能存在采样问题，但是它们发生在要渲染的三角形内部。</p>
<p>像素着色器通过将纹理坐标值传递给诸如 texture2D 之类的调用来访问纹理。这些值在（u，v）纹理坐标中，由对应功能映射到 [0.0，1.0] 范围。GPU 负责将此值转换为 texel 坐标。不同 API 中的纹理坐标系之间有两个主要区别。在 DirectX 中，纹理的左上角为（0，0），右下角为（1，1）。这与存储图像数据的图像类型匹配，顶行是指文件中的第一行。在OpenGL中，纹理像素（0，0）位于左下角，是 DirectX 的 y 轴翻转。像素具有整数坐标，但是我们经常要访问像素之间的位置，并在它们之间进行混合。这提出了像素中心的浮点坐标是什么的问题。Heckbert <strong>[692]</strong>  讨论了为何有两种可能的系统：截断（truncating）和四舍五入（rounding）。DirectX 9 将每个中心定义为（0.0，0.0）—— 使用四舍五入（rounding）。这个系统有些令人困惑，因为在DirectX 的原点，左上像素的左上角的值是（-0.5，-0.5）。DirectX 10 则向前更改为 OpenGL 的系统，在该系统上，纹理元素的中心具有小数值（0.5、0.5），即截断，或者更准确地讲，是向下取整（flooring），小数部分被丢弃。向下取整是一种更自然的系统，可以很好地映射到语言，例如，像素（5、9）为u坐标定义了 5.0 到 6.0 的范围，为 v 定义了 9.0 到 10.0 的范围。</p>
<p>关于这一点，还有一个值得解释的术语是从属纹理读取（dependent texture read），它有两个定义。第一种特别适用于移动设备。当通过 texture2D 或类似方法访问纹理时，每当像素着色器计算纹理坐标而不是使用从顶点着色器传入的未修改纹理坐标 <strong>[66]</strong>  时，就会产生从属纹理读取。请注意，这意味着对传入的纹理坐标进行任何更改，甚至包括交换 u 和 v 值之类的简单操作。当着色器没有相关纹理读取时，较早的不支持 OpenGL ES 3.0 的移动 GPU 可以更有效地运行，因为这可以预先获取纹理像素数据。该术语的另一个较旧的定义对于早期的台式机 GPU 特别重要。在这种情况下，当一个纹理的坐标取决于某些先前纹理的值的结果时，就会发生从属纹理读取。例如，一种纹理可能会更改着色法线，进而改变用于访问立方体贴图的坐标。在早期的 GPU 上，这种功能受到限制甚至不存在。如今，此类读取可能会影响性能，具体取决于批处理中计算的像素数量以及其他因素。有关的更多信息，请参见第 23.8 节。</p>
<p>GPU 中使用的纹理图像大小通常为 <img alt="2^{m} \times 2^{n}" class="mathcode" src="https://private.codecogs.com/gif.latex?2%5E%7Bm%7D%20%5Ctimes%202%5E%7Bn%7D"> 纹理像素，其中 m 和 n 为非负整数。这些被称为二次幂（power-of-two，POT）纹理。现代 GPU 可以处理任意大小的非 2 幂（non-power-of-two，NPOT）纹理，从而可以将生成的图像视为纹理。但是，某些较旧的移动 GPU 可能不支持 NPOT 纹理的 mipmapping（第 6.2.2 节）。图形加速器对纹理大小有不同的上限。例如，DirectX 12 最多允许 <img alt="16384^{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?16384%5E%7B2%7D"> 个纹理像素。</p>
<p>假设我们有一个 256×256 纹理像素的纹理，并且我们想将其用作正方形的纹理。只要屏幕上投影的正方形与纹理的大小大致相同，正方形的纹理看起来就几乎是原始图像。但是，如果投影的正方形覆盖了原始图像的十倍像素（称为放大，magnification），或者投影的正方形仅覆盖了屏幕的一小部分（缩小，minification），会发生什么呢？ 答案是，这取决于你决定在这两种情况下使用哪种采样和滤波方法。</p>
<p>本章讨论的图像采样和滤波方法适用于从每个纹理读取的值。但是，我们期望的结果是防止最终渲染的图像出现走样，这在理论上要求对最终像素的颜色进行采样和滤波。这里的区别在于着色方程的输入的滤波，或输出的滤波。只要输入和输出是线性相关的（对于诸如颜色的输入来说就是如此），那么单个纹理值的滤波就等于最终颜色的滤波。但是，存储在纹理中的许多着色器输入值（例如表面法线和粗糙度值）与输出具有非线性关系。标准纹理滤波方法可能不适用于这些纹理，从而导致锯齿。在 9.13 节中讨论了用于此类纹理滤波的改进方法。</p>
<h3 id="6-2-1-放大-Magnification"><a href="#6-2-1-放大-Magnification" class="headerlink" title="6.2.1 放大 Magnification"></a>6.2.1 放大 Magnification</h3><p>在图 6.8 中，将大小为 48×48 纹理像素的纹理贴到一个正方形上，并且相对于该纹理大小而言，该正方形的离观察者很近，因此基础图形系统必须放大该纹理。放大倍数最常用的滤波技术是最近邻（nearest neighbor）（实际滤波器称为 box 滤波器，请参见第 5.4.1 节）和双线性插值（bilinear interpolation）。还有三次卷积（cubic convolution），它使用 4× 4或 5×5 纹素阵列的加权和。这样可以实现更高的放大质量。尽管目前尚不普遍支持三次卷积（也称为双三次插值，bicubic interpolation）的本机硬件，但它可以在着色器程序中执行。</p>
<p>在图 6.8 的左侧，使用了最近邻方法。这种放大技术的一个特征是各个纹理像素可能变得明显。我们将该现象称为像素化（pixelation），这是因为该方法在放大时会采用最接近每个像素中心的纹理像素值，从而导致块状的外观。尽管此方法的质量有时很差，但每个像素仅需要提取一个纹理像素。</p>
<p>在中间的肖像图中，使用了双线性插值（有时称为线性插值）。对于每个像素，这种滤波都会找到四个相邻的纹理像素，并在二维上进行线性插值，以找到像素的混合值。可以看到，其结果是模糊的，与使用最近邻方法相比，产生的许多锯齿现象已消失。这里做个小实验，请在眯着眼睛的同时尝试看左边图像，因为此举的效果与低通滤波器大致相同，并且可以使脸部露出更多。</p>
<img alt="" height="270" src="https://img-blog.csdnimg.cn/20200929140934974.png" width="739">

<blockquote>
<p>图 6.8 48×48 图像的纹理放大率为 320×320 像素。左：最近邻滤波，其中每像素选择最近的纹理像素。中：使用四个最近的纹理像素的加权平均值进行双线性滤波。右：使用 5×5 最近的纹理像素的加权平均值进行三次滤波。</p>
</blockquote>
<p>返回到第 170 页的砖墙纹理示例（<strong>译者注：</strong> 在 6.1 开头）：在不丢弃小数的情况下，我们获得了（pu，pv）=（81.92，74.24）。在这里我们使用 OpenGL 的左下原点纹理像素坐标系，因为它能与标准的直角坐标系相匹配。我们的目标是在四个最接近的纹理像素之间进行插值，并使用其纹理像素中心定义一个纹理像素大小的坐标系。见图 6.9。为了找到四个最近的像素，我们从样本位置减去像素中心值（0.5，0.5），得出（81.42，73.74）。丢弃小数部分，四个最接近的像素的范围从（x，y）=（81，73）到（x + 1，y + 1）=（82，74）。在我们的示例中，小数部分（0.42，0.74）是样本相对于由四个纹理像素中心形成的坐标系的位置。我们将此位置表示为（u’，v’）。</p>
<img alt="" height="270" src="https://img-blog.csdnimg.cn/20200929201152604.png" width="734">

<blockquote>
<p>图 6.9 双线性插值。涉及的四个纹理像素由左侧的四个正方形表示，纹理像素中心为蓝色。右边是由四个纹理像素的中心形成的坐标系。</p>
</blockquote>
<p>将纹理访问函数定义为 t（x，y），其中 x 和 y 是整数，并返回纹理像素的颜色。可以将任何位置（u’，v’）的双线性插值颜色计算为两步过程。首先，水平（使用u’）对底部纹理像素t（x，y）和t（x + 1，y）进行插值，类似地，也对最顶部的两个纹理像素t（x，y + 1）和t（ x + 1，y + 1）进行插值。对于底部的纹理像素，我们获得（1 − u’）t（x，y）+ u’t（x + 1，y）（图 6.9 中的底部绿色圆圈），对于顶部的像素，我们得出（1 − u’） t（x，y +1）+ u’t（x +1，y +1）（上方的绿色圆圈）。然后使用 v’ 对这两个值进行垂直插值，因此在 <img alt="(p_{u},p_{v})" class="mathcode" src="https://private.codecogs.com/gif.latex?%28p_%7Bu%7D%2Cp_%7Bv%7D%29"> 处的双线性插值颜色 <img alt="\textbf{b}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Ctextbf%7Bb%7D"> 为</p>
<img alt="" height="135" src="https://img-blog.csdnimg.cn/20200929204338140.png" width="642">

<p>凭直觉，接近我们样本位置的纹理像素将对最终值产生更大的影响。这确实是我们在等式中所看到的。在（x + 1，y +1）处的右上纹理像素具有 u’v’ 的影响。这里请注意对称性：右上的影响等于由左下角和采样点形成的矩形区域。回到我们的示例，这意味着从该纹理像素检索的值将乘以 0.42×0.74，特别是 0.3108。从该纹理像素的顺时针方向，其他乘数分别为 0.42×0.26、0.58×0.26 和 0.58×0.74，所有这四个权重的总和为1.0。</p>
<p>一种解决放大倍率模糊的常见方法是使用细节纹理（detail textures）。这些纹理代表了精细的表面细节，从手机上的划痕到地形上的灌木丛。这样的细节作为单独的纹理以不同的比例覆盖在放大的纹理上。细节纹理的高频重复图案与低频放大的纹理相结合，具有类似于使用单个高分辨率纹理的视觉效果。</p>
<p>双线性插值在两个方向上进行线性插值。但是，线性插值并不是我们想要的。假设纹理由棋盘图案中的黑白像素组成。使用双线性插值会得出整个纹理上变化的灰度样本。通过重新映射这一操作，例如，所有低于 0.4 的灰度都是黑色，所有高于 0.6 的灰度都是白色，并且中间的灰度都被拉伸以填充间隙，这样就可以让纹理看起来更像是棋盘，同时还使纹理像素之间有些融合 。参见图 6.10。</p>
<img alt="" height="238" src="https://img-blog.csdnimg.cn/20200929211708780.png" width="746">

<blockquote>
<p>图 6.10 最近邻，双线性插值，以及通过重新映射介于两者之间的情况，使用相同的2×2棋盘纹理。请注意，由于纹理和图像网格不完全匹配，最近邻采样会给出略有不同的正方形大小。</p>
</blockquote>
<p>使用更高分辨率的纹理将具有相似的效果。例如，假设每个方格正方形由 4×4 的纹理像素而不是 1×1 组成。在每个方格的中心周围，插值的颜色将完全是黑色或白色。</p>
<p>在图 6.8 的右侧，已使用了双三次滤波器，剩余的块状现象已被大大消除。这里需要注意的是，双三次滤波器比双线性滤波器更昂贵。但是，许多高阶滤波器可以表示为重复线性插值 <strong>[1518]</strong> （另请参见第17.1.1节）。其结果，就是可以通过几次的查找来利用纹理单元中用于线性插值的 GPU 硬件。</p>
<p>如果认为双三次滤波器太昂贵，Qu´ılez <strong>[1451]</strong>  提出了一种简单技术，即使用平滑曲线在一组 2×2 纹素之间进行插值。我们首先描述曲线，然后描述技术。两条常用的曲线是平滑步幅曲线（smoothstep curve）和五阶曲线（quintic curve） <strong>[1372]</strong> ：</p>
<img alt="" height="80" src="https://img-blog.csdnimg.cn/20200929210646648.png" width="629">

<p>这些在许多其他情况下都很有用，在这些情况下，你需要从一个值平滑地插值到另一个值。平滑步幅曲线具有 s’（0）= s’（1）=  0 的特性，并且在 0 和 1 之间平滑。五阶曲线具有相同的特性，但是 q’’（0）= q’’ （1）= 0，即，曲线的起点和终点的二阶导数也为 0。两条曲线如图 6.11 所示。</p>
<img alt="" height="262" src="https://img-blog.csdnimg.cn/20200929210940928.png" width="744">

<blockquote>
<p>图 6.11 平滑步幅曲线s（x）（左）和五阶曲线q（x）（右）。</p>
</blockquote>
<p>该技术首先通过将样本乘以纹理尺寸并相加 0.5 来计算（u’，v’）（与公式 6.1 和图 6.9 中使用的相同）。保留整数部分以备后来使用，并将分数存储在 u’ 和 v’ 中，它们在 [0，1] 的范围内。然后将（u’，v’）变换为（tu，tv）=（q（u’），q（v’）），但仍在 [0，1] 的范围内。最后，减去 0.5，再将整数部分相加； 然后，将所得的 u 坐标除以纹理宽度，并以 v 进行类似的操作。此时，新的纹理坐标与 GPU 提供的双线性插值查找配合使用。请注意，此方法将在每个纹理像素处产生平稳状态，这意味着如果这些纹理像素位于 RGB 空间中的平面上，则此类型的插值将给出平滑但仍然呈阶梯状的外观，但这可能不是我们想要的。见图 6.12。</p>
<img alt="" height="175" src="https://img-blog.csdnimg.cn/20200929211441822.png" width="742">

<blockquote>
<p>图 6.12  四种放大一维纹理的方法。橙色圆圈表示纹理像素的中心以及纹理像素值（高度）。从左到右分别是：最近邻、线性、在相邻纹理像素之间使用五阶曲线、使用三次插值。</p>
</blockquote>
<h3 id="6-2-2-缩小-Minification"><a href="#6-2-2-缩小-Minification" class="headerlink" title="6.2.2 缩小 Minification"></a>6.2.2 缩小 Minification</h3><p>当纹理缩小时，多个纹理像素可能会覆盖像素的单元，如图 6.13 所示。为了获得每个像素的正确颜色值，您应该整合影响像素的纹理像素的效果。但是，很难精确地确定特定像素附近所有纹理像素的确切影响，并且实际上，我们不可能实时完美地做到这一点。</p>
<img alt="" height="259" src="https://img-blog.csdnimg.cn/20200929212047552.png" width="739">

<blockquote>
<p>图 6.13  缩小：通过一排像素单元的棋盘纹理的正方形视图，大致显示了许多纹理像素对每个像素的影响。</p>
</blockquote>
<p>由于此限制，在 GPU 上使用了几种不同的方法。一种方法是使用最近邻的像素，它的工作原理与相应的放大滤波器完全相同，即，它选择在像素像元中心可见的纹理像素。该滤波器可能会导致严重的走样问题。在图 6.14 中，最上面的图使用了最近邻方法。在地平线上，会出现伪像，因为我们只选择了影响像素的许多纹理像素之一来表示表面。当表面相对于观察者移动时，这些伪像甚至会更加明显，并且这是我们说的时间性走样（temporal aliasing）的一种表现形式。</p>
<img alt="" height="560" src="https://img-blog.csdnimg.cn/20200930152151253.png" width="722">

<blockquote>
<p>图 6.14 顶部图像是通过点采样（最近邻）渲染的，中心是 mipmapping 渲染的，底部是求和区域表（summed area tables ）的渲染。</p>
</blockquote>
<p>另一个经常被使用的滤波器是双线性插值，其工作原理与放大滤波器完全相同。该滤波器仅比最邻近的方法好一点点。它混合了四个纹理像素，而不是仅使用一个，但是当一个像素受到四个以上纹理像素的影响时，滤波器便会迅速失效并产生走样。</p>
<p>更好的解决方案是可能的。如 5.4.1 节所述，可以通过采样和滤波技术解决走样问题。纹理的信号频率取决于其纹理像素在屏幕上的间隔距离。由于奈奎斯特限制，我们需要确保纹理的信号频率不大于采样频率的一半。例如，一个图像是由交替的黑白线组成的，相隔一个纹理像素。波长为两个纹理像素宽（从黑线到黑线），因此频率为 <img alt="\frac{1}{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B2%7D">。要在屏幕上正确显示此纹理，频率必须至少为 <img alt="2\times \frac{1}{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?2%5Ctimes%20%5Cfrac%7B1%7D%7B2%7D">，即每个纹理像素至少对应一个像素。因此，对于一般的纹理，每个像素最多应只有一个纹理像素，以避免走样。</p>
<p>为了达到这个目标，必须提高像素的采样频率或降低纹理频率。上一章讨论的反走样方法提供了提高像素采样率的方法。但是，这些仅会有限地增加采样频率。为了更充分地解决这个问题，目前已经开发了各种纹理缩小算法。</p>
<p>所有纹理反走样算法背后的基本思想是相同的：对纹理进行预处理并创建数据结构，这将有助于计算像素上一组纹理像素的效果的快速近似值。对于实时渲染，这些算法具有使用固定数量的时间和资源来执行的特征。用这种方式，每个像素会获取固定数量的样本，并将其组合起来以计算（可能很大）数量的纹理像素的效果。</p>
<h4 id="Mip映射-Mipmapping"><a href="#Mip映射-Mipmapping" class="headerlink" title="Mip映射 Mipmapping"></a>Mip映射 Mipmapping</h4><p>最流行的纹理反走样方法称为 mipmapping <strong>[1889]</strong> 。现在已生产的所有图形加速器均以某种形式实现了该功能。“ Mip”在细小语言中代表 multum，在拉丁语中则是“在一个小地方有很多东西”的名字。</p>
<p>当使用 mipmapping 最小化滤镜时，在进行实际渲染之前，使用一组较小版本的纹理增强原始纹理。纹理（零级）下采样（downsampled）到原始面积的四分之一，其中每个新的纹理像素值通常计算为原始纹理中四个相邻纹理像素的平均值。新的一级纹理有时称为原始纹理的子纹理。递归执行缩小操作，直到纹理的一个或两个尺寸等于一个纹理像素。此过程如图 6.15 所示。整个图像集通常称为 mipmap 链（mipmap chain）。</p>
<img alt="" height="424" src="https://img-blog.csdnimg.cn/20200930211150733.png" width="741">

<blockquote>
<p>图 6.15  通过在金字塔的底部拍摄原始图像（级别0），然后将每个 2×2 区域平均为下一级别的纹理像素值，即可形成 mipmap。垂直轴是第三纹理坐标 d。在该图中，d 不是线性的。它用于衡量样本用于插值的两个纹理级别。</p>
</blockquote>
<p>形成高质量 Mipmap 的两个重要元素是良好的滤波和伽马校正。形成 Mipmap 级别的常见方法是获取每 2×2 组像素，并将它们平均以得到 Mip 像素值。这样操作的话，使用的滤波器便被称为 box 滤波器（box filter），它可能是最差的滤波器之一。这可能会导致质量差，因为它会不必要地模糊低频，同时保留一些会引起混叠的高频 <strong>[172]</strong> 。最好使用高斯，Lanczos，Kaiser或类似的滤波器。快速，免费的源代码可用于任务 <strong>[172，1592]</strong> ，并且某些 API 在 GPU 本身上支持更好的滤波。在纹理边缘附近，在滤波期间必须注意纹理是重复还是单个副本。</p>
<p>对于在非线性空间中编码的纹理（例如大多数颜色纹理），在滤波时忽略伽玛校正将会修改感知到的 Mipmap 级别的亮度 <strong>[173，607]</strong> 。当你离对象越来越远并且使用了未经校正的 Mipmap 时，对象的整体外观可能会更暗，并且对比度和细节也会受到影响。因此，重要的是将此类纹理从 sRGB 转换为线性空间（第 5.6 节），在该空间中执行所有 mipmap 滤波，然后将最终结果转换回 sRGB 颜色空间进行存储。大多数 API 支持 sRGB 纹理，因此将在线性空间中正确生成 mipmap，并将结果存储在 sRGB中。访问 sRGB 纹理时，首先将它们的值转换为线性空间，以便正确执行放大和缩小。</p>
<p>正如之前提到的，某些纹理与最终着色颜色具有根本上的非线性关系。尽管这通常会给滤波带来问题，但由于要对数百或数千个像素进行滤波，因此 mipmap 的生成对此问题特别敏感。为了获得最佳的结果，通常需要专门的 mipmap 生成方法。此类方法在第 9.13 节中进行了详细说明。</p>
<p>构造纹理时访问此结构的基本过程很简单。屏幕像素将纹理自身上的区域包围起来。当像素区域投影到纹理上时（图 6.16），它包含了一个或多个纹理像素。严格地说，使用像素的单元格边界并不是正确的方法，但这里我们使用它来简化这个演示。单元外部的纹理像素可能会影响像素的颜色。请参阅第 5.4.1 节。我们的目的是大致确定多少的纹理会影响到像素。有两种用于计算 d 的常用量度（OpenGL 将其称为 λ，它也被称为细节纹理级别，texture level of detail）。一种方法是使用像素单元所形成的四边形的较长边缘，用它来近似像素的覆盖范围 <strong>[1889]</strong> ； 另一种方法是使用四个微分 ∂u/∂x，∂v/∂x，∂u/∂y 和 ∂v/∂y 的最大绝对值作为度量 <strong>[901，1411]</strong> 。每个微分是纹理坐标相对于屏幕轴的变化量的量度。例如，∂u/∂x 是一个像素的 u 纹理值沿 x 屏幕轴的变化量。有关这些方程式的更多信息，请参见Williams的原始文章 <strong>[1889]</strong>  或 Flavell <strong>[473]</strong>  或 Pharr <strong>[1411]</strong>  的文章。McCormack等。**[1160]**  讨论了通过最大绝对值方法会造成走样的问题，并提出了一个替代公式。Ewins等。**[454]**  分析了质量相当的几种算法的硬件消耗。</p>
<img alt="" height="309" src="https://img-blog.csdnimg.cn/2020093022224692.png" width="739">

<blockquote>
<p>图 6.16. 左侧是一个正方形像素单元及其纹理视图。右边是像素单元在纹理本身上的投影。</p>
</blockquote>
<p>使用 Shader Model 3.0 或更高版本的像素着色器程序可以使用这些渐变值。由于它们基于相邻像素值之间的差异，在受动态流控制（dynamic flow control）影响的像素着色器的某些部分中，我们无法访问它们（第 3.8 节）。为了在这样的部分中（例如，在循环内）执行纹理读取，必须较早地计算导数。请注意，由于顶点着色器无法访问渐变信息，因此在使用顶点纹理时，需要在顶点着色器本身中计算渐变或细节级别并将其提供给 GPU。</p>
<p>计算 d 坐标的目的是确定沿 mipmap 的金字塔轴采样的位置。见图 6.15。目标是达到奈奎斯特比率的像素与纹理像素比至少为1：1。这里的重要原理是，随着像素单元包含更多的纹理像素和 d 的增加，将访问更小，更模糊的纹理版本。（u，v，d）三元组用于访问 mipmap。值 d 与纹理级别类似，但是 d 是整数之间的距离的分数，而不是整数值。采样高于 d 位置的纹理级别和低于 d 位置的纹理级别。（u，v）位置用于从这两个纹理级别的每一个中检索双线性插值样本。然后再根据从每个纹理级别到 d 的距离对生成的样本进行线性插值。整个过程称为三线性插值（trilinear interpolation），是逐像素执行的。</p>
<p>d 坐标上的一个用户控制参数是细节偏差水平（level of detail bias，简称 LOD bias，LOD偏差）。这是与 d 相加的值，因此会影响纹理的相对清晰度。如果我们进一步向上移动金字塔以开始（增大d），则纹理将变得模糊。对于任何给定的纹理，良好的 LOD 偏差将随图像类型和使用方式而变化。例如，开始时有些模糊的图像可能会使用负偏差，而用于纹理化的滤波效果差（走样）的合成图像可能会使用正偏差。可以为纹理整体或像素着色器中的每个像素指定偏差。为了更好地控制，用户可以提供 d 坐标或用于计算它的导数。</p>
<p>mipmapping 的好处在于，访问并插值了预组合的像素集，而不是试图求和单独影响像素的所有纹理素。无论缩小多少，此过程都会花费固定的时间。但是，mipmapping 有几个缺陷 <strong>[473]</strong> 。一个主要的缺陷是模糊。想象一下，一个像素单元在 u 方向上覆盖大量纹理像素，而在 v 方向上仅覆盖少数像素。这种情况通常发生在观看者近乎边缘地沿着带纹理的表面观看的时候。实际上，可能需要沿着纹理的一个轴进行最小化，而沿着另一个轴进行放大。访问 mipmap 的效果是检索了纹理上的正方形区域。无法检索矩形区域**(?)**。为避免产生走样，我们选择纹理上像素单元的近似覆盖率的最大度量。这导致检索到的样本通常相对模糊。在图 6.14 的 mipmap 图像中可以看到这种效果。移到右侧距离的线显示为模糊。</p>
<h4 id="求和区域表-Summed-Area-Table"><a href="#求和区域表-Summed-Area-Table" class="headerlink" title="求和区域表 Summed-Area Table"></a>求和区域表 Summed-Area Table</h4><p>避免过度模糊的另一种方法是求和区域表（SAT）**[312]** 。要使用此方法，首先要创建一个数组，该数组的大小等于纹理的大小，但包含更多的颜色存储精度位（例如，红色，绿色和蓝色分别为 16 位或更多）。在此数组的每个位置，必须计算并存储由该位置和纹理像素（0，0）（原点）形成的矩形中所有相应纹理纹理像素的总和。在纹理化过程中，像素单元在纹理上的投影会被矩形所限制。然后访问求和区域表以确定该矩形的平均颜色，该颜色作为像素的纹理颜色传回。使用如图 6.17 所示的矩形的纹理坐标计算平均值。这可以使用公式 6.3 来完成：</p>
<img alt="" height="81" src="https://img-blog.csdnimg.cn/20201003135530567.png" width="609">

<p>在此，x 和 y 是矩形的纹素坐标，而 s [x，y] 是该纹素的求和区域值。该方程的工作原理是：从右上角到原点，取整个区域的总和，然后通过减去相邻角的贡献减去面积 A 和 B 。区域 C 已被减去两次，因此将其添加到左下角。注意（<img alt="x_{ll}" class="mathcode" src="https://private.codecogs.com/gif.latex?x_%7Bll%7D">，<img alt="y_{ll}" class="mathcode" src="https://private.codecogs.com/gif.latex?y_%7Bll%7D">）是区域 C 的右上角，即（<img alt="x_{ll}" class="mathcode" src="https://private.codecogs.com/gif.latex?x_%7Bll%7D"> + 1，<img alt="y_{ll}" class="mathcode" src="https://private.codecogs.com/gif.latex?y_%7Bll%7D"> + 1）是边界盒的左下角。</p>
<p>使用求和区域表的结果如图 6.14 所示。到达地平线的线在右侧边缘附近更加锐利，但中间的对角交叉线仍然模糊不清。问题在于，当沿着纹理的对角线观察纹理时，会生成一个大矩形，其中许多纹理像素不位于要计算的像素附近。例如，假设一个长而细的矩形代表像素单元的反投影，该像素按对角线横跨整个纹理，如图 6.17 所示。此时将返回整个纹理矩形的平均值，而不仅仅是像素单元内的平均值。</p>
<img alt="" height="311" src="https://img-blog.csdnimg.cn/20201004150203520.png" width="734">

<blockquote>
<p>图 6.17 像素单元反投影到纹理上，并以矩形为边界；矩形的四个角用于访问求和区域表。</p>
</blockquote>
<p>求和区域表是所谓的各向异性滤波算法的一个示例 <strong>[691]</strong> 。这样的算法在非正方形区域上检索纹理像素值。但是，SAT 能够在主要水平和垂直方向上最有效地做到这一点。还要注意，对于 16 × 16 或更小的尺寸的纹理，求和区域表至少需要两倍的内存，而较大的纹理则需要更高的精度。</p>
<p>求和区域表可以在现代 GPU 上实现，并以合理的整体内存成本提供更高的质量 <strong>[585]</strong> 。改进的滤波对于高级渲染技术的质量至关重要。例如，Hensley 等。**[718，719]**  提供了一种有效的实现方式，并展示了求和区域采样如何改善光泽反射。可以通过 SAT 改进使用区域采样的其他算法，例如景深（depth of field） <strong>[585，719]</strong> ，阴影图（shadow maps）**[988]**  和模糊反射（blurry reflections）**[718]** 。</p>
<h4 id="无约束各向异性滤波-Unconstrained-Anisotropic-Filtering"><a href="#无约束各向异性滤波-Unconstrained-Anisotropic-Filtering" class="headerlink" title="无约束各向异性滤波 Unconstrained Anisotropic Filtering"></a>无约束各向异性滤波 Unconstrained Anisotropic Filtering</h4><p>对于当前的图形硬件，进一步改善纹理滤波的最常用方法是重用现有的 mipmap 硬件。基本思想是对像素单元进行反投影，然后对纹理上的这个四边形（四边形）进行几次采样，然后合并采样。如上所述，每个 mipmap 样本都有一个位置和一个与其关联的正方形区域。该算法不使用单个 mipmap 样本来近似四边形的覆盖范围，而是使用几个正方形覆盖四边形。可以使用四边形的较短边来确定 d（与 mipmapping 不同，后者通常使用较长边）；这会使每个 Mipmap 样本的平均面积变小（从而减少模糊）。四边形的较长边用于创建平行于较长边并穿过四边形中间的各向异性线。当各向异性的量在 1：1 和 2：1 之间时，沿着这条线采集两个样本（见图 6.18）。在较高的各向异性比率下，沿轴将获取更多的样本。</p>
<img alt="" height="312" src="https://img-blog.csdnimg.cn/20201004154910128.png" width="739">

<blockquote>
<p>图 6.18  各向异性滤波。像素单元的反投影产生四边形。在较长的侧面之间形成各向异性线。</p>
</blockquote>
<p>该方案允许各向异性线沿任何方向延伸，因此没有求和区域表的限制。因为它使用 mipmap 算法进行采样，所以它也不需要比 mipmaps 更多的纹理内存。各向异性滤波的一个例子如图 6.19 所示。</p>
<img alt="" height="298" src="https://img-blog.csdnimg.cn/20201004165656628.png" width="740">

<blockquote>
<p>图 6.19  Mipmap 与各向异性滤波。左侧完成了三线性 mipmapping，右侧进行了 16：1 各向异性滤波。展望未来，各向异性滤波可提供更清晰的结果，同时走样程度最小。（图片来自 three.js 示例webgl材料纹理各向异性 <strong>[218]</strong> 。）</p>
</blockquote>
<p>Schilling 等人首先提出了沿轴采样的想法。与他们的 Texram 动态存储设备 <strong>[1564]</strong> 。Barkans 描述了该算法在 Talisman 系统中的用法 <strong>[103]</strong> 。McCormack等人提出了一个类似的系统，称为Feline。**[1161]** 。Texram的原始配方是沿各向异性轴（也称为探针）给予相同重量的样品。护身符在轴的相对两端将两个探针的重量减半。猫科动物使用高斯滤波器内核对一组探针加权。这些算法采用高质量的软件采样算法，例如椭圆加权平均（EWA）滤波器，该滤波器将像素的影响区域转换为纹理上的椭圆，并通过滤波器内核对椭圆内的纹理像素进行加权[691]。Mavridis和Papaioannou提出了几种在GPU上使用着色器代码实现 EWA 滤波的方法 <strong>[1143]</strong> 。</p>
<h3 id="6-2-3-体积纹理-Volume-Textures"><a href="#6-2-3-体积纹理-Volume-Textures" class="headerlink" title="6.2.3 体积纹理 Volume Textures"></a><strong>6.2.3 体积纹理 Volume Textures</strong></h3><p>图像纹理的直接扩展是通过（u，v，w）（或（s，t，r）值）访问的三维图像数据。例如，医学成像数据可以被生成为三维网格。通过在该网格中移动多边形，可以查看这些数据的二维切片。一个相关的想法是用这种形式表示体积的灯光。通过找到其在该体积内的位置值以及光的方向，可以找到表面上某个点的照明。</p>
<p>大多数 GPU 支持对体积纹理进行 mipmapping。由于在体积纹理的单个 mipmap 级别内进行滤波涉及三线性插值，因此在 mipmap 级别之间进行滤波需要四线性插值。由于这涉及对 16 个纹理像素的结果进行平均，因此可能会导致精度问题，可以使用更高精度的体积纹理来解决。Sigg 和 Hadwiger  <strong>[1638]</strong>  讨论了与体积纹理有关的此问题和其他问题，并提供了执行滤波和其他操作的有效方法。</p>
<p>尽管体积纹理具有更高的存储要求，并且滤波成本更高，但它们确实具有一些独特的优势。由于可以将三维位置直接用作纹理坐标，因此可以跳过为三维网格找到良好的二维参数化的复杂过程。这避免了二维参数化中常见的变形和接缝问题。体积纹理也可以用于表示诸如木材或大理石的材料的体积结构。具有这种纹理的模型看起来是用这种材料雕刻而成的。</p>
<p>由于不使用绝大多数样本，因此使用体积纹理进行表面纹理化的效率极低。Benson 和 Davis <strong>[133]</strong>  和 DeBry 等人。**[334]**  讨论了在稀疏八叉树（sparse octree）结构中存储纹理数据。该方案非常适合交互式三维绘画系统，因为在创建时不需要为表面分配明确的纹理坐标，并且八叉树可以将纹理细节保持在所需的任何级别。Lefebvre 等。**[1017]**  讨论了在现代 GPU 上实现八叉树纹理的细节。Lefebvre 和 Hoppe <strong>[1018]</strong>  讨论了将稀疏体积数据打包为明显较小的纹理的方法。</p>
<h3 id="6-2-4-立方体贴图-Cube-Maps"><a href="#6-2-4-立方体贴图-Cube-Maps" class="headerlink" title="6.2.4 立方体贴图 Cube Maps"></a>6.2.4 立方体贴图 Cube Maps</h3><p>另一类纹理是立方体纹理或立方体贴图，它具有六个方形纹理，每个纹理与一个立方体的一个面相关联。使用三分量纹理坐标向量访问立方体贴图，该向量指定了从立方体中心向外指向的光线的方向。光线与立方体相交的点如下。具有最大幅度的纹理坐标选择相应的面部（例如，向量（-3.2、5.1，-8.4）选择 -z 面部）。其余两个坐标除以最大幅度坐标的绝对值，即 8.4。它们现在的范围是 -1 到 1，并且只需将其重新映射到 [0，1] 即可计算纹理坐标。例如，坐标（-3.2，5.1）映射为（（-3.2 / 8.4 + 1）/ 2，（5.1 / 8.4 + 1）/ 2）≈（0.31，0.80）。多维数据集贴图用于表示作为方向函数的值； 它们最常用于环境映射（第10.4.3节）。</p>
<h3 id="6-2-5-纹理表示-Texture-Representation"><a href="#6-2-5-纹理表示-Texture-Representation" class="headerlink" title="6.2.5 纹理表示 Texture Representation"></a>6.2.5 纹理表示 Texture Representation</h3><p>处理应用程序中的许多纹理时，有几种提高性能的方法。纹理压缩在第 6.2.6 节中介绍，而本节的重点是纹理图集，纹理阵列和无绑定纹理，所有这些目的都是为了避免渲染时更改纹理造成的成本。在 19.10.1 和 19.10.2 节中，描述了纹理流和转码。</p>
<p>为了能够为 GPU 分配尽可能多的工作，通常最好更改状态的操作要尽可能少（第18.4.2节）。为此，可以将几张图像放在一个较大的纹理中，我们称为纹理图集。这在图 6.20 的左侧有说明。注意，子纹理的形状可以是任意的，如图 6.6 所示。Néoll 和 Stricker <strong>[1286]</strong>  描述了子纹理放置图集的优化。由于 mipmap 的上层可能包含几个单独的，不相关的形状，因此也需要注意 mipmap 的生成和访问。Manson 和 Schaefer <strong>[1119]</strong>  提出了一种通过考虑表面的参数化来优化 mipmap 创建的方法，该方法可以产生更好的结果。Burley 和 Lacewell <strong>[213]</strong>  提出了一个称为 Ptex 的系统，其中细分曲面中的每个四边形都有自己的小纹理。优点是，这避免了在网格上分配唯一的纹理坐标，并且在纹理图集的不连续部分的接缝处没有伪像（artifacts）。为了能够跨四边形进行滤波，Ptex 使用了邻接数据结构。当最初的目标是产品渲染时，Hillesland <strong>[746]</strong>  提出了打包的 Ptex（packed Ptex），它将每个面的子纹理放入纹理集，并使用相邻面的填充来避免滤波时的不连续性。Yuksel <strong>[1955]</strong>  提出了网格颜色纹理（mesh color textures），该纹理在 Ptex 上有所改进。Toth <strong>[1780]</strong>  通过实现一种方法，在滤波器抽头超出 [0，1]<img alt="^{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5E%7B2%7D"> 的范围时将其丢弃，从而为类似 Ptex 的系统提供了跨表面的高质量滤波。</p>
<img alt="" height="338" src="https://img-blog.csdnimg.cn/20201004174647308.png" width="744">

<blockquote>
<p>图 6.20  左：一个纹理图集，其中将九个较小的图像合成为一个大纹理。右：一种更现代的方法是将较小的图像设置为纹理数组，这是大多数 API 中都存在的概念。</p>
</blockquote>
<p>使用图集的一个困难是包裹/重复和镜像模式，这不会作用到子纹理，而只会作用到整个纹理。为图集生成 mipmap 时，可能会发生另一个问题，其中一个子纹理会渗入另一个子纹理。但是，这可以通过在将每个子纹理放入大型纹理集之前分别为它们生成 mipmap 层次结构，并对子纹理使用 2 的幂次分辨率来避免这种情况 <strong>[1293]</strong> 。</p>
<p>解决这些问题的一种更简单的解决方案是使用一种称为纹理数组（texture arrays） 的 API 构造，该构造完全避免了 mipmapping 和重复模式的所有问题 <strong>[452]</strong> 。参见图 6.20 的右侧。纹理数组中的所有子纹理都必须具有相同的尺寸、格式、mipmap 层次结构和 MSAA 设置。就像纹理地图集一样，仅对纹理数组执行一次设置，然后就可以使用着色器中的索引访问任何数组元素。这比绑定每个子纹理 <strong>[452]</strong>  快 5 倍。</p>
<p>API 还支持无绑定纹理（bindless textures） <strong>[1407]</strong> ，这也可以帮助避免状态更改的成本。如果没有无约束纹理，则使用 API 将纹理绑定到特定的纹理单元。其中一个问题是纹理单元数量的上限，这会使程序员感到麻烦。驱动程序确保纹理位于 GPU 侧。使用无绑定纹理时，纹理数量没有上限，因为每个纹理仅由一个 64 位指针（有时称为“句柄”，handle）与其数据结构相关联。可以通过许多不同方式来访问这些句柄，例如，通过 uniforms，通过变化的数据，来自其他纹理或从着色器存储缓冲区对象（SSBO）。应用程序需要确保纹理驻留在 GPU 端。无边界纹理避免了驱动程序中的任何类型的绑定成本，从而使渲染速度更快。</p>
<h3 id="6-2-6-纹理压缩-Texture-Compression"><a href="#6-2-6-纹理压缩-Texture-Compression" class="headerlink" title="6.2.6 纹理压缩 Texture Compression"></a>6.2.6 纹理压缩 Texture Compression</h3><p>直接解决内存和带宽问题以及缓存问题的一种方案是固定比率纹理压缩（fifixed-rate texture compression） <strong>[127]</strong> 。通过让 GPU 即时解码压缩的纹理，纹理可以需要更少的纹理内存，因此可以增加有效的缓存大小。至少同样重要的是，此类纹理的使用效率更高，因为它们在访问时消耗的内存带宽更少。一个相关但不同的用例是添加压缩以提供更大的纹理。例如，在 <img alt="512^{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?512%5E%7B2%7D"> 分辨率下每个纹理像素使用 3 字节的非压缩纹理将占用 768 kB。使用纹理压缩时，压缩比为6：1，<img alt="1024^{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?1024%5E%7B2%7D"> 纹理将仅占用 512 kB。</p>
<p>图像文件格式（例如 JPEG 和 PNG）中使用了多种图像压缩方法，但是在硬件中对其进行解码的消耗是昂贵的（有关信息纹理的转码，请参见19.10.1节）。S3 开发了一种称为 S3 纹理压缩（S3 Texture Compression，S3TC）**[1524]**  的方案，该方案被选作 DirectX 的标准，并称为 DXTC。在 DirectX 10 中，它称为 BC（用于块压缩）。此外，它是 OpenGL 中的事实上的标准，因为几乎所有 GPU 都支持它。它具有创建大小固定的压缩图像的优点，压缩图像具有独立编码的片段，并且解码简单（因此快速）。图像的每个压缩部分都可以独立处理。没有共享的查找表或其他依赖项，从而简化了解码。</p>
<p>DXTC / BC 压缩方案有七个变体，它们具有一些共同的属性。编码是在 4×4 纹素块（也称为图块）上完成的。每个块分别编码。编码基于插值。对于每个编码量，存储两个参考值（例如，颜色）。将为该块中的 16 个纹理像素的每一个保存一个插值因子。它沿着两个参考值之间的直线选择一个值，即它等于或从两种存储的颜色进行插值的颜色。压缩来自仅存储两种颜色以及每个像素较短的索引值。<br>|<strong>名字（Names）</strong>|<strong>存储（Storage）</strong>|<strong>参考颜色（Ref colors）</strong>|<strong>标记（Indices）</strong>|<strong>透明度（Alpha）</strong>|<strong>备注（Comment）</strong><br>|——|—–|—–|—–|——|—–|<br>|BC1 / DXT1|8 B / 4 bpt|RGB565 x 2|2 bpt|-|1 line<br>|BC2 / DXT3|16 B / 8 bpt|RGB565 x 2|2 bpt|4 bpt raw|与 BC1 同颜色<br>|BC3 / DXT5|16 B / 8 bpt|RGB565 x 2|2 bpt|3 bpt interp.|与 BC1 同颜色<br>|BC4|8 B / 4 bpt|R8 x 2|3 bpt|-|1 channel<br>|BC5|16 B / 8 bpt|RG88 x 2|2 x 3 bpt|-|2x BC4<br>|BC6H|16 B / 8 bpt|见下文|见下文|-|针对 HDR；1-2 行<br>|BC7|8 B / 4 bpt|见下文|见下文|可选|1-3 行</p>
<blockquote>
<p>表6.1 纹理压缩格式。所有这些压缩块均为4×4纹素。存储列显示每个块的字节数（B）和每个texel的位数（bpt）。参考颜色的表示法是首先是通道，然后是每个通道的位数。例如，RGB565 表示红色和蓝色为5位，而绿色通道为6位。</p>
</blockquote>
<p>确切的编码在这七个变体之间有所不同，表 6.1 对此进行了总结。请注意，“ DXT” 表示 DirectX 9 中的名称，“ BC” 表示 DirectX 10 及更高版本中的名称。从表中可以看出，BC1具有两个16位参考RGB值（5位红色，6个绿色，5个蓝色），每个纹理像素具有 2 位插值因子，可以从参考值之一或两个中间值中进行选择。与未压缩的 24 位 RGB 纹理相比，这表示 6：1 的纹理压缩率。BC2 以与 BC1 相同的方式对颜色进行编码，但为量化（原始）alpha 值每纹理像素（bpt）添加4位。对于 BC3，每个块都有以与 DXT1 块相同的方式编码的 RGB 数据。此外，使用两个 8 位参考值和每个像素 3 位插值因子对 alpha 数据进行编码。每个纹理像素可以选择参考 alpha 值之一或六个中间值之一 **(1)**。BC4 具有一个通道，在 BC3 中编码为 alpha。BC5 包含两个通道，每个通道都像 BC3 中那样进行编码。</p>
<p>BC6H 用于高动态范围（HDR）纹理，其中每个纹理像素最初每个 R，G 和 B 通道具有 16 位浮点值。此模式使用 16 个字节，导致 8 bpt 。它具有用于单行的一种模式（类似于上述技术），以及用于两行的另一种模式，其中每块纹理可以从一小组分区中进行选择。两种参考颜色也可以进行增量编码以获得更高的精度，并且根据所使用的模式，它们也可以具有不同的精度。在 BC7 中，每个纹理块可以包含一到三行，并存储 8 bpt。我们的目标是 8 位 RGB 和 RGBA 纹理的高质量纹理压缩。它与 BC6H 共享许多属性，但是却是 LDR 纹理的格式，而 BC6H 是 HDR 的格式。请注意，在 OpenGL 中，BC6H 和 BC7 分别称为 BPTC FLOAT 和 BPTC。立方体或体积纹理以及二维纹理都可以应用这些压缩技术。</p>
<p><strong>作者注：</strong></p>
<p><strong>(1)</strong> 备用 DXT1 模式为透明像素保留了四个可能的插值因子之一，从而将插值的数量限制为三个，即两个参考值及其平均值。</p>
<img alt="" height="234" src="https://img-blog.csdnimg.cn/20201008013610956.png" width="741">

<blockquote>
<p>图 6.21  ETC（爱立信纹理压缩）对像素块的颜色进行编码，然后修改每个像素的亮度以创建最终的纹理像素颜色。（图像由JacobStr¨om压缩。）</p>
</blockquote>
<p>这些压缩方案的主要缺点是它们是有损的。也就是说，通常无法从压缩版本中检索原始图像。对于 BC1 - BC5，仅使用四个或八个插值来表示 16 个像素。如果图块中包含更多数量的不同值，则会有一些损失。实际上，如果正确使用，这些压缩方案通常会提供可接受的图像保真度。</p>
<p>BC1 - BC5 的问题之一是，用于块的所有颜色都位于 RGB 空间中的直线上。例如，红色，绿色和蓝色不能在一个块中表示。BC6H 和 BC7 支持更多的线路，因此可以提供更高的质量。</p>
<p>对于 OpenGL ES，选择了另一种称为爱立信纹理压缩（Ericsson texture compression，ETC）**[1714]**  的压缩算法以包含在 API 中。该方案具有与 S3TC 相同的功能，即快速解码，随机访问，无间接查找和固定速率。它将 4×4 像素的块编码为 64 位，即每个纹理像素使用 4 位。基本思想如图 6.21 所示。每个 2×4 块（或 4×2 块，取决于提供最佳质量的块）都存储底色。每个块还从一个小的静态查找表中选择一组四个常量，并且块中的每个纹理像素都可以选择添加此表中的值之一。这种方法修改了每个像素的亮度。其图像质量与 DXTC 相当。</p>
<p>在 OpenGL ES 3.0 中包含的 ETC2 <strong>[1715]</strong>  中，未使用的位组合用于为原始的 ETC 算法添加更多模式。未使用的比特组合为压缩表示（例如 64 位），它被压缩为与另一压缩表示相同的图像。例如，在 BC1 中，将两个参考颜色设置为相同是没有用的，因为这将指示恒定的色块，只要一种参考颜色包含该恒定色，则可以依次获得该恒定色块。在 ETC 中，一种颜色也可以从第一种颜色加上带符号的数字进行增量编码，因此计算可能会上溢或下溢。这种情况被用来表示其他压缩模式。ETC2 添加了两个新模式，每个块具有四种颜色（以不同方式派生），而最终模式是 RGB 空间中的一个平面，用于处理平滑过渡。爱立信Alpha压缩（Ericsson alpha compression，EAC）**[1868]**  用一个分量（例如 Alpha）压缩图像。这种压缩类似于基本的 ETC 压缩，但仅用于一个分量，并且结果图像的每个像素纹理存储 4 位。可以选择将其与ETC2组合使用，此外，可以使用两个 EAC 通道来压缩法线（有关此主题的更多信息，请参见下文）。所有的 ETC1，ETC2 和 EAC 都是 OpenGL 4.0 核心配置文件，OpenGL ES 3.0， Vulkan 和 Metal 的一部分。</p>
<p>压缩法线贴图（在第 6.7.2 节中讨论）时需要格外小心。专为 RGB 颜色设计的压缩格式通常无法正常显示 xyz 数据。大多数方法都利用这样的事实，即已知法线为单位长度，并进一步假定其 z 分量为正（正切空间法线的合理假设）。这仅允许存储法线的 x 和 y 分量。z 分量是动态导出的</p>
<img alt="" height="67" src="https://img-blog.csdnimg.cn/20201009134449683.png" width="477">

<p>由于仅存储两个分量，而不是三个，因此它本身会导致一定的压缩。由于大多数 GPU 本身并不支持三分量纹理，因此这也避免了浪费分量的可能性（或必须在第四分量中打包其他数量的分量）。通常，通过将 x 和 y 分量存储在BC5 / 3Dc格式纹理中，可以实现进一步的压缩。参见图 6.22。由于每块的参考值划分了最小和最大 x 和 y 分量值，因此可以将它们视为在 xy 平面上定义边界框。三位插值因子允许在每个轴上选择八个值，因此会将边界框划分为 8×8 的可能的法线网格。或者，可以使用 EAC 的两个通道（用于 x 和 y），然后按照上面的定义计算 z。</p>
<img alt="" height="280" src="https://img-blog.csdnimg.cn/20201009135120508.png" width="740">

<blockquote>
<p>图 6.22  左：球体上的法线单位只需要编码 x 和 y 分量。右：对于 BC4 / 3Dc，xy 平面中的一个框将法线围起来，每 4×4 个法线块可在此框内使用 8×8 个法线（为清楚起见，此处仅显示 4×4 个法线）。</p>
</blockquote>
<p>在不支持 BC5 / 3Dc 或 EAC 格式的硬件上，常见的回退（fallback） <strong>[1227]</strong>  是使用 DXT5 格式的纹理并将两个分量存储在绿色和 alpha 分量中（因为这些分量的存储精度最高） 。其他两个分量未使用。</p>
<p>PVRTC <strong>[465]</strong>  是 Imagination Technologies 研发的在名为 PowerVR 的硬件上可用的纹理压缩格式，其最广泛的用途是用于 iPhone 和 iPad。它为每个纹理像素提供 2 位和 4 位的方案，并压缩 4×4 纹理像素的块。其关键思想是提供图像的两个低频（平滑）信号，这些信号是使用相邻的像素数据块进行插值获得的。然后，每个纹理像素使用 1 或 2 位在图像上的两个信号之间进行插值。</p>
<p>自适应可伸缩纹理压缩（Adaptive scalable texture compression，ASTC）**[1302]**  的不同之处在于，它将 n×m 纹理像素的块压缩为 128 位。块大小从 4×4 到 12×12 不等，这导致了不同的比特率，从每纹理像素低至 0.89 位到每纹理像素高达 8 位。ASTC 使用多种技巧来实现紧凑的索引表示，并且每个块都可以选择行数和端点编码。此外，ASTC 可以处理每个纹理 1 至 4 个通道以及 LDR 和 HDR 纹理。ASTC 是 OpenGL ES 3.2 及更高版本的一部分。</p>
<p>上面介绍的所有纹理压缩方案都是有损的，并且在压缩纹理时，可以选择在此过程上花费不同的时间。可以花几秒钟甚至几分钟来进行压缩，以获得更高的质量。因此，该过程通常是作为脱机预处理完成的，并且会存储起来供以后使用。另外，如果只花费几毫秒的时间压缩，那结果的质量会较低，但是这样的话纹理可以实时压缩并立即使用。关于实时压缩的一个例子是天空盒（第13.3节），每隔一秒左右就会重新生成一次，此时云层可能已经略微移动了。由于解压缩是使用固定功能的硬件完成的，因此该过程的速度非常快。其中压缩的过程会并且确实比解压缩花费更长的时间，这种差异称为数据压缩不对称（data compression asymmetry）。</p>
<p>Kaplanyan <strong>[856]</strong>  提出了几种可以改善压缩纹理质量的方法。对于包含颜色的纹理和法线贴图，建议使用每个分量 16 位的方式创作贴图。对于彩色纹理，执行直方图重归一化（histogram renormalization）（在这16位上），然后使用着色器中的比例和偏置常数（每个纹理）反转其效果。直方图归一化是一种将图像中使用的值扩展到整个范围的技术，这实际上是一种对比度增强。每个分量使用 16 位可确保在重新归一化后直方图中没有闲置的时隙，这减少了许多纹理压缩方案可能引入的条带失真。如图 6.23 所示。此外，如果75％的像素高于116/255，Kaplanyan建议对纹理使用线性颜色空间，否则将纹理存储在sRGB中。对于法线贴图，他还指出BC5 / 3Dc通常独立于y来压缩x，这意味着并非总能找到最佳法线。相反，他建议对法线使用以下错误度量：</p>
<img alt="" height="65" src="https://img-blog.csdnimg.cn/20201009203616521.png" width="496">

<p>其中 <img alt="\textbf{n}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Ctextbf%7Bn%7D"> 是原始法线，<img alt="\textbf{n}_{c}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Ctextbf%7Bn%7D_%7Bc%7D"> 是相同的法线压缩，然后解压缩。</p>
<img alt="" height="263" src="https://img-blog.csdnimg.cn/20201009203803303.png" width="739">

<blockquote>
<p>图 6.23  每个分量使用 16 位的效果，而纹理压缩时使用 8 位的效果。从左到右：原始纹理，DXT1 从每个分量 8 位压缩，DXT1 从每个分量 16 位压缩，并在着色器中进行了重新归一化。为了更清楚地显示效果，已在强光下渲染了纹理。（图片由 Anton Kaplanyan 提供。）</p>
</blockquote>
<p>应当注意，还可以在不同的颜色空间中压缩纹理，这可以用来加速纹理压缩。常用的变换是 <img alt="RGB\rightarrow YC_{o}C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?RGB%5Crightarrow%20YC_%7Bo%7DC_%7Bg%7D"><strong>[1112]</strong> ：</p>
<img alt="" height="91" src="https://img-blog.csdnimg.cn/20201009204034796.png" width="572">

<p>其中，<img alt="Y" class="mathcode" src="https://private.codecogs.com/gif.latex?Y"> 是亮度项，<img alt="C_{o}" class="mathcode" src="https://private.codecogs.com/gif.latex?C_%7Bo%7D"> 和 <img alt="C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?C_%7Bg%7D"> 是色度项。逆变换的消耗也并不昂贵：</p>
<img alt="" height="50" src="https://img-blog.csdnimg.cn/20201009204105406.png" width="644">

<p>这仅仅相当于做了几次加法。可以从公式 6.6 中看出，这两个变换是线性的，它是矩阵向量乘法，其本身即是线性的（请参见公式 4.1 和 4.2）。这一点很重要，因为我们可以存储 <img alt="YC_{o}C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?YC_%7Bo%7DC_%7Bg%7D">，而不是将 RGB 存储在纹理中。纹理处理器仍然可以在 <img alt="YC_{o}C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?YC_%7Bo%7DC_%7Bg%7D"> 空间中执行滤波，然后像素着色器可以根据需要转换回 RGB。应该注意的是，这种变换本身是有损的，这可能会有问题，也可能不会。</p>
<p>还有另一个可逆的 <img alt="RGB\rightarrow YC_{o}C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?RGB%5Crightarrow%20YC_%7Bo%7DC_%7Bg%7D"> 变换，可以总结为</p>
<img alt="" height="130" src="https://img-blog.csdnimg.cn/20201009205009234.png" width="629">

<p>符号 ≫ 为右移运算。这里的意思是可以在例如 24 位 RGB 颜色和相应的 <img alt="YC_{o}C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?YC_%7Bo%7DC_%7Bg%7D"> 表示之间进行来回转换而不会造成任何损失。应该注意的是，如果 RGB 中的每个分量都具有 n 位，则 <img alt="C_{o}" class="mathcode" src="https://private.codecogs.com/gif.latex?C_%7Bo%7D"> 和 <img alt="C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?C_%7Bg%7D"> 均具有 n +1 位，以确保可逆变换。<img alt="Y" class="mathcode" src="https://private.codecogs.com/gif.latex?Y"> 虽然只需要 n 位。Van Waveren 和 Casta〜no <strong>[1852]</strong>  使用有损 <img alt="YC_{o}C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?YC_%7Bo%7DC_%7Bg%7D"> 变换在 CPU 或 GPU 上实现对 DXT5 / BC3 的快速压缩。它们将 <img alt="Y" class="mathcode" src="https://private.codecogs.com/gif.latex?Y"> 存储在 alpha 通道中（因为它具有最高的精度），而 <img alt="C_{o}" class="mathcode" src="https://private.codecogs.com/gif.latex?C_%7Bo%7D"> 和 <img alt="C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?C_%7Bg%7D"> 存储在 RGB 的前两个分量中。由于 <img alt="Y" class="mathcode" src="https://private.codecogs.com/gif.latex?Y"> 分别存储和压缩，因此压缩变得很快。对于 <img alt="C_{o}" class="mathcode" src="https://private.codecogs.com/gif.latex?C_%7Bo%7D"> 和 <img alt="C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?C_%7Bg%7D"> 组分，他们找到一个二维边界框，并选择产生最佳结果的对角线框。请注意，对于在 CPU 上动态创建的纹理，最好也压缩 CPU 上的纹理。通过在 GPU 上渲染来创建纹理时，通常最好也压缩 GPU 上的纹理。<img alt="YC_{o}C_{g}" class="mathcode" src="https://private.codecogs.com/gif.latex?YC_%7Bo%7DC_%7Bg%7D"> 变换和其他亮度色度变换通常用于图像压缩，其中色度分量在 2×2 像素上平均。这样可将存储量减少 50％，并且由于色度趋于缓慢变化，因此通常可以正常工作。Lee-Steere 和 Harmon <strong>[1015]</strong>  通过将其转换为色相饱和度值（HSV），将色相和饱和度下采样 x 和 y 的系数为 4，并将值存储为单通道 DXT1 纹理，从而更进一步。Van Waveren 和 Casta〜no 也描述了法线图压缩的快速方法 <strong>[1853]</strong> 。</p>
<p>Griffin 和 Olano <strong>[601]</strong>  的研究表明，将多个纹理应用于具有复杂着色模型的几何模型时，纹理的质量通常可以很低，但却不会有明显的视觉差异。因此，根据使用情况，降低质量是可以接受的。Fauconneau <strong>[463]</strong>  提出了 DirectX 11 纹理压缩格式的 SIMD 实现。</p>
<h2 id="6-3-程序纹理-Procedural-Texturing"><a href="#6-3-程序纹理-Procedural-Texturing" class="headerlink" title="6.3 程序纹理 Procedural Texturing"></a>6.3 程序纹理 Procedural Texturing</h2><p>给定纹理空间位置，执行图像查找是生成纹理值的一种方法。另一个办法是计算一个函数，从而产生程序纹理（procedural texture）。</p>
<p>尽管程序纹理通常在脱机渲染的应用程序中使用，而图像纹理在实时渲染中更为常见。但这是由于现代 GPU 中图像纹理化硬件的极高效率造成的，它可以在一秒钟内执行数十亿次纹理访问。但是，GPU 体系结构正在朝着更低廉的计算和（相对）更昂贵的内存访问发展。这些趋势已使程序纹理在实时应用程序中得到了更多的使用。</p>
<p>考虑到体积图像纹理的高昂的存储成本，体积纹理对于程序纹理方法来说特别有吸引力。我们可以通过多种技术来合成这样的纹理。最常见的方法之一是使用一个或多个噪声函数来生成值 <strong>[407、1370、1371、1372]</strong> 。参见图 6.24。噪声函数通常在两个连续的二次方频率（称为八度，octaves）上采样。每个八度都有权重，通常随着频率的增加而降低，这些加权样本的总和称为湍流函数（turbulence function）。</p>
<img alt="" height="363" src="https://img-blog.csdnimg.cn/20201009212839436.png" width="743">

<blockquote>
<p>图 6.24使用体积纹理进行实时程序纹理化的两个示例。左侧的大理石是使用光线步进（ray marching）渲染的半透明体积纹理。在右侧，该对象是使用复杂的程序木质着色器 <strong>[1054]</strong>  生成并在现实环境中合成的合成图像。（左图来自 Shadertoy 的“Playing marble”，由圣安妮·古利特（St´ephane Guillitte 提供）。右图由 Autodesk，Inc.的尼古拉斯·萨瓦（Nicolas Savva）提供。</p>
</blockquote>
<p>由于计算噪声函数的成本，通常会预先计算三维阵列中的晶格点，并将其用于内插纹理值。有多种使用颜色缓冲区混合来快速生成这些数组的方法 <strong>[1192]</strong> 。Perlin <strong>[1373]</strong>  提出了一种快速，实用的方法来对该噪声函数进行采样，并展示了一些用途。Olano <strong>[1319]</strong>  提供了噪声生成算法，允许在存储纹理和执行计算之间进行权衡。McEwan等。**[1168]**  开发了无需任何查找即可在着色器中计算经典噪声（classic noise）和 Simplex 噪声（simplex noise）的方法，并且提供了源代码。Parberry <strong>[1353]</strong>  使用动态编程在多个像素上摊销计算，以加快噪声计算。Green <strong>[587]</strong>  提供了一种更高质量的方法，但是对于接近交互的应用程序，它意味着更多的方法，因为它使用 50 像素着色器指令进行一次查找。Perlin <strong>[1370，1371，1372]</strong>  提出的原始噪声函数可以进行改进。Cook 和 DeRose <strong>[290]</strong>  提出了另一种表示形式，称为小波噪声，它避免了走样问题，而评估成本仅增加了一点点。Liu 等。**[1054]**  使用各种噪声函数来模拟不同的木材纹理和表面光洁度。另外，我们还推荐阅读 Lagae 等人 <strong>[956]</strong>  关于该话题的最新报告。</p>
<p>其他程序化方法也是可行的。例如，通过测量从每个位置到散布在空间中的一组“特征点”之间的距离来形成细胞纹理。以各种方式（例如更改颜色或着色法线）映射所得到的最接近距离，可以创建一些看起来像细胞，石板，蜥蜴皮和其他自然纹理的图案。Griffiths <strong>[602]</strong>  讨论了如何有效地找到最近邻并在 GPU 上生成蜂窝状纹理。</p>
<p>程序纹理的另一种类型是物理模拟或其他交互过程的结果，例如水波纹或扩展裂缝。在这种情况下，程序纹理可以对动态条件做出有效的、无限的变化。</p>
<p>当生成程序化二维纹理时，参数化问题可能比创作的纹理面临更大的困难，在创作的纹理中，可以手动修改或解决拉伸或接缝伪像。一种解决方案是通过将纹理直接合成到表面上来完全避免参数化。在复杂的表面上执行此操作在技术上具有挑战性，并且是研究的活跃领域。有关该领域的概述，请参见 Wei 等人的文章 <strong>[1861]。</strong></p>
<p>反走样的程序纹理与反走样的图像纹理相比既困难又容易。一方面，诸如 mipmapping 之类的预计算方法不可用，这给程序员带来了负担。另一方面，程序纹理的开发者具有有关纹理内容的“内部信息”，因此可以对其进行调整以避免走样。对于通过对多个噪声函数求和而创建的程序纹理尤其如此。每个噪声函数的频率都是已知的，因此可以丢弃任何会引起走样的频率，从而在实际上降低了计算成本。有多种技术可以消除其他类型的程序纹理的锯齿 <strong>[407、605、1392、1512]</strong> 。Dorn 等人 <strong>[371]</strong>  讨论了先前的工作，并提出了一些用于重新构造纹理函数以避免高频（即被频带限制，band-limited）的过程。</p>
<h2 id="6-4-纹理动画-Texture-Animation"><a href="#6-4-纹理动画-Texture-Animation" class="headerlink" title="6.4 纹理动画 Texture Animation"></a>6.4 纹理动画 Texture Animation</h2><p>应用于表面的图像不必是静态的。例如，视频源就可以用作逐帧变化的纹理。</p>
<p>纹理坐标也不必是静态的。应用程序设计人员可以在网格的数据本身中，或通过应用在顶点或像素着色器中的函数，在帧与帧之间显式地更改纹理坐标。想象一下，假设我们已经对瀑布进行了建模，并用看起来像落水的图像对其进行了纹理处理。我们假定 v 坐标是流向。为了使水运动，必须在每个连续帧的 v 坐标中减去一个量。从纹理坐标中减去的效果就是使纹理本身看起来向前移动。</p>
<p>通过将矩阵变换应用于纹理坐标可以创建更精细的效果。除了平移之外，还允许进行线性变换，例如缩放，旋转和剪切 <strong>[1192，1904]</strong> ，图像扭曲（image warping）和变形变换（morphing transforms）**[1729]**  以及广义投影（generalized projections）**[638]** 。通过在CPU或着色器中应用功能，可以创建更多精致的效果。</p>
<p>通过使用纹理混合技术，可以实现其他动画效果。例如，通过从大理石质地开始并以肉色进行褪色，可以使雕像变为活物 <strong>[1215]</strong> 。</p>
<h2 id="6-5-材质映射-Material-Mapping"><a href="#6-5-材质映射-Material-Mapping" class="headerlink" title="6.5 材质映射 Material Mapping"></a>6.5 材质映射 Material Mapping</h2><p>纹理的常见用途是修改影响着色方程的材质属性。现实世界中的对象通常具有在其表面上变化的材质属性。为了模拟此类对象，像素着色器可以从纹理读取值，并在计算着色方程之前使用它们修改材质参数。最常被纹理修改的参数是表面颜色。这种纹理称为反照率颜色图（albedo color map）或漫反射颜色图（diffuse color map）。但是，可以通过纹理修改任何参数：替换，相乘或以其他方式更改它。例如，在图 6.25 中，将三个不同的纹理应用于表面，以替换常量值。</p>
<img alt="" height="267" src="https://img-blog.csdnimg.cn/20201010135947264.png" width="736">

<blockquote>
<p>图 6.25  金属砖和砂浆。右侧是表面颜色，粗糙度（较浅）的凹凸贴图和凹凸贴图高度（较浅）的纹理。（图片来自 three.js 示例 webgl 色调映射 <strong>[218]</strong> 。）</p>
</blockquote>
<p>在材质中纹理的使用可以更进一步。代替修改方程式中的参数，可以使用纹理来控制像素着色器本身的流（flow）和功能。通过使一种纹理指定表面的哪些区域具有哪种材质，可以将具有不同着色方程式和参数的两种或多种材质应用于表面，从而为每种材质执行不同的代码。例如，具有一些生锈区域的金属表面可以使用纹理来指示生锈的位置，根据纹理查找有条件地执行着色器的生锈部分，否则执行闪亮的金属着色器（第 9.5.2 节）。</p>
<p>着色模型输入（例如表面颜色）与从着色器输出的最终颜色具有线性关系。因此，可以使用标准技术对包含此类输入的纹理进行滤波，并避免走样。包含非线性着色输入（例如粗糙度或凹凸贴图）的纹理（第 6.7 节）需要多加注意，以避免出现走样。着色方程的滤波技术可以改善此类纹理的结果。这些技术在 9.13 节中讨论。</p>
<h2 id="6-6-透明映射-Alpha-Mapping"><a href="#6-6-透明映射-Alpha-Mapping" class="headerlink" title="6.6 透明映射 Alpha Mapping"></a>6.6 透明映射 Alpha Mapping</h2><p>使用 alpha 混合或 alpha 测试可以将 alpha 值用于许多效果，例如有效地渲染树叶，爆炸和远处的物体，这仅仅是列举的一小部分。本节讨论了将纹理与 Alpha 结合使用的方法，并指出了各种限制和解决方案。</p>
<p>一种与纹理相关的效果是贴花（decaling）。例如，假设你想在茶壶上放一朵花的图片。你不想要整个图片，而只想要花所在的部分。通过将 0 的 alpha 分配给纹理元素，可以使其透明，从而使其无效。因此，通过正确设置贴花纹理的 Alpha，您可以将贴图替换或混合基础表面。通常，将夹取匹配函数与透明边框一起使用，以将贴花的单个复制（相对于重复纹理）应用于表面。图 6.26 中显示了如何实现贴花的示例。有关贴花的更多信息，请参见第 20.2 节。</p>
<img alt="" height="271" src="https://img-blog.csdnimg.cn/20201010194131797.png" width="687">

<blockquote>
<p>图 6.26. **一种实现贴花的方法。首先使用场景渲染帧缓冲区，然后渲染一个框，对于框内的所有点，贴花纹理都投影到帧缓冲区的内容上。最左边的纹理元素是完全透明的，因此不会影响帧缓冲区。黄色纹理像素是不可见的，因为它将被投影到表面的隐藏部分上。</p>
</blockquote>
<p>一个与 Alpha 的相似的应用是制作剪切图（cutouts）。假设您制作了灌木的贴花图像，并将其应用于场景中的矩形。其原理与贴花的原理相同，除了不与下层表面齐平外，灌木丛会绘制在其背后的任何几何形状的顶部。这样，您可以使用单个矩形来渲染具有复杂轮廓的对象。</p>
<p>在灌木丛的案例中，如果围绕它旋转相机观察，则会露馅，因为这个灌木丛没有厚度。一种解决方法是复制此灌木丛矩形并将其沿树干旋转 90 度。这两个矩形构成了廉价的三维灌木丛，有时也称为“交叉树” （cross tree）**[1204]** ，从地面上看时，这种错觉相当有效。参见图 6.27。Pelzer <strong>[1367]</strong>  讨论了使用三个剪切图代表草的类似配置。在第 13.6 节中，我们讨论了一种称为广告牌（billboarding）的方法，该方法用于将这种渲染减少为单个矩形。如果观看者移至地面上方，就会露馅，因为从上方看到灌木丛是两个剪切图。参见图 6.28。</p>
<img alt="" height="326" src="https://img-blog.csdnimg.cn/2020101020055954.png" width="745">

<blockquote>
<p>图6.28  从离地面有点远的地方看“交叉树”灌木丛，然后再向上看，就露馅了。</p>
</blockquote>
<p>为了解决这个问题，可以以不同的方式（切片，分支，图层）添加更多的剪切图，以提供更具说服力的模型。第 13.6.5 节讨论了一种生成此类模型的方法； 第 857 页的图 19.31 显示了另一个。有关最终结果的示例，请参见第 2 和 1049 页上的图像。</p>
<p>将 alpha 贴图和纹理动画结合使用，可以产生令人信服的特殊效果，例如闪烁的火炬，植物生长，爆炸和大气效果。</p>
<p>有几种使用 alpha 贴图渲染对象的选项。Alpha 混合（第 5.5 节）允许使用带小数的透明度值，该值可以对对象边缘以及部分透明的对象进行反走样。但是，alpha 混合需要在不透明的三角形之后以从后到前的顺序渲染混合的三角形。一个简单的交叉树是两个剪切纹理（cutout textures）的示例，其中没有正确的渲染顺序，因为每个四边形位于另一个的前面。即使在理论上可以排序并获得正确的顺序，通常这样做效率也不高。例如，一块田地可能有成千上万个使用剪切图的草叶。每个网格物体可以由许多单独的叶片合成。因此，明确地分出每个叶片是不切实际的。</p>
<p>渲染时，可以通过几种不同的方法来改善此问题。一种是使用 Alpha 测试，它是有条件地丢弃像素着色器中具有低于给定阈值的Alpha 值的片元的过程。具体做法如下</p>
<img alt="" height="50" src="https://img-blog.csdnimg.cn/20201010195003385.png" width="617">

<p>其中 texture.a 是纹理查找中的 alpha 值，参数 alphaThreshold 是用户提供的阈值，该阈值确定哪些片元将被丢弃。因为透明片元被丢弃了，所以该二进制的可见性测试使三角形可以以任何顺序呈现。我们通常希望对 alpha 值为 0.0 的任何片元执行此操作。丢弃完全透明的片元还有一个额外的好处，就是可以节省进一步的着色器处理和合并的成本，还可以避免将 z 缓冲区中的像素错误地标记为可见 <strong>[394]</strong> 。对于剪切图，我们通常将阈值设置为高于 0.0，例如 0.5 或更高，然后采取进一步的步骤，然后完全忽略 alpha 值，而不是将其用于混合。这样做可以避免乱码。但是，由于只有两个级别的透明度（完全不透明和完全透明）可用，因此图像质量较低。另一种解决方案是对每个模型执行两次遍历，第一次遍历针对实体剪切图，写入 z 缓冲区，另一次遍历针对半透明样本，并且不写入 z 缓冲区。</p>
<p>alpha 测试还有两个其他问题，即过度的放大(magnification) <strong>[1374]</strong>  和过度的缩小(minification) <strong>[234，557]</strong> 。当将 alpha 测试与 mipmapping 一起使用时，如果处理方式不同，效果可能令人难以信服。图 6.29 的顶部显示了一个示例，其中树的叶子变得比预期的更加透明。这可以用一个例子来解释。假设我们有一个具有四个 alpha 值的一维纹理，即（0.0，1.0，1.0，0.0）。通过平均，下一个 mipmap 级别变为（0.5，0.5），然后最高级别为（0.5）。现在，假设我们使用 <img alt="\large \alpha _{t}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bt%7D"> = 0.75。访问 mipmap 级别 0 时， 4 个纹理像素中的 1.5 个将通过丢弃测试。但是，访问下两个级别时，由于 0.5 &lt;0.75，所有内容将被丢弃。请参见图 6.30。</p>
<img alt="" height="808" src="https://img-blog.csdnimg.cn/20201010200420580.png" width="714">

<blockquote>
<p>图6.29  顶部：带有mipmapping的alpha测试，无任何更正。底部：alpha测试，其alpha值根据覆盖范围重新调整。（图片来自“见证者，The Witness”，由伊格纳西奥·卡斯塔（Ignacio Casta）提供。</p>
</blockquote>
<img alt="" height="272" src="https://img-blog.csdnimg.cn/20201010200715969.png" width="741">

<blockquote>
<p>图 6.30  上方图片是具有混合功能的叶子图案的不同 mipmap 级别，较高的级别则进行缩放以提高可见性。在下方图片，显示mipmap，将使用 0.5 的 alpha 测试对其进行处理，以显示对象后退时如何减少像素。（图片由 Ben Golus 提供 <strong>[557]</strong> 。）</p>
</blockquote>
<p>Casta˜no <strong>[234]</strong>  提出了一种在 mipmap 创建期间完成的简单解决方案，效果很好。对于 mipmap 级别 k，覆盖率 <img alt="\large c_{k}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20c_%7Bk%7D"> 被定义为</p>
<img alt="" height="71" src="https://img-blog.csdnimg.cn/20201010195959778.png" width="511">

<p>其中 <img alt="\large n_{k}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20n_%7Bk%7D"> 是在 mipmap 级别 k 中的纹理像素数量，α（k，i）是在像素 i 处来自 mipmap 级别 k 的 alpha 值，而 <img alt="\large \alpha _{t}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bt%7D"> 是用户在公式 6.9 中提供的 alpha 阈值。在这里，我们假设 α（k，i）&gt;<img alt="\large \alpha _{t}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bt%7D">的结果为1，否则为0。注意，k = 0 表示最低的 mipmap 级别，即原始图像。然后，对于每个 mipmap 级别，我们找到一个新的 mipmap 阈值<img alt="\large \alpha _{k}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bk%7D">，而不是使用 <img alt="\large \alpha _{t}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bt%7D">，以使 <img alt="\large c_{k}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20c_%7Bk%7D"> 等于 <img alt="\large c_{0}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20c_%7B0%7D">（或尽可能接近）。这可以使用二进制搜索来完成。最后，在 mipmap 级别 k 中所有纹理像素的 alpha 值按 <img alt="\large \alpha _{t}/\alpha_{k}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bt%7D/%5Calpha_%7Bk%7D"> 缩放。图 6.29 的底部使用了这种方法，NVIDIA 的纹理工具也对此提供了支持。Golus <strong>[557]</strong>  给出了一个变体，其中未修改 mipmap，但是随着 mipmap 级别的增加，alpha 会在着色器中按比例放大。</p>
<p>Wyman 和 McGuire <strong>[1933]</strong>  提出了另一种解决方案，其中理论上将公式 6.9 中的代码行替换为</p>
<img alt="" height="50" src="https://img-blog.csdnimg.cn/2020101213530984.png" width="562">

<p>随机函数在 [0,1] 中返回一个统一值，这意味着平均而言，它将得出正确的结果。例如，假设纹理查找的 alpha 值为 0.3，则片元将以 30％ 的机会被丢弃。这是一种随机透明的形式，每个像素只有一个样本 <strong>[423]</strong> 。在实践中，将随机函数替换为哈希函数，以避免时间和空间上的高频噪声：</p>
<img alt="" height="79" src="https://img-blog.csdnimg.cn/20201012135819947.png" width="685">

<p>通过对上述函数的嵌套调用来形成三维哈希，即 float hash3D（x，y，z）{return hash2D（hash2D（x，y），z）; }，返回[0,1）中的数字。哈希的输入是对象空间坐标除以对象空间坐标的最大屏幕空间导数（x 和 y），然后进行夹取（clamping）操作。需要进一步注意以获得 z 方向运动的稳定性，并且该方法最好与时间性反走样技术（ temporal antialiasing techniques）结合使用。该技术会随着距离的增加而逐渐淡入，因此在关闭时我们根本不会获得任何随机效果。这种方法的优点是每个片元平均而言都是正确的，而 Casta〜no 的方法 <strong>[234]</strong>  为每个 mipmap 级别创建单个 <img alt="\large \alpha _{k}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Calpha%20_%7Bk%7D">。但是，此值可能会在每个 mipmap 级别上有所不同，这可能会降低质量并需要美术人员干预。</p>
<p>Alpha 测试会在放大下显示涟漪伪像（artifacts），可以通过将 Alpha 贴图预先计算为距离场 <strong>[580]</strong>  来避免（请参见第 677 页的讨论）。</p>
<p>Alpha 覆盖（Alpha to coverage）和类似的功能半透明自适应反走样（transparency adaptive antialiasing）会获取片元的透明度值，并将其转换为覆盖像素内的多少样本 <strong>[1250]</strong> 。这个想法就像 5.5 节中描述的屏幕门透明，但这是在子像素级别。想象每个像素有四个样本位置，并且一个片元覆盖了一个像素，但是由于剪切图纹理的缘故，它的透明度为 25％（不透明度为 75％）。Alpha 覆盖模式使片元变得完全不透明，但仅覆盖了四个样本中的三个。例如，此模式可用于重叠草叶的剪切图纹理，例如 <strong>[887，1876]</strong> 。由于每个绘制的样本都是完全不透明的，因此最接近的叶状体将沿其边缘以一致的方式将对象隐藏在其后方。由于 Alpha 混合功能已关闭，因此无需排序即可正确地混合半透明边缘像素。</p>
<p>Alpha to Coverage 是反走样 Alpha 测试的好方法，但是在 Alpha 混合时会显示伪像。例如，两个具有相同 alpha 覆盖率的 alpha 混合片元将使用相同的子像素图案，这意味着一个片元将完全覆盖另一个片元，而不是与其混合。Golus <strong>[557]</strong>  讨论了使用 fwidth（）着色器指令为内容提供更清晰的边缘。见图 6.31。</p>
<p>对于 alpha 贴图的各种使用方法，重要的是要了解双线性插值如何影响颜色值。想象一下彼此相邻的两个纹理像素：rgbα=（255,0,0,255）是纯红色，而它的近邻 rgbα=（0,0,0,2）是黑色，几乎完全透明。正好位于两个纹理像素中间的位置的rgbα 是多少？ 如果简单进行插值会得出（127,0,0,128），所得的 rgb 值呈“暗红色”。但是，真正的结果实际上并不是暗的，它是一个纯红色，并且它已预乘其 Alpha。如果要插值 Alpha 值，则为了确保正确的插值，需要保证在插值之前，已被插值的颜色已经由 Alpha 进行了预乘。例如，假设我们将几乎透明的近邻设置为 rgbα=（0,255,0,2），即给出一些绿色的微小色调。并且该颜色不会与 Alpha 预乘，那么在插值时会得到结果（127,127,0,128）—— 绿色的微小色调突然将结果变为（预乘）黄色样本，这是不对的。现在先进行预乘，此近邻纹理像素的预乘版本为（0,2,0,2），在插值后，这就给出了合适的预乘结果（127,1,0,128）。这个结果更为正确，最终的预乘颜色主要是红色，而绿色则难以察觉。</p>
<p>双线性插值后得出的预乘结果可能导致贴花和剪切对象周围出现黑色边缘。“较暗”的红色结果被其余管线视为未相乘的颜色，并且条纹变为黑色。即使使用 Alpha 测试，此效果仍然可见。最好的办法是在完成双线性插值之前进行预乘 <strong>[490，648，1166，1813]</strong> 。WebGL API支持此功能，因为颜色合成对于网页很重要。但是，双线性插值通常由 GPU 执行，并且在执行此操作之前，着色器无法完成对纹理像素值的操作。图像不会以 PNG 等文件格式进行预乘，因为这样做会失去色彩精度。在使用 Alpha 贴图时，默认情况下，这两个因素会共同导致黑边现象。一种常见的解决方法是对剪切图像进行预处理，使用从附近的不透明纹理像素衍生的颜色来绘制透明的“黑色”纹理像素 <strong>[490，685]</strong> 。通常，所有半透明区域都需要以这种方式手动或自动重新上色，以避免 mipmap 级别也出现边缘问题 <strong>[295]</strong> 。另外值得注意的是，在形成带有 Alpha 值的 mipmap 时，应该使用预乘值 <strong>[1933]</strong> 。</p>
<h2 id="6-7-凹凸映射-Bump-Mapping"><a href="#6-7-凹凸映射-Bump-Mapping" class="headerlink" title="6.7 凹凸映射 Bump Mapping"></a><strong>6.7 凹凸映射 Bump Mapping</strong></h2><p>本节描述了一大类的小型细节表示技术，我们将其统称为凹凸映射。所有这些方法通常都是通过修改每个像素的着色流程来实现的。们比起单独的纹理贴图具有更多的三维外观，但却不用添加额外的几何结构。</p>
<p>一个对象的细节可以分为三个等级：覆盖许多像素的宏观特征（macro-features），横跨几个像素的细观特征（meso-features），和实质上小于一个像素的微观特征（micro-features）。这些分类在某种程度上是流动的，因为在动画或交互式操作期间，观看者可能在不同距离观察到同一对象。</p>
<p>宏观几何由顶点和三角形或其他几何图元表示。创建三维角色时，通常以宏观尺度对肢体和头部进行建模。微观的几何结构被封装在着色模型中，该着色模型通常在像素着色器中实现，并使用纹理贴图作为参数。所用的着色模型可模拟表面微观几何结构的相互作用，例如，发光物体在微观上是光滑的，而漫射表面在微观上是粗糙的。角色的皮肤和衣服似乎具有不同的材质，因为它们使用不同的着色器，或者至少使用这些着色器中的不同参数。</p>
<p>细观几何结构描述了宏观与微观尺度之间的一切。它包含的细节过于复杂，无法使用单个三角形进行有效渲染，但是对于观察者来说，它足以区分表面曲率在几个像素上的变化。例如角色脸上的皱纹，肌肉结构细节以及衣服上的褶皱和接缝都是细观尺度的。细观尺度建模通常使用一类方法，它们被统称凹凸映射技术。它们在像素级别调整着色参数，以使观看者感觉到远离基本几何结构的微小干扰，而基本几何结构实际上保持平坦。不同种类的凹凸映射之间的主要区别是它们如何表示细节特征。其变量包括现实级别和细节特征的复杂性。例如，数字艺术家通常将细节雕刻到模型中，然后使用软件将这些几何元素转换为一种或多种纹理，例如凹凸纹理和缝隙变暗的纹理。</p>
<p>布林（Blinn）在 1978 年提出了在纹理中编码细观尺度细节的想法 <strong>[160]</strong> 。他观察到，如果在着色过程中用稍微受扰动的表面法线代替真实的表面，则表面似乎具有小范围的细节。他将描述表面法线微扰动的数据存储在数组中。</p>
<p>这里的关键思想是，我们不使用纹理来更改照明方程式中的颜色分量，而是访问纹理来修改表面法线。模型表面的几何法线实际上保持不变。我们仅修改照明方程式中使用的法线。此操作没有物理等效项。我们在曲面法线上执行更改，但曲面本身在几何意义上保持平滑。就像每个顶点具有法线一样，它给人一种幻觉，即三角形之间的表面很光滑。修改每个像素的法线会改变三角形表面本身的视觉感知，但不会改变其几何结构。</p>
<p>对于凹凸映射，法线必须相对于某个参考系改变方向。为此，我们将切线框架（ tangent frame，也称为切线空间基底 ，tangent-space basis）存储在每个顶点上。此参考系用于将灯光转换到表面位置的空间（反之亦然），以计算干扰法线的效果。除了顶点法线外，在多边形表面上应用了法线贴图的情况下，我们还存储了切线（tangent）和副切线向量（bitangent vectors）。双切线向量也被错误地称为副法线向量（binormal vector）**[1025]** 。</p>
<p>切线和副切线向量表示法线贴图本身在对象空间中的轴，因为目标是将光照转换为相对于贴图的光照。参见图 6.32。</p>
<img alt="" height="329" src="https://img-blog.csdnimg.cn/20201012205129202.png" width="738">

<blockquote>
<p>图6.32  展示了一个球形三角形，其切线框显示在每个角上。形状像圆球和圆环的，具有自然的切线空间基础，正如圆环上的纬度和经度线所示。</p>
</blockquote>
<p>法线 n，切线 t 和切线 b 这三个向量形成一个基本矩阵：</p>
<img alt="" height="116" src="https://img-blog.csdnimg.cn/20201012204928963.png" width="490">

<p>这个矩阵有时缩写为TBN，它将光的方向（对于给定的顶点）从世界空间转换为切线空间 这些向量不必真正彼此垂直，因为法线贴图本身可能会变形以适合曲面。但是，非正交的基底会导致纹理倾斜，这可能意味着需要更多的存储空间，并且可能会对性能产生影响，即矩阵无法通过简单的转置来反转 <strong>[494]</strong> 。节省内存的一种方法是仅在顶点存储切线和副切线，并取它们的叉积来计算法线。但是，只有在矩阵的手性（handedness）始终相同的情况下，此技术才有效 <strong>[1226]</strong> 。通常，模型是对称的：飞机，人，文件柜和许多其他对象。由于纹理消耗大量内存，因此它们通常会被镜像到对称模型上。因此，虽然仅存储对象纹理的一侧，但是纹理映射将其放置在模型的两侧。在这种情况下，切线空间的旋向性在两侧会有所不同，所以无法进行假设**(?)**。如果在每个顶点存储了额外的信息位来指示手性，那么在这种情况下仍然可以避免存储法线。如果已经设置完毕，则此位数用于求反切线和双切线的叉积，以生成正确的法线。如果切线框架是正交的，则还可以将基础存储为四元数（第 4.3 节），这既节省空间，又可以节省每个像素的一些计算 <strong>[494、1114、1154、1381、1639]</strong> 。尽管在实践中很少见，但质量可能会略有下降。</p>
<p>切线空间的思想对于其他算法很重要。如下一章所述，许多着色方程仅依赖于曲面的法线方向。但是，诸如拉丝铝或天鹅绒之类的材质也需要知道观察者和照明相对于表面的相对方向。切线框架可用于定义材质在表面上的方向。Lengyel <strong>[1025]</strong>  和 Mittring <strong>[1226]</strong>  的文章提供了该领域的广泛叙述。Schüler <strong>[1584]</strong>  提出了一种在像素着色器中动态计算切线空间的方法，而无需逐顶点去存储预先计算的切线帧。Mikkelsen <strong>[1209]</strong>  对这项技术进行了改进，并推导了一种不需要任何参数化方法，而是使用表面位置的导数和高度场的导数来计算扰动法线的方法。但是，与使用标准切线空间映射相比，此类技术会导致显示的细节大大减少，并可能产生美术工作流的问题 <strong>[1639]</strong> 。</p>
<h3 id="6-7-1-布林的方法-Blinn’s-Methods"><a href="#6-7-1-布林的方法-Blinn’s-Methods" class="headerlink" title="6.7.1 布林的方法 Blinn’s Methods"></a>6.7.1 布林的方法 Blinn’s Methods</h3><p>布林最初的凹凸映射方法在纹理的每个纹理像素上存储两个有符号的值 <img alt="\large b_{u}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bu%7D"> 和 <img alt="\large b_{v}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bv%7D">。这两个值对应于沿 u 和 v 图像轴改变法线的量。即，这些通常是双线性插值的纹理值用于缩放垂直于法线的两个向量。将这两个向量添加到法线以更改其方向。两个值 <img alt="\large b_{u}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bu%7D">和 <img alt="\large b_{v}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bv%7D"> 描述了曲面在该点面向哪个方向。见图 6.33。这种类型的凹凸贴图纹理称为偏移向量凹凸贴图（offset vector bump map）或偏移贴图（offset map）。</p>
<img alt="" height="358" src="https://img-blog.csdnimg.cn/20201013135554191.png" width="745">

<blockquote>
<p>图 6.33  在左侧，法线向量 n 通过从凹凸纹理获取的（<img alt="\large b_{u}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bu%7D">，<img alt="\large b_{v}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bv%7D">）值在 u 方向和 v 方向上进行修改，得到 n’（未归一化）。右侧显示了一个高度场及其对着色法线的影响。可以在高度之间对这些法线插值，以获得更平滑的外观。</p>
</blockquote>
<p>表示凹凸的另一种方法是使用高度场（heightfield）来修改表面法线的方向。每个单色纹理值代表一个高度，因此在纹理中，白色是高区域，黑色是低区域（反之亦然）。有关示例，请参见图 6.34。这是首次创建或浏览凹凸贴图时使用的常见格式，它也是 1978 年由 Blinn 引入的。heightfield用于导出 u 和 v 符号值，类似于第一种方法中使用的值。这是通过获取相邻列之间的差异来获得 u 的斜率以及相邻列之间的差异来获取v <strong>[1567]</strong> 来完成的。一种变体是使用 Sobel 滤波器，该滤波器赋予直接的近邻以更大的权重 <strong>[535]</strong> 。</p>
<img alt="" height="368" src="https://img-blog.csdnimg.cn/20201013191652136.png" width="734">

<blockquote>
<p>图6.34  波浪形的高度场凹凸图像及其在球体上的使用。</p>
</blockquote>
<h3 id="6-7-2-法线映射-Normal-Mapping"><a href="#6-7-2-法线映射-Normal-Mapping" class="headerlink" title="6.7.2 法线映射 Normal Mapping"></a>6.7.2 法线映射 Normal Mapping</h3><p>凹凸贴图的常见方法是直接存储法线贴图。其算法和结果在数学上与布林的方法相同； 只有存储格式和像素着色器计算会更改。</p>
<p>法线图编码映射到 [-1,1] 的（x，y，z），例如，对于 8 位纹理，x轴值 0 表示 -1.0，255 表示 1.0。一个例子如图 6.35 所示。颜色 (128,128,255)（浅蓝色）将代表所示颜色映射的平坦表面，即法线 (0,0,1)。</p>
<img alt="" height="348" src="https://img-blog.csdnimg.cn/20201013192145510.png" width="737">

<blockquote>
<p>图6.35  使用法线贴图的凹凸映射。每个颜色通道实际上都是一个表面法线坐标。红色通道是 x 偏差； 红色越多，指向右边的法线越多。绿色是 y 偏差，蓝色是 z 。右侧是使用法线贴图生成的图像。注意立方体顶部的扁平外观。（图片由 Manuel M. Oliveira 和 Fabio Policarpo 提供。）</p>
</blockquote>
<p>法线图的表示最初是作为世界空间法线图 <strong>[274，891]</strong>  引入的，然而这在实践中很少使用。对于这种类型的贴图，扰动非常简单：在每个像素处，从贴图中检索法线，并将其与光的方向一起直接使用，以计算表面上该位置的着色。还可以在物体空间中定义法线贴图，以便可以旋转模型，之后法线仍然有效。但是，世界和物体空间的表示都将纹理绑定到特定方向的特定几何形状，这限制了纹理的重复使用。</p>
<p>取而代之的是，我们通常在切线空间（即相对于曲面本身）中检索扰动的法线。这种方法允许表面变形以及正常纹理的最大重复使用。切线空间法线贴图也可以很好地压缩，因为 z 分量的符号（与不受扰动的表面法线对齐的符号）通常可以假定为正值。</p>
<p>使用法线贴图可以很好地提高真实感 —— 见图 6.36。</p>
<img alt="" height="450" src="https://img-blog.csdnimg.cn/20201013192935872.png" width="743">

<blockquote>
<p>图 6.36  在类似游戏的场景中使用的法线贴图凹凸映射的示例。左上方：不使用右侧的两个法线贴图。左下方：已使用法线贴图。右：法线贴图。（3D模型和法线贴图由 Dulce Isis SegarraLópez 提供。）</p>
</blockquote>
<p>与颜色纹理的滤波相比，法线贴图的滤波是一个难题。通常，法线颜色与着色颜色之间的关系不是线性的，因此标准滤波方法可能会导致令人反感的走样。想象一下看楼梯由闪亮的白色大理石块制成。在某些角度下，楼梯的顶部或侧面可以捕捉光线并反射出明亮的镜面高光。但是，楼梯的平均法线为 45 度角。它会从与原始楼梯完全不同的方向捕获亮点。如果在没有正确滤波的情况下渲染具有锐利的镜面高光的凹凸贴图，当采样的位置恰好时，高光闪烁就会出现，从而产生分散注意力的火花效果。</p>
<p>Lambertian 曲面是一种特殊情况，其中法线贴图对着色几乎具有线性影响。Lambertian 着色几乎完全是一个点积，它是线性运算。平均一组法线并对其结果执行点积等效于对具有法线的单个点积进行平均：</p>
<img alt="" height="89" src="https://img-blog.csdnimg.cn/20201013195347205.png" width="525">

<p>请注意，平均向量在使用前未归一化。公式 6.14 表明，对于 Lambertian 曲面，标准滤波和 mipmap 几乎可以产生正确的结果。由于 Lambertian 着色方程不是点积，因此结果不是很正确。它是一个夹取的（clamped）点乘积 —— max（l·n，0）。夹取操作使其变为非线性。这将使表面过于暗淡，以至于无法直视光的方向，但是在实践中，这通常能够被接受 <strong>[891]</strong> 。需要警示的是，通常用于法线贴图的某些纹理压缩方法（如从其他两个法线重构 z 分量）不支持非单位长度的法线，因此使用未归一化的法线贴图可能会带来压缩上的困难。</p>
<p>在非 Lambertian 曲面的情况下，可以通过将着色方程的输入作为一组滤波，而不是单独对法线贴图滤波来产生更好的结果。在第 9.13 节中讨论了此方法的相关技术。</p>
<p>最后，从高度图 h（x，y）导出法线图可能是有用的。按下面的步骤进行 <strong>[405]</strong> 。首先，使用中心差为 x 来计算 x 和 y 方向上的导数的近似值</p>
<img alt="" height="67" src="https://img-blog.csdnimg.cn/20201013200829228.png" width="718">

<p>然后，在纹理像素（x，y）处的未归一化法线为</p>
<img alt="" height="56" src="https://img-blog.csdnimg.cn/20201013200848674.png" width="543">

<p>这里必须注意纹理的边界。</p>
<p>通过使用凹凸映射，能够将阴影投射到其自身的表面上，可以使用“水平贴图” （horizon mapping）**[1027]**  进一步增强法线贴图。这是通过预先计算其他纹理来实现的，每个纹理与沿着表面平面的方向相关联，并为每个纹理像素存储该方向上的地平线角度。相关更多信息，请参见第 11.4 节。</p>
<h2 id="6-8-视差映射-Parallax-Mapping"><a href="#6-8-视差映射-Parallax-Mapping" class="headerlink" title="6.8 视差映射 Parallax Mapping"></a>6.8 视差映射 Parallax Mapping</h2><p>凹凸和法线贴图的问题在于，凹凸永远不会随视角移动位置，也不会相互阻挡。例如，如果你以真实的角度看一眼真实的砖墙，你将看不到砖之间的砂浆。墙壁的凹凸贴图永远不会显示这种类型的遮挡，因为它只会改变法线。最好的办法是让凸块实际影响在每个像素处渲染表面上的哪个位置。</p>
<p>视差映射（parallax mapping）的概念由 Kaneko <strong>[851]</strong>  于 2001 年提出，并由 Welsh <strong>[1866]</strong>  进行了完善和推广。视差指的是当观察者移动时，对象的位置相对于彼此移动的想法。当观察者移动时，凹凸应该看起来具有高度。视差映射的关键思想是通过检查发现的可见物体的高度，来对像素中应该看到的物体进行有根据的猜测。</p>
<img alt="" height="222" src="https://img-blog.csdnimg.cn/2020101320223670.png" width="737">

<blockquote>
<p>图 6.37 我们想达成的效果在左侧：从视图向量刺穿高度场的位置找到表面上的实际位置。视差贴图通过获取矩形上某个位置的高度并使用它来查找新位置 <img alt="\large \textbf{p}_{adj}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bp%7D_%7Badj%7D"> 来进行一阶近似。（在 Welsh <strong>[1866]</strong>  之后。）</p>
</blockquote>
<p>对于视差贴图，将凹凸数据存储在高度场纹理中。在给定像素处查看表面时，将在该位置检索高度场值，并将其用于移动纹理坐标以检索表面的不同部分。偏移量基于所获取的高度和眼睛与表面的角度。参见图 6.37。高度场值要么存储在单独的纹理中，要么打包为其他纹理的未使用的颜色或 Alpha 通道（将不相关的纹理打包在一起时必须格外小心，因为这会对压缩质量产生负面影响）。在用于移动坐标之前，将对高度字段值进行缩放和偏置。比例尺决定了高度场要在表面上方或下方延伸的高度，并且偏差提供了不发生任何偏移的“海平面”高度。给定纹理坐标位置 p，调整后的高度场高度 h 和具有高度值 <img alt="\large v_{z}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20v_%7Bz%7D"> 和水平分量  <img alt="\large \textbf{v}_{xy}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D_%7Bxy%7D"> 的归一化视图向量 <img alt="\large \textbf{v}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D">，新的视差调整后的纹理坐标 <img alt="\large \textbf{p}_{adj}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bp%7D_%7Badj%7D"> 为</p>
<img alt="" height="65" src="https://img-blog.csdnimg.cn/20201013201951462.png" width="472">

<p>请注意，与大多数着色方程式不同，此处执行计算的空间很重要 —— 视图向量必须在切线空间中。</p>
<p>尽管是一个简单的近似值，但如果凸块高度的变化相对较慢 <strong>[1171]</strong> ，则这种移位在实践中效果很好。这样，附近的相邻纹理像素的高度大约相同，因此使用原始位置的高度作为新位置的高度估计的想法是合理的。但是，此方法在浅视角下会露馅。当视图向量接近表面的水平线时，高度变化较小会导致纹理坐标偏移较大。这近乎失效，因为检索到的新位置与原始曲面位置几乎没有高度相关性。</p>
<p>为了改善这个问题，Welsh <strong>[1866]</strong>  引入了偏移限制的思想。想法是将移动量限制为永远不大于获取的高度。公式是</p>
<img alt="" height="41" src="https://img-blog.csdnimg.cn/20201013202614178.png" width="472">

<p>请注意，该公式的计算速度比原始公式要快。从几何上讲，这种解释是，高度定义了一个半径，位置不能超出该半径。如图6.38 所示。</p>
<img alt="" height="242" src="https://img-blog.csdnimg.cn/20201013202719775.png" width="738">

<blockquote>
<p>图 6.38  在视差偏移量限制中，偏移量最多偏离原始位置的高度，以虚线圆弧表示。灰色虚线偏移是原始的结果，黑色虚线偏移显示有限结果。右边是用该技术渲染的墙。（图片由特里·威尔士（Terry Welsh）提供。）</p>
</blockquote>
<p>由于 <img alt="\large v_{z}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20v_%7Bz%7D"> 接近1，因此在陡峭的角度（面对面）时，该公式与原始公式几乎相同。在较小的角度时，偏移的作用受到限制。从视觉上看，这使得在浅角度的凹凸感减小，但是这比纹理的随机采样好得多。游泳时，随着视图的改变，纹理也存在问题，或者对于立体渲染，观看者同时感知到两个必须给出一致的深度提示的视点<strong>1171]</strong> 。即使有这些缺点，具有偏移限制的视差映射也只花费了一些额外的像素着色器程序指令，并且相对于基本法线映射提供了可观的图像质量改进。hishkovtsov <strong>[1631]</strong> 通过在凹凸贴图法线方向上移动估计的位置来改善视差遮挡的阴影。</p>
<h3 id="6-8-1-视察遮蔽映射-Parallax-Occlusion-Mapping"><a href="#6-8-1-视察遮蔽映射-Parallax-Occlusion-Mapping" class="headerlink" title="6.8.1 视察遮蔽映射 Parallax Occlusion Mapping"></a>6.8.1 视察遮蔽映射 Parallax Occlusion Mapping</h3><p>凹凸贴图不会基于 heightfield 修改纹理坐标； 它仅在某个位置改变法线着色。假设像素的高度与其相邻像素的高度大致相同，视差贴图则提供了高度场效果的简单近似值。然而这个假设可能会很容易露馅。凹凸贴图可能永远不会相互遮挡，也不会蒙上阴影。我们想要的是在像素处可见的东西，即视图向量首先与高度场相交的地方。</p>
<p>为了以更好的方式解决此问题，一些研究人员建议沿视图向量使用光线步进（ray marching），直到找到一个（近似）交点。这项工作可以在像素着色器中完成，高度数据可以作为纹理访问。我们将对这些方法的研究归纳为视差映射技术的子集，该技术以一种或另一种方式利用光线步进 <strong>[192，1171，1361，1424，1742，1743]</strong> 。</p>
<p>这些类型的算法除一些其他名称外，通常被称为视差遮挡映射（parallax occlusion mapping，POM）或浮雕映射（relief mapping）方法。其关键思想是首先沿着投影向量测试固定数量的高度场纹理样本。这通常会在观察角度为视线生成更多样本，以免错过最近的交点 <strong>[1742，1743]</strong>  。检索沿射线方向的每个三维位置，将其转​​换为纹理空间，然后进行处理以确定其是否在高度场之上或之下。一旦找到高度场下方的样本，则其下方的数量以及之前一个样本上方的数量将用于查找相交位置，见图 6.39。然后该位置会被用来应用附加的法线贴图，颜色贴图和任何其他纹理，以对表面进行着色。多层高度场可用于产生悬垂（overhangs），独立的重叠表面以及两侧浮雕映射的假物体（impostors）。请参阅第 13.7 节。高度场跟踪方法也可以用于使凹凸的表面在自身上投射阴影，包括硬阴影 <strong>[1171、1424]</strong>  和软阴影 <strong>[1742、1743]</strong> 。它们之间的比较请参见图 6.40。</p>
<img alt="" height="323" src="https://img-blog.csdnimg.cn/20201014135617529.png" width="738">

<blockquote>
<p>图6.39   代表观察者的绿色射线投射到表面上，以固定的时间间隔（紫色点）进行采样，并获取高度。该算法找到了观察射线与黑色线段的第一个交点，近似于弯曲的高度场。</p>
</blockquote>
<img alt="" height="339" src="https://img-blog.csdnimg.cn/20201014211255740.png" width="736">

<blockquote>
<p>图6.40  与光线步进（右）相比，没有光线步进的视差贴图（左）。不使用光线步进时，立方体的顶部会变平。使用光线步进时，也会产生自阴影效果。（图片由 Manuel M. Oliveira 和 Fabio Policarpo 提供。）</p>
</blockquote>
<p>关于这个话题有很多文献。尽管所有这些方法都沿着光线步进，但存在一些差异。我们可以使用简单的纹理来获取高度，但是也可以使用更高级的数据结构和更高级的根查找方法。一些技术可能涉及着色器丢弃像素或写入深度缓冲区，这可能对性能产生损害。下面我们总结了一大堆方法，但是请记住，随着 GPU 的发展，最佳方法也会随之发展。这种“最佳”方法取决于光线步进期间的内容和完成的步数。</p>
<p>确定两个常规样本之间的实际交点的问题是根查找问题（root-finding problem）。实际上，高度场更多地被视为深度场，其矩形的平面定义了表面的上限。这样的话，平面上的初始点会在高度场上方。在找到高度场的上方的最后一个点和下方的第一个点之后，Tatarchuk <strong>[1742，1743]</strong>  使用割线方法的单个步骤来找到一个近似解。Policarpo 等 <strong>[1424]</strong>  在发现的两个点之间使用二分法搜索，以在更近的交叉点上进行磨练（hone in）。Risser等人 <strong>[1497]</strong>  通过使用割线方法进行迭代来加快收敛速度。折衷的方案是可以并行地进行常规采样，尽管迭代方法仅需更少的整体纹理访问，但是必须等待结果并执行较慢的依赖纹理提取。这种蛮力方法似乎在整体上表现良好 <strong>[1911]</strong> 。</p>
<p>以足够高的频率对高度场进行采样是至关重要的。McGuire 和 McGuire <strong>[1171]</strong>  提出对 mipmap 查找进行偏置（biasing），并使用各向异性的 mipmap 以确保对高频高度场（例如代表尖峰或头发的高频高度场）进行正确采样。人们还可以用比法线贴图更高的分辨率存储高度场纹理。最后，某些渲染系统甚至不存储法线贴图，而是更喜欢使用交叉滤镜（cross filter）**[40]**  从高度场中动态导出法线。第 696 页的公式 16.1 展示了该方法。</p>
<p>提高性能和采样精度的另一种方法是，首先不以固定的间隔对高度场进行采样，而是尝试跳过中间的空白空间。Donnelly <strong>[367]</strong>  将高度场预处理为一组体素，在每个体素中存储它与高度场表面的距离。以这种方式，可以快速跳过中间的空间，但代价是每个高度场的存储空间会更大。Wang 等 <strong>[1844]</strong>  使用五维位移映射方案来保持从所有方向和位置到表面的距离。这种方法将会允许复杂的曲面，自遮蔽和其他效果，但是要消耗大量内存。Mehra 和 Kumar <strong>[1195]</strong>  出于类似目的使用定向距离图。Dummer <strong>[393]</strong>  引入了圆锥阶跃映射（cone step mapping）的概念，而 Policarpo 和 Oliveira <strong>[1426]</strong>  对其进行了改进。这里的概念是还要为每个高度场位置存储一个圆锥半径（cone radius）。该半径定义了射线的间隔，在该间隔中与高度场最多有一个交点。该属性允许沿射线快速跳过而不会丢失任何可能的交点，但是代价是需要依赖纹理读取。另一个缺点是创建圆锥阶跃贴图（cone step map）所需的预计算，这使得该方法无法用于动态更改高度场。Schroders和Gulik <strong>[1581]</strong>  提出了四叉树浮雕映射（quadtree relief mapping），这是一种在遍历期间跳过体积的分层方法。Tevs等 <strong>[1760]</strong>  使用 “最大mipmap” 来进行跳过，同时将预计算成本降至最低。Drobot <strong>[377]</strong>  还使用存储在 mipmap 中的类似四叉树的结构来加速遍历，并提出了一种在不同的高度场之间进行混合的方法，其中一种地形类型（terrain type）会转换为另一种地形类型。</p>
<p>上述所有方法的一个问题是，立体的幻觉会沿着对象的轮廓边缘逐渐分崩离析，最后会显示出原始表面的平滑轮廓。参见图6.41。这里的关键思想是渲染的三角形应该定义哪些像素由像素着色器程序计算，而不是表面实际所在的位置。另外，对于弯曲表面，轮廓问题变得更加复杂。Oliveira 和 Policarpo <strong>[1325，1850]</strong> 描述和开发了一种方法，该方法使用了二次轮廓逼近技术（ quadratic silhouette approximation technique）。Jeschke等 <strong>[824]</strong> 和Dachsbacher 等 <strong>[323]</strong> 都给出了一种更通用，更鲁棒的方法（并回顾了以前的工作）来正确处理轮廓和曲面。这在最初是由 Hirche <strong>[750]</strong>  进行探索，其总体思想是向外挤出网格中的每个三角形并形成一个棱镜。渲染此棱镜时会强制计算可能会出现高度场的所有像素。这种方法称为外壳映射（shell mapping），因为扩展的网格在原始模型上形成了一个单独的外壳。通过保留棱镜与光线相交时的非线性特性，可以实现高度场的无伪像渲染，尽管这个计算成本很高。图 6.42 显示了这种技术的令人印象深刻的用法。</p>
<img alt="" height="375" src="https://img-blog.csdnimg.cn/202010142152137.png" width="744">

<blockquote>
<p>图6.42. 视差遮挡贴图（也称为浮雕贴图），用于使路面上的石头看起来更逼真。路面实际上是一组应用了高度场的简单三角形。（图片来自游戏，孤岛危机“Crysis”，由Crytek提供。）</p>
</blockquote>
<h2 id="6-9-纹理灯光-Textured-Lights"><a href="#6-9-纹理灯光-Textured-Lights" class="headerlink" title="6.9 纹理灯光 Textured Lights"></a>6.9 纹理灯光 Textured Lights</h2><img alt="" height="384" src="https://img-blog.csdnimg.cn/20201014221339230.png" width="733">

<blockquote>
<p>图6.43  投射的纹理光。纹理被投影到茶壶和地面上，并用于在投影视锥中调整光的分布（在视锥外设置为0）。（图片由NVIDIA Corporation提供。）</p>
</blockquote>
<p>纹理还可以用于为光源增加视觉丰富度，并允许复杂的强度分布或聚光灯功能。对于所有照明都限于圆锥形或截头圆锥形的灯，可以使用投影纹理来调整光照强度 <strong>[1192，1597，1904]</strong> 。这样可以形成聚光灯，图案光，甚至“幻灯机”效果（图6.43）。在专业剧院和电影照明中使用的剪影（cutouts）术语之后**(?)**，这些灯通常称为戈波灯（gobo light）或曲奇灯（cookie light）。有关以类似方式投射阴影的投影映射的讨论，请参见第 7.2 节。</p>
<p>对于不限于视锥体但可以在所有方向照亮的灯光，可以使用立方体贴图（cubemap）来调整光照强度，而不是使用二维投影纹理。一维纹理可用于定义任意距离衰减函数。结合二维角度衰减图，可以考虑复杂的体积照明模式 <strong>[353]</strong>  。更普遍的可能是使用三维（体积）纹理控制光的衰减 <strong>[353、535、1192]</strong> 。这种方法允许任意数量的效果，包括光束效果（light beams）。此技术会占用大量内存（所有体积纹理都是如此）。如果光线的影响体积是沿三个轴对称的，那么就可以通过将数据镜像到每个八分之一球体中来将内存占用量减少八倍。</p>
<p>可以将纹理添加到任何灯光类型，以启用其他视觉效果。带纹理的灯光使艺术家可以轻松控制照明，而艺术家可以简单地编辑所使用的纹理。</p>
<h3 id="进一步阅读和资源"><a href="#进一步阅读和资源" class="headerlink" title="进一步阅读和资源"></a>进一步阅读和资源</h3><p>赫伯特（Heckbert）对纹理映射理论进行了很好的综述 <strong>[690]</strong> ，并对该主题进行了更深入的报道 <strong>[691]</strong> 。Szirmay-Kalos和Umenhoffer <strong>[1731]</strong> 对视差遮挡映射和位移方法进行了出色而详尽的调查。关于正态表示的更多信息可以在 Cigolle 等人的著作中找到。**[269]**  并且由 Meyer 等人 <strong>[1205]</strong>  撰写。</p>
<p>《使用OpenGL进行高级图形编程》 （Advanced Graphics Programming Using OpenGL）**[1192]** 一书广泛涵盖了使用纹理算法的各种可视化技术。有关三维程序纹理的广泛介绍，请参见《纹理化和建模：一种程序化方法》（Texturing and Modeling: A Procedural Approach） <strong>[407]</strong> 。《使用可编程图形硬件进行高级游戏开发》（Advanced Game Development with Programmable Graphics Hardware） <strong>[1850]</strong> 一书详细介绍了如何实现视差遮挡映射技术，Tatarchuk 的演示文稿 <strong>[1742，1743]</strong>  以及 Szirmay-Kalos 和 Umenhoffer 的调查报告 <strong>[1731]</strong>  也是如此。</p>
<p>对于程序纹理（和建模），我们在 Internet 上最喜欢的网站是Shader-toy。网站上展示了许多有价值且引人入胜的程序纹理函数，并且你可以轻松地修改任何示例，同时查看结果。</p>
<p>访问本书的网站 realtimerendering.com，以获取许多其他资源。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B8%B2%E6%9F%93/" rel="tag"># 渲染</a>
              <a href="/tags/RealTimeRendering/" rel="tag"># RealTimeRendering</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/28/RealTimeRender4/5/" rel="prev" title="RealTimeRendering 5">
      <i class="fa fa-chevron-left"></i> RealTimeRendering 5
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/23/C++Study/CppStudy1/" rel="next" title="C++随笔1">
      C++随笔1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="SOHUCS"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E7%BA%B9%E7%90%86%E5%8C%96-Chapter-6-Texturing"><span class="nav-number">1.</span> <span class="nav-text">第6章 纹理化 Chapter 6 Texturing</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E7%BA%B9%E7%90%86%E5%8C%96%E7%AE%A1%E7%BA%BF-The-Texturing-Pipeline"><span class="nav-number">1.1.</span> <span class="nav-text">6.1 纹理化管线 The Texturing Pipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E6%8A%95%E5%BD%B1%E5%87%BD%E6%95%B0-The-Projector-Function"><span class="nav-number">1.1.1.</span> <span class="nav-text">6.1.1 投影函数 The Projector Function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-%E5%8C%B9%E9%85%8D%E5%87%BD%E6%95%B0-The-Corresponder-Function"><span class="nav-number">1.1.2.</span> <span class="nav-text">6.1.2 匹配函数 The Corresponder Function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-%E7%BA%B9%E7%90%86%E5%80%BC-Texture-Values"><span class="nav-number">1.1.3.</span> <span class="nav-text">6.1.3 纹理值 Texture Values</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%9B%BE%E5%83%8F%E7%BA%B9%E7%90%86%E5%8C%96-Image-Texturing"><span class="nav-number">1.2.</span> <span class="nav-text">6.2 图像纹理化 Image Texturing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-%E6%94%BE%E5%A4%A7-Magnification"><span class="nav-number">1.2.1.</span> <span class="nav-text">6.2.1 放大 Magnification</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E7%BC%A9%E5%B0%8F-Minification"><span class="nav-number">1.2.2.</span> <span class="nav-text">6.2.2 缩小 Minification</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Mip%E6%98%A0%E5%B0%84-Mipmapping"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Mip映射 Mipmapping</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E5%92%8C%E5%8C%BA%E5%9F%9F%E8%A1%A8-Summed-Area-Table"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">求和区域表 Summed-Area Table</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%BA%A6%E6%9D%9F%E5%90%84%E5%90%91%E5%BC%82%E6%80%A7%E6%BB%A4%E6%B3%A2-Unconstrained-Anisotropic-Filtering"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">无约束各向异性滤波 Unconstrained Anisotropic Filtering</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-%E4%BD%93%E7%A7%AF%E7%BA%B9%E7%90%86-Volume-Textures"><span class="nav-number">1.2.3.</span> <span class="nav-text">6.2.3 体积纹理 Volume Textures</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE-Cube-Maps"><span class="nav-number">1.2.4.</span> <span class="nav-text">6.2.4 立方体贴图 Cube Maps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-5-%E7%BA%B9%E7%90%86%E8%A1%A8%E7%A4%BA-Texture-Representation"><span class="nav-number">1.2.5.</span> <span class="nav-text">6.2.5 纹理表示 Texture Representation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-6-%E7%BA%B9%E7%90%86%E5%8E%8B%E7%BC%A9-Texture-Compression"><span class="nav-number">1.2.6.</span> <span class="nav-text">6.2.6 纹理压缩 Texture Compression</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E7%A8%8B%E5%BA%8F%E7%BA%B9%E7%90%86-Procedural-Texturing"><span class="nav-number">1.3.</span> <span class="nav-text">6.3 程序纹理 Procedural Texturing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB-Texture-Animation"><span class="nav-number">1.4.</span> <span class="nav-text">6.4 纹理动画 Texture Animation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E6%9D%90%E8%B4%A8%E6%98%A0%E5%B0%84-Material-Mapping"><span class="nav-number">1.5.</span> <span class="nav-text">6.5 材质映射 Material Mapping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-%E9%80%8F%E6%98%8E%E6%98%A0%E5%B0%84-Alpha-Mapping"><span class="nav-number">1.6.</span> <span class="nav-text">6.6 透明映射 Alpha Mapping</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-%E5%87%B9%E5%87%B8%E6%98%A0%E5%B0%84-Bump-Mapping"><span class="nav-number">1.7.</span> <span class="nav-text">6.7 凹凸映射 Bump Mapping</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-1-%E5%B8%83%E6%9E%97%E7%9A%84%E6%96%B9%E6%B3%95-Blinn%E2%80%99s-Methods"><span class="nav-number">1.7.1.</span> <span class="nav-text">6.7.1 布林的方法 Blinn’s Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-2-%E6%B3%95%E7%BA%BF%E6%98%A0%E5%B0%84-Normal-Mapping"><span class="nav-number">1.7.2.</span> <span class="nav-text">6.7.2 法线映射 Normal Mapping</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-%E8%A7%86%E5%B7%AE%E6%98%A0%E5%B0%84-Parallax-Mapping"><span class="nav-number">1.8.</span> <span class="nav-text">6.8 视差映射 Parallax Mapping</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-1-%E8%A7%86%E5%AF%9F%E9%81%AE%E8%94%BD%E6%98%A0%E5%B0%84-Parallax-Occlusion-Mapping"><span class="nav-number">1.8.1.</span> <span class="nav-text">6.8.1 视察遮蔽映射 Parallax Occlusion Mapping</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-9-%E7%BA%B9%E7%90%86%E7%81%AF%E5%85%89-Textured-Lights"><span class="nav-number">1.9.</span> <span class="nav-text">6.9 纹理灯光 Textured Lights</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB%E5%92%8C%E8%B5%84%E6%BA%90"><span class="nav-number">1.9.1.</span> <span class="nav-text">进一步阅读和资源</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">VisionXie</p>
  <div class="site-description" itemprop="description">生活在树上，始终热爱大地，升入天空。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VisionXie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <script>
  NexT.utils.loadComments(document.querySelector('#SOHUCS'), () => {
    var appid = 'cyvS0HjaG';
    var conf = '26c6eae6e21dfb5a6535a5e53425e9ec';
    var width = window.innerWidth || document.documentElement.clientWidth;
    if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
    } else {
      var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})});
    }
  });
  </script>
  <script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>

</body>
</html>
