<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="关于UE4的一些随笔">
<meta property="og:type" content="article">
<meta property="og:title" content="Unreal随笔">
<meta property="og:url" content="http://example.com/2021/08/19/UnrealStudy/Unreal%E9%9A%8F%E7%AC%94/index.html">
<meta property="og:site_name" content="XiMo">
<meta property="og:description" content="关于UE4的一些随笔">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-19T16:00:00.000Z">
<meta property="article:modified_time" content="2023-05-11T16:00:00.000Z">
<meta property="article:author" content="VisionXie">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Unreal">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/08/19/UnrealStudy/Unreal%E9%9A%8F%E7%AC%94/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Unreal随笔 | XiMo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XiMo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">醉后不知天在水，满船清梦压星河。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>All<span class="badge">30</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/19/UnrealStudy/Unreal%E9%9A%8F%E7%AC%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="VisionXie">
      <meta itemprop="description" content="生活在树上，始终热爱大地，升入天空。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiMo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Unreal随笔
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-20 00:00:00" itemprop="dateCreated datePublished" datetime="2021-08-20T00:00:00+08:00">2021-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-05-12 00:00:00" itemprop="dateModified" datetime="2023-05-12T00:00:00+08:00">2023-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UnrealEngine/" itemprop="url" rel="index"><span itemprop="name">UnrealEngine</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    
      <a title="changyan" href="/2021/08/19/UnrealStudy/Unreal%E9%9A%8F%E7%AC%94/#SOHUCS" itemprop="discussionUrl">
        <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2021/08/19/UnrealStudy/Unreal随笔/" itemprop="commentCount"></span>
      </a>
    
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>关于UE4的一些随笔</p>
<span id="more"></span>

<h2 id="Actor的EndPlay事件在哪些时候会调用？"><a href="#Actor的EndPlay事件在哪些时候会调用？" class="headerlink" title="Actor的EndPlay事件在哪些时候会调用？"></a>Actor的EndPlay事件在哪些时候会调用？</h2><p>EndPlay - 在数个地方调用，保证 Actor 的生命走向终点。在游戏过程中，如包含流关卡的<br>Actor 被卸载，Destroy 将发射此项和关卡过渡。调用 EndPlay 的全部情形：<br>   （1）对 Destroy 显式调用<br>   （2）Play in Editor 终结<br>   （3）关卡过渡（无缝行程或加载地图） 包含 Actor 的流关卡被卸载<br>   （4）Actor 的生命期已过<br>   （5）应用程序关闭（全部 Actor 被销毁）</p>
<h2 id="BlueprintImplementableEvent和BlueprintNativeEvent之间有什么区别？"><a href="#BlueprintImplementableEvent和BlueprintNativeEvent之间有什么区别？" class="headerlink" title="BlueprintImplementableEvent和BlueprintNativeEvent之间有什么区别？"></a>BlueprintImplementableEvent和BlueprintNativeEvent之间有什么区别？</h2><p>BlueprintImplementableEvent和BluuprintNativeEvent两者都是函数标记，用于修饰<br>函数的。</p>
<p>BlueprintImplementableEvent：在C++可以声明函数（不能定义，蓝图重写），<br> 在C++里调用该函数，蓝图重写实现该函数</p>
<p>BlueprintNativeEvent：在C++可以声明和定义函数，在C++里调用该函数，蓝图重写<br> 实现该函数（蓝图可以重写或不重写C++父类函数）<br>使用方法:<br>UFUNCTION(BlueprintImplementableEvent) void TestA();<br>UFUNCTION(BlueprintNativeEvent) void TestB();</p>
<h2 id="BlurprintPure在什么时候使用？"><a href="#BlurprintPure在什么时候使用？" class="headerlink" title="BlurprintPure在什么时候使用？"></a>BlurprintPure在什么时候使用？</h2><p>BlueprintPure的特点是在C++和蓝图中都可以调用，但是其修饰的函数必须有函数返回值或<br>函数参数输出，否则会编译失败。被声明的函数不会以任何方式拥有对象，并且可以在蓝图<br>或级别蓝图图标中执行。<br>因此，BlueprintPurs修饰的函数，主要用于（1）数学中的“+、-、*、/”操作  （数值处理），<br>（2）变量获取节点（获取变量中的部分数据）</p>
<h2 id="UE4的蓝图中对于Foreach等循环采用的是类似并行的方式，试实现一个串行的方法"><a href="#UE4的蓝图中对于Foreach等循环采用的是类似并行的方式，试实现一个串行的方法" class="headerlink" title="UE4的蓝图中对于Foreach等循环采用的是类似并行的方式，试实现一个串行的方法"></a>UE4的蓝图中对于Foreach等循环采用的是类似并行的方式，试实现一个串行的方法</h2><p>首先需要了解并行和串行的区别。<br>并行通讯：同一时刻，可以一次性执行多步。<br>串行通讯：同一时刻，只能一步一步的执行。<br>for(int i=0;i&lt;10;i++);//所以我自己写个循环，不开多线程应该就可以了吧。毕竟没有<br>找到标准答案，只能自己猜测了。求大佬，教教我。</p>
<h2 id="如何解决子弹穿墙问题？"><a href="#如何解决子弹穿墙问题？" class="headerlink" title="如何解决子弹穿墙问题？"></a>如何解决子弹穿墙问题？</h2><p>如果采用的是射线检测的话，LineTracebyChannel函数只会返回首个命中对象。<br>但为了防止真出现子弹穿墙问题，<br>我们可以让LineTracebyChannel只要击中一个物体就会停止射线检测。</p>
<p>如果采用的是为子弹单独制作成一个物体的话，<br>在射击时，只要将墙体和子弹的碰撞属性设为Block,便会阻止子弹继续前进。</p>
<h2 id="UE4对UStruct的内存会自动管理吗？"><a href="#UE4对UStruct的内存会自动管理吗？" class="headerlink" title="UE4对UStruct的内存会自动管理吗？"></a>UE4对UStruct的内存会自动管理吗？</h2><p>不会，<br>只有使用UPROPERTY宏标记的USTRUCT才能被计入垃圾回收。</p>
<h2 id="在客户端是否可以获取到AIController？"><a href="#在客户端是否可以获取到AIController？" class="headerlink" title="在客户端是否可以获取到AIController？"></a>在客户端是否可以获取到AIController？</h2><p>不可以，在DS（dedicated server）模型下，AIController只存在于服务端，其主要是通过在服务端对Pawn进行操控，<br>然后再同步到客户端。</p>
<h2 id="客户端上面能够执行RPC的对象有哪些？"><a href="#客户端上面能够执行RPC的对象有哪些？" class="headerlink" title="客户端上面能够执行RPC的对象有哪些？"></a>客户端上面能够执行RPC的对象有哪些？</h2><p>RPC（远程过程调用），是在本地调用但能在其他机器（不同于执行调用的机器）上远程执行<br>的函数。<br>在客户端上能够执行RPG的对象需要满足：<br>（1）该Actor必须被复制<br>（2）如果RPC是从客户端调用并在服务器上执行，客户端就必须拥有调用RPC的Actor。<br>（3）如果是多播RPC是个例外：<br>当从客户端调用时，只是在本地运行而非服务器上执行。<br><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.26/zh-CN/InteractiveExperiences/Networking/Actors/RPCs/">https://docs.unrealengine.com/4.26/zh-CN/InteractiveExperiences/Networking/Actors/RPCs/</a></p>
<h2 id="如果在C-中需要使用windows的头文件，如何操作？"><a href="#如果在C-中需要使用windows的头文件，如何操作？" class="headerlink" title="如果在C++中需要使用windows的头文件，如何操作？"></a>如果在C++中需要使用windows的头文件，如何操作？</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “AllowWindowsPlatformTypes.h”</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “HideWindowsPlatformTypes.h”</span></span><br></pre></td></tr></table></figure>

<h2 id="在头文件中经常出现的-generated-h是什么？"><a href="#在头文件中经常出现的-generated-h是什么？" class="headerlink" title="在头文件中经常出现的*.generated.h是什么？"></a>在头文件中经常出现的*.generated.h是什么？</h2><p>当一个头文件中 include “xxx.generated.h“，意味着这个头文件加入了反射系统。那些UPROPERTY, UFUNCTION 之类的宏，也标记着这些方法属性等等加入了 UE4 的反射系统，<br>加入了反射系统，UE4 才能帮你做 GC（垃圾回收），你才能实现蓝图、C++ 通信等等很多功能。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Bob__yuan/article/details/106200971">https://blog.csdn.net/Bob__yuan/article/details/106200971</a></p>
<h2 id="UE4-入门宏"><a href="#UE4-入门宏" class="headerlink" title="UE4 入门宏"></a>UE4 入门宏</h2><p>UE4中的宏Macro，和函数比较相似，都是对一些功能算法进行了封装，都有一个输入点和输出点，调用方法也类似。<br>宏与函数的区别在于：<br>（1）宏是直接展开，即直接将宏的代码直接复制替换到所有使用当前宏的地方，<br>这点类似于c++中的宏，而函数则是需要编译。<br>（2）宏运行时无实体，函数运行时有实体。<br>（3）宏有多个入口Exec多个出口Exec，函数只有一个入口Exec一个出口Exec。<br>（4）宏可以使用Delay,函数不可以使用Delay。<br>（5）宏不可以复制，函数可以复制。<br>（6）宏的参数可以使用“Exec”类型，函数不可以<br>宏的特点：<br>（1）类的成员函数可以被子类继承，但宏不会被继承，子类无法使用父类的宏<br>（2）可以自定义宏库，供所有蓝图使用<br>（3）宏特别适合于制作控制流，如引擎自带的FilpFlop。<br>（4）宏中定义局部变量，只能使用基本数据类型，不能使用类类型。<br>宏 ：执行快，功能更强，但占据空间多，安全性差</p>
<p>函数：执行较慢，占空间少，安全性高</p>
<p>个人总结，优先用函数，少用宏</p>
<h2 id="对一个Actor调用AIMoveTo失败了，其可能原因是什么？"><a href="#对一个Actor调用AIMoveTo失败了，其可能原因是什么？" class="headerlink" title="对一个Actor调用AIMoveTo失败了，其可能原因是什么？"></a>对一个Actor调用AIMoveTo失败了，其可能原因是什么？</h2><p>（1）未放入NavMesh和NavRecast.<br>（2）Nav导航组件设置太大，也可能会导致失效<br>（3）目标点超出Nav导航范围。</p>
<h2 id="试说出宏、函数、事件的部分区别和联系"><a href="#试说出宏、函数、事件的部分区别和联系" class="headerlink" title="试说出宏、函数、事件的部分区别和联系"></a>试说出宏、函数、事件的部分区别和联系</h2><p>函数与事件的区别：<br>1、函数有返回值，事件无返回值<br>2、函数调用会等待函数执行结果，事件调用只是触发但不会等待。<br>3、函数执行在同一个线程，事件执行在不同线程。<br>4、函数可以用局部变量，事件没有局部变量。<br>5、因为函数执行顺序有保证，所以优先使用函数<br>6、没有返回值的函数，在被子类Overide时，会变成事件。<br>宏与函数的区别在于：<br>（1）宏是直接展开，即直接将宏的代码直接复制替换到所有使用当前宏的地方，<br>这点类似于c++中的宏，而函数则是需要编译。<br>（2）宏运行时无实体，函数运行时有实体。<br>（3）宏有多个入口Exec多个出口Exec，函数只有一个入口Exec一个出口Exec。<br>（4）宏可以使用Delay,函数不可以使用Delay。<br>（5）宏不可以复制，函数可以复制。<br>（6）宏的参数可以使用“Exec”类型，函数不可以</p>
<h2 id="试使用C-实现一个对蓝图中任意Actor排序的框架"><a href="#试使用C-实现一个对蓝图中任意Actor排序的框架" class="headerlink" title="试使用C++实现一个对蓝图中任意Actor排序的框架"></a>试使用C++实现一个对蓝图中任意Actor排序的框架</h2><p>（1）创建蓝图宏库，鼠标右键-&gt;Blueprints-&gt;Blueprint Macro Library -&gt;<br>All Classes-&gt;Object，以UObject作为蓝图宏库的基类。<br>（2）My Blueprint窗口，Add New创建二个宏Select Sort、Bubble Sort；<br>（3）实现代码逻辑<br>Description：<br>选择排序(详情请查阅选择排序方法)<br>bGreater=( Array[min] &gt;Array[i] ) ? true : false;<br>将Array[min]与Array[i]成员的大小比较结果连接上bGreater(pin)<br>内部循环根据bGreater(bool)值判断是否交换Array[min]与Array[i]成员位置<br>排序结束，返回有序数组</p>
<h2 id="Blueprintable和BlueprintType的意义"><a href="#Blueprintable和BlueprintType的意义" class="headerlink" title="Blueprintable和BlueprintType的意义"></a>Blueprintable和BlueprintType的意义</h2><p>Blueprintable:将使用该宏标志的类公开为创建蓝图的可接受基类（类似于：那些base类）。<br>其默认为NotBlueprintable,即不可以创建蓝图子类。</p>
<p>BlueprintType:将使用该宏标志的类公开为可用于蓝图中变量的类型（类似于：int）。<br>与之对应的有NotBlueprintType，即不可以在蓝图中创建该类型的变量。</p>
<h2 id="客户端上面对一个Actor中的RPC事件调用失败，可能原因是什么？"><a href="#客户端上面对一个Actor中的RPC事件调用失败，可能原因是什么？" class="headerlink" title="客户端上面对一个Actor中的RPC事件调用失败，可能原因是什么？"></a>客户端上面对一个Actor中的RPC事件调用失败，可能原因是什么？</h2><p>（1）该Actor不可被复制<br>（2）其他的客户端上，未拥有可以调用RPC的Actor。<br>（3）在Pawn派生类的蓝图收到Possessed事件时，Connection-&gt;ViesTarget还未被赋值。</p>
<h2 id="UE4中的RPC事件有哪些？"><a href="#UE4中的RPC事件有哪些？" class="headerlink" title="UE4中的RPC事件有哪些？"></a>UE4中的RPC事件有哪些？</h2><p>RPC主要包括Multicast（广播）、Run On Server（在服务端执行）和Run On Owning Client<br>（在客户端执行）三种类型。其中广播类型在服务器上调用执行，然后自动转发给客户端；<br>在服务端执行的函数有客户端调用，然后仅在服务器执行。在客户端执行的函数由服务器<br>调用，然后仅在自己的客户端上执行。</p>
<h2 id="如何设置Actor的同步间隔？"><a href="#如何设置Actor的同步间隔？" class="headerlink" title="如何设置Actor的同步间隔？"></a>如何设置Actor的同步间隔？</h2><p>更改Actor中的：NetUpdateFrequency 网络更新频率属性。</p>
<h2 id="若需要实现一个多播事件，如何操作？"><a href="#若需要实现一个多播事件，如何操作？" class="headerlink" title="若需要实现一个多播事件，如何操作？"></a>若需要实现一个多播事件，如何操作？</h2><p>不是很理解这个问题问的是网络的多播，还是多播委托。<br>网络的多播：（1）先使用”Switch Has Authority”判断是否在服务器端。然后在事件的<br>Detials中将Replacates设置为Multicast。<br>（2）先创建一个只在服务端运行的事件，然后由该事件去执行播放方法。<br>多播委托：<br>（1）构建动态代理<br>（2）在类内部声明动态代理对象<br>（3）在蓝图中绑定<br>（4）在CPP中执行多播委托。</p>
<h2 id="连接服务器的命令是什么，如何传递参数？"><a href="#连接服务器的命令是什么，如何传递参数？" class="headerlink" title="连接服务器的命令是什么，如何传递参数？"></a>连接服务器的命令是什么，如何传递参数？</h2><p>连接服务器的命令是Socket-&gt;Connect（<em>addr）；<br>其中的</em>addr是InternetAddr指针，用于传递IP和Port。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39781267/article/details/81745853">https://blog.csdn.net/weixin_39781267/article/details/81745853</a></p>
<h2 id="为什么需要TWeakPtr？"><a href="#为什么需要TWeakPtr？" class="headerlink" title="为什么需要TWeakPtr？"></a>为什么需要TWeakPtr？</h2><p>TWeakPtr不会参与应用技术，当TWeakPtr指向的对象不存在共享指针指向时，TWeakPtr将<br>自动失效，所以该指针的时候需要有效性判断。用于非UObject类，想要引用它又不想因为引<br>用它而影响引用计数时。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangxiaofan666/article/details/99733735">https://blog.csdn.net/zhangxiaofan666/article/details/99733735</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/github_38111866/article/details/107712692">https://blog.csdn.net/github_38111866/article/details/107712692</a></p>
<h2 id="UE4的模块系统"><a href="#UE4的模块系统" class="headerlink" title="UE4的模块系统"></a>UE4的模块系统</h2><p>首先：UE4中模块分为5部分：<br>Developer主要是跨平台工具，Merge和一些底层的工具。<br>Editor主要是编辑器相关的代码<br>Programs主要是独立于引擎，但大多数又依赖引擎的工具，UBT就在这里<br>ThirdParty第三方库或者插件<br>RunTime是主要的Gameplay等等和游戏相关的代码了。<br>UE4模块系统详解<br>UE4中的模块（module）介绍</p>
<h2 id="简单介绍一下对象系统（UObject类）和类型系统（UClass类）"><a href="#简单介绍一下对象系统（UObject类）和类型系统（UClass类）" class="headerlink" title="简单介绍一下对象系统（UObject类）和类型系统（UClass类）"></a>简单介绍一下对象系统（UObject类）和类型系统（UClass类）</h2><p>UObject类为对象系统的基类。该类的主要作用是存放对象的名字、标记信息<br>（ObjectFlags）、类型信息（ClassPrivate）、Outer对象和在对象管理数组中的索引。<br>UClass类主要用于描述C++中的类信息。在UE4在UClass实例不仅仅用于描述<br>C++(Native)类，也用来描述Blueprint生成的类。<br>UE4对象系统_UObject&amp;UClass</p>
<h2 id="Core模块包含了哪些基础类"><a href="#Core模块包含了哪些基础类" class="headerlink" title="Core模块包含了哪些基础类"></a>Core模块包含了哪些基础类</h2><p>Core模块下有很多文件夹：<br>Containers 包含各种C++容器类：Array、List、Map、Queue、Set等等<br>Delegates 包含各种代理声明的宏：DECLARE_DELEGATE、DECLARE_MULTICAST_DELEGATE、DECLARE_EVENT等等<br>Logging 包含日志功能类和宏：UE_LOG、ELogVerbosity等等<br>Math 包含各种数学函数和结构：Box、Color、Matrix、Quat、Range、Rotator、<br>Vector、UnrealMath等等<br>【UE4源代码观察】观察Core模块</p>
<h2 id="RHI模块"><a href="#RHI模块" class="headerlink" title="RHI模块"></a>RHI模块</h2><p>RHI即RenderHardwareInterface, 即渲染硬件接口, 是UE为实现跨平台而实现的一套API.<br>每个RHI接口都为OpenGL, Vulkan, DX11等做了不同的实现. 在引擎初始化时使用的绘图<br>接口就已经确定, 引擎就可以确定RHI所使用接口的版本.<br>【UE4源代码观察】观察 RHI、D3D11RHI、RenderCore 这三个模块的依赖关系</p>
<h2 id="Engine模块"><a href="#Engine模块" class="headerlink" title="Engine模块"></a>Engine模块</h2><p>Engine模块主要用于定义actor和组件，同时实现了游戏的基本框架。</p>
<h2 id="UMG-模块"><a href="#UMG-模块" class="headerlink" title="UMG 模块"></a>UMG 模块</h2><p>UMG模块是虚幻运动图形的简称。<br>主要用到以下几种文件：<br> 1、Blueprint（ User Inteface-Blueprint） 也就是常说的UMG，是我们常用的UI工程文件<br> 2、Font（字体资源拖入Content Browser自动生成）字体文件<br> 3、Texture (PNG资源拖进来可以自动生成) 图片资源文件<br> 4、Material 材质文件，可用于UI材质或者mesh材质<br> 5、Actor（Blueprint Class-Actor）可以摆放到场景中的文件类型，用于制作3DUI</p>
<h2 id="UE4中的类型系统"><a href="#UE4中的类型系统" class="headerlink" title="UE4中的类型系统"></a>UE4中的类型系统</h2><p>UE4的宏可以分为四种：UCLASS、USTRUCT、UFUNCTION、UPROPERTY。<br>其中：</p>
<ul>
<li>UCLASS用于修饰类</li>
<li>USTRUCT用于修饰结构体</li>
<li>UFUNCTION用于修饰函数</li>
<li>UPROPERTY用于修饰变量</li>
</ul>
<p>29、如果要在游戏的开始和结束执行某些操作，可以在UE4哪儿处理？<br>如果你是指的一个关卡的开始和结束位置执行某些操作的话，可以创建一个Actor专门用于执行<br>这些事件。开始的操作放在BeginPlay中，结束的操作是在EndPlay中。BeginPlay会在关卡开<br>始时调用，EndPlay会在关卡切换的时候调用。注意该Actor不能提前调用Actor的EndPlay。<br>如果是还要开始一些的话，就是LevelActor的Construct()函数。<br>如果是还要晚一些的话，就是LevelActor的BeginPlay()函数。<br>再开始一些的话，就是GameInstance中的Init()函数。</p>
<h2 id="UE4中，各种字符编码如何转换？"><a href="#UE4中，各种字符编码如何转换？" class="headerlink" title="UE4中，各种字符编码如何转换？"></a>UE4中，各种字符编码如何转换？</h2><p>可以通过以下的五个宏来完成字符编码转换。<br>    TCHAR_TO_ANSI(str)<br>    TCHAR_TO_OEM(str)<br>    ANSI_TO_TCHAR(str)<br>    TCHAR_TO_UTF8(str)//TCHAR转UTF8<br>    UTF8_TO_TCHAR(str)</p>
<h2 id="C-源文件中的注释在蓝图中显示为乱码，为什么？"><a href="#C-源文件中的注释在蓝图中显示为乱码，为什么？" class="headerlink" title="C++源文件中的注释在蓝图中显示为乱码，为什么？"></a>C++源文件中的注释在蓝图中显示为乱码，为什么？</h2><p>需要将C++源文件的文件编码格式改为UTF-8格式。<br>修改方法，Vs-文件-高级保存选项-utf-8，<br>在VS2017中，需要自定义来显示这个选项:</p>
<ul>
<li>1 工具→自定义；</li>
<li>2 点击 命令 标签；</li>
<li>3 在上方单选区选中 菜单栏，下拉列表选 文件；</li>
<li>4 点击 添加命令</li>
<li>5 在类别中，找到文件，在右侧找到高级保存选项，确定</li>
</ul>
<h2 id="插件中的LoadingPhase是什么？"><a href="#插件中的LoadingPhase是什么？" class="headerlink" title="插件中的LoadingPhase是什么？"></a>插件中的LoadingPhase是什么？</h2><p>LoadingPhase主要用于控制插件在引擎启动的何时被加载。<br>有三个选项如下：<br>Default为正常阶段加载该模块。<br>PreDefault为正常阶段前来加载模块。<br>PostConfigInit为在引擎开始加载核心的子系统前加载该模块。</p>
<h2 id="如何切换不同的引擎版本？"><a href="#如何切换不同的引擎版本？" class="headerlink" title="如何切换不同的引擎版本？"></a>如何切换不同的引擎版本？</h2><ul>
<li>1、直接在Epic商城里面找到虚幻引擎选项，进入后，点击启动旁边的那个下拉符号，即可切换版本。</li>
<li>2、先找到项目文件夹下的.uproject文件，然后鼠标右键-&gt;Switch Unreal Engine version，<br>切换好版本后，直接打开即可。</li>
</ul>
<h2 id="对于一个团队项目，如何处理DDC？"><a href="#对于一个团队项目，如何处理DDC？" class="headerlink" title="对于一个团队项目，如何处理DDC？"></a>对于一个团队项目，如何处理DDC？</h2><p>DDC为派生数据缓存。<br>如果是同一地点的团队或者是小团队，可以设置共享DDC。此为所有团队成员和构建计算机均可<br>读取/写入的网络驱动器。<br>如果是大型项目，并希望分发预构建DDC数据，则应该生成DDC pak。</p>
<h2 id="UFUNCTION，UPROPERTY等宏的作用是什么？"><a href="#UFUNCTION，UPROPERTY等宏的作用是什么？" class="headerlink" title="UFUNCTION，UPROPERTY等宏的作用是什么？"></a>UFUNCTION，UPROPERTY等宏的作用是什么？</h2><ul>
<li>1、UFUNCTION宏用于将C++函数设置为UE4反射系统可识别的C++函数。其函数说明符可以更改</li>
<li>2、UE4解释和使用函数的方式。</li>
<li>3、UPROPERTY宏则是可以通过定于属性元数据和变量说明符，来对属性实现一些UE的特定操作。如显示到细节面板。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149392857">https://zhuanlan.zhihu.com/p/149392857</a></li>
</ul>
<h2 id="如何给AI增加playerstate？"><a href="#如何给AI增加playerstate？" class="headerlink" title="如何给AI增加playerstate？"></a>如何给AI增加playerstate？</h2><p>默认情况下，AI并没有playerstate，如果需要，可以在构造函数中增加<br>bWantsPlayerState = true;</p>
<h2 id="ProjectileComponent是否同步？若未同步，如何操作？"><a href="#ProjectileComponent是否同步？若未同步，如何操作？" class="headerlink" title="ProjectileComponent是否同步？若未同步，如何操作？"></a>ProjectileComponent是否同步？若未同步，如何操作？</h2><p>并不是同步的。需要通过RPC进行同步。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/343847343">https://zhuanlan.zhihu.com/p/343847343</a></p>
<h2 id="若要更改某个Actor中的组件为其派生的组件，如何操作？"><a href="#若要更改某个Actor中的组件为其派生的组件，如何操作？" class="headerlink" title="若要更改某个Actor中的组件为其派生的组件，如何操作？"></a>若要更改某个Actor中的组件为其派生的组件，如何操作？</h2><p>不知道我是否理解错误，这个“其派生的组件”中的“其”是指的Actor中的组件。<br>在一开始将该父类组件申明为指针，当要更改时，直接指向其派生的组件对象即可。</p>
<h2 id="UE4的游戏框架包含哪些内容？"><a href="#UE4的游戏框架包含哪些内容？" class="headerlink" title="UE4的游戏框架包含哪些内容？"></a>UE4的游戏框架包含哪些内容？</h2><p>（1）使用玩家输入或者AI逻辑控制Pawns<br>Controller是一个负责指导Pawn的Actor。它们通常有两种版本，AIController和<br>PlayerController。控制器可以“拥有”一个Pawn来控制它。<br>PlayerController是Pawn与玩家控制他之间的接口。其代表了玩家的意志。<br>AIController是一个可以控制Pawn的模拟意志。</p>
<p>（2）代表世界的玩家、朋友、敌人<br>Pawn是一个actor。Pawn可以被Controller持有，他们可以接收输入，可以做很多游戏逻辑。<br>Character是一个人形风格的Pawn，继承自Pawn。他默认自带一个胶囊体碰撞器和角色运动组件。他可以做到基本的人形移动，他可以平滑的复制移动并且有一些动画相关的功能。</p>
<p>（3）向玩家展现信息<br>HUD是一个抬头显示器。可以显示健康、弹药等，每个PlayerController通常有一个。<br>Camera相当于玩家的眼球并且管理他的行为。每个PlayerController通常也有其中一个。</p>
<p>（4）设置与追踪游戏的规则<br>游戏模式（GameMode）游戏的概念分为两类。GameMode与GameState是游戏的定义，<br>包括像游戏规则的事情，胜利的条件。他只存在于服务器上。他通常没有太多的数据变化，<br>也没有客户端需要了解的瞬态数据。<br>游戏状态（GameState）包括像关联球员名单得分，那里的作品是一盘棋，或者游戏中的<br>任务完成列表。GameState存在于所有服务器与客户端上，可自由复制使所有计算机保持<br>最新状态。<br>玩家状态（PlayerState）是游戏参与者的状态，PlayerState包含玩家姓名，得分，<br>类似MOBA的匹配等级。所有玩家的PlayerState存在于所有机器上，可以自由复制保持同步。</p>
<h2 id="当前UE4在移动平台上面的问题有哪些？"><a href="#当前UE4在移动平台上面的问题有哪些？" class="headerlink" title="当前UE4在移动平台上面的问题有哪些？"></a>当前UE4在移动平台上面的问题有哪些？</h2><p>UE4在移动平台上面的问题主要包括以下几个方面：</p>
<ul>
<li><p>性能问题<br>UE4在移动平台上的性能表现相对较差，尤其是在低端设备上。这主要是由于移动设备的硬件性能相对较弱，而UE4的渲染和物理引擎等功能较为复杂，需要较高的计算资源。</p>
</li>
<li><p>内存问题<br>移动设备的内存容量相对较小，而UE4的资源占用较大，容易导致内存不足的问题。这可能会导致游戏崩溃或者运行缓慢。</p>
</li>
<li><p>控制问题<br>移动设备的控制方式与PC和主机有所不同，需要针对移动设备进行优化。例如，需要设计适合触摸屏幕的控制方式，或者支持外接手柄等设备。</p>
</li>
<li><p>兼容性问题<br>移动设备的硬件和操作系统版本繁多，需要针对不同的设备进行兼容性测试和优化。这可能会增加开发和测试的难度和成本。</p>
</li>
<li><p>网络问题<br>移动设备通常使用无线网络连接，网络质量不稳定，可能会导致游戏延迟或者断线。需要针对网络不稳定的情况进行优化，例如使用预测性技术来减少延迟。</p>
</li>
</ul>
<p>需要注意的是，这些问题并不是UE4在移动平台上的全部问题，具体问题还需要根据游戏的具体需求和设计进行分析和解决。</p>
<h2 id="UE4服务器的默认监听端口是哪一个？采用的是UDP还是TCP协议？"><a href="#UE4服务器的默认监听端口是哪一个？采用的是UDP还是TCP协议？" class="headerlink" title="UE4服务器的默认监听端口是哪一个？采用的是UDP还是TCP协议？"></a>UE4服务器的默认监听端口是哪一个？采用的是UDP还是TCP协议？</h2><p>UE4服务器的默认监听端口是7777，采用的是UDP协议。</p>
<p>在UE4中，服务器和客户端之间的通信采用的是UDP协议。UDP协议是一种无连接的协议，不需要建立连接就可以发送数据，因此具有较低的延迟和较高的吞吐量。这使得UDP协议非常适合实时游戏等对延迟和带宽要求较高的应用场景。</p>
<p>UE4服务器默认监听的端口是7777，这是UE4引擎中预定义的端口号。如果需要修改监听端口，可以在服务器启动时通过命令行参数或者配置文件进行设置。例如，可以使用以下命令启动服务器并指定监听端口为8888：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyServer.exe -port=<span class="number">8888</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果在防火墙或者路由器中使用了端口转发，还需要将转发的端口设置为7777或者修改UE4服务器的监听端口为转发的端口。</p>
<h2 id="Tick中的帧时间是否可靠？若不可靠，如何操作？"><a href="#Tick中的帧时间是否可靠？若不可靠，如何操作？" class="headerlink" title="Tick中的帧时间是否可靠？若不可靠，如何操作？"></a>Tick中的帧时间是否可靠？若不可靠，如何操作？</h2><p>在UE4中，Tick函数中的帧时间（DeltaTime）是相对可靠的，但并不是完全可靠的。DeltaTime表示上一帧和当前帧之间的时间差，通常情况下，它的值应该是比较稳定的，但在某些情况下，它可能会出现异常值或者不稳定的情况。</p>
<p>例如，当游戏运行在低端设备上或者遇到性能瓶颈时，DeltaTime的值可能会变得不稳定，甚至出现负值。这可能会导致游戏出现卡顿、闪烁等问题。</p>
<p>为了解决这个问题，可以采用以下方法：</p>
<p>使用FApp::GetCurrentTime()函数获取当前时间，计算上一帧和当前帧之间的时间差。这种方法可以避免DeltaTime出现异常值的情况。</p>
<p>使用UGameplayStatics::GetWorldDeltaSeconds()函数获取当前帧的时间步长。这种方法可以避免DeltaTime出现负值的情况。</p>
<p>使用固定时间步长更新游戏逻辑，而不是依赖于DeltaTime。这种方法可以保证游戏逻辑的稳定性，但可能会影响游戏的表现效果。</p>
<p>需要注意的是，以上方法都有各自的优缺点，具体使用哪种方法取决于游戏的具体需求和设计。</p>
<h2 id="UE4的打包方法有哪些？"><a href="#UE4的打包方法有哪些？" class="headerlink" title="UE4的打包方法有哪些？"></a>UE4的打包方法有哪些？</h2><ul>
<li><strong>编辑器打包</strong><br>File -&gt; Package Project -&gt; 目标平台<br>编译配置<br>DebugGame<br>Development<br>Shipping<br>默认生成路径 [ProjectName]\WindowsNoEditor,可自定义路径<br>更多设置 ProjectSettings -&gt; Package<br>日志 Running AutomationTool 部分</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Running AutomationTool</span><br><span class="line">UATHelper: <span class="built_in">Packaging</span> (<span class="built_in">Windows</span> (<span class="number">64</span>-bit)): Parsing command line:</span><br><span class="line"> -ScriptsForProject=<span class="string">&quot;C:/Users/Alice/Documents/Unreal Projects/tips/tips.uproject&quot;</span></span><br><span class="line"> BuildCookRun -nocompileeditor -installed -nop4</span><br><span class="line"> -project=<span class="string">&quot;C:/Users/Alice/Documents/Unreal Projects/tips/tips.uproject&quot;</span></span><br><span class="line"> -cook -stage -archive</span><br><span class="line"> -archivedirectory=<span class="string">&quot;C:/Users/Alice/Documents/Unreal Projects/tips&quot;</span></span><br><span class="line"> -package</span><br><span class="line"> -ue4exe=C:\SoftwareInstallation\EpicGames\UE_4<span class="number">.26</span>\Engine\Binaries\Win64\UE4Editor-Cmd.exe</span><br><span class="line"> -compressed</span><br><span class="line"> -ddc=InstalledDerivedDataBackendGraph</span><br><span class="line"> -pak</span><br><span class="line"> -prereqs</span><br><span class="line"> -nodebuginfo</span><br><span class="line"> -targetplatform=Win64</span><br><span class="line"> -build</span><br><span class="line"> -target=tips</span><br><span class="line"> -clientconfig=Development</span><br><span class="line"> -utf8output</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30471065/article/details/95887209">https://blog.csdn.net/weixin_30471065/article/details/95887209</a></p>
<h2 id="如何制作差异包或者补丁？"><a href="#如何制作差异包或者补丁？" class="headerlink" title="如何制作差异包或者补丁？"></a>如何制作差异包或者补丁？</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30471065/article/details/95887209">https://blog.csdn.net/weixin_30471065/article/details/95887209</a></p>
<h2 id="试说出Selector、Sequence、Parallel的运作流程"><a href="#试说出Selector、Sequence、Parallel的运作流程" class="headerlink" title="试说出Selector、Sequence、Parallel的运作流程"></a>试说出Selector、Sequence、Parallel的运作流程</h2><p>组合节点是用来组装各节点的逻辑。</p>
<p>在行为树中，组合节点分为三类：sequence、selector、simpleparallel这三类。</p>
<ul>
<li><p>sequence表示：按照顺序 执行该节点下的所有节点，并且当其中有一个节点返回fail时，停止执行后续所有行为并且 sequence节点返回 fail。</p>
</li>
<li><p>selector表示：按照顺序执行该节点下的所有节点，并且当其中有一个节点返回success时，停止执行后续所有行为并且selector节点返回success。</p>
</li>
<li><p>simpleparallel表示：平行执行任务，左边有个紫色的快，从那个块中拉出的其他节点会被视作主要任务，从右边灰色块中拉出的任务被视为平行任务，当主要任务结束时，主要任务返回success/fail 则simpleparallel返回success/fail，与平行任务无关。finsh mode表示结束模式， immediate表示 主要任务结束 则平行任务强行终止，delay表示 主要任务结束 等平行任务结束后 再终止。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_39287935/article/details/108007394">https://blog.csdn.net/sinat_39287935/article/details/108007394</a></p>
<h2 id="UE4中的AI感知组件有哪些？"><a href="#UE4中的AI感知组件有哪些？" class="headerlink" title="UE4中的AI感知组件有哪些？"></a>UE4中的AI感知组件有哪些？</h2><p>AIPerception<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/510629683">https://zhuanlan.zhihu.com/p/510629683</a></p>
<h2 id="在UE4的C-中调用父类的函数，如何操作？"><a href="#在UE4的C-中调用父类的函数，如何操作？" class="headerlink" title="在UE4的C++中调用父类的函数，如何操作？"></a>在UE4的C++中调用父类的函数，如何操作？</h2><p>在override的xxx函数中调用 Super::xxx();</p>
<h2 id="UE4内置的伤害接口是什么，有哪些类型？"><a href="#UE4内置的伤害接口是什么，有哪些类型？" class="headerlink" title="UE4内置的伤害接口是什么，有哪些类型？"></a>UE4内置的伤害接口是什么，有哪些类型？</h2><p>在UE4中，内置的伤害接口是Damage函数，它定义在AActor类中。Damage函数用于处理角色受到伤害时的逻辑，可以通过调用该函数来对角色造成伤害。</p>
<p>Damage函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">TakeDamage</span><span class="params">(<span class="keyword">float</span> DamageAmount, FDamageEvent <span class="keyword">const</span>&amp; DamageEvent, AController* EventInstigator, AActor* DamageCauser)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Damage函数的参数说明如下：</p>
<p>DamageAmount：伤害值，表示角色受到的伤害量。<br>DamageEvent：伤害事件，表示造成伤害的事件类型，例如子弹、爆炸等。<br>EventInstigator：事件发起者，表示造成伤害的角色控制器。<br>DamageCauser：伤害来源，表示造成伤害的角色。<br>除了Damage函数外，UE4还提供了一些伤害事件类型，可以用于指定造成伤害的具体类型。这些事件类型包括：</p>
<p>FDamageEvent：基本伤害事件类型，可以用于表示任何类型的伤害。<br>FRadialDamageEvent：径向伤害事件类型，可以用于表示爆炸等径向伤害。<br>FPointDamageEvent：点伤害事件类型，可以用于表示子弹等点状伤害。<br>需要注意的是，这些伤害事件类型都是结构体，需要在使用前进行初始化。例如，可以使用以下代码创建一个点伤害事件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FPointDamageEvent <span class="title">DamageEvent</span><span class="params">(DamageAmount, HitResult, ShotDirection, <span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，DamageAmount表示伤害值，HitResult表示命中结果，ShotDirection表示射击方向，nullptr表示伤害来源为空。</p>
<h2 id="UE4中的联网会话节点有哪些？"><a href="#UE4中的联网会话节点有哪些？" class="headerlink" title="UE4中的联网会话节点有哪些？"></a>UE4中的联网会话节点有哪些？</h2><p>在UE4中，联网会话节点用于创建和管理多人游戏的会话。UE4提供了多种不同类型的联网会话节点，可以根据游戏的需求和设计选择合适的节点类型。以下是UE4中常用的联网会话节点：</p>
<p>Create Session：创建一个新的联网会话。可以指定会话名称、最大玩家数量、是否允许加入中途等参数。</p>
<p>Find Sessions：查找当前可用的联网会话。可以指定会话名称、最大玩家数量、是否允许加入中途等参数。</p>
<p>Join Session：加入一个已有的联网会话。需要指定要加入的会话的信息，例如会话ID、会话名称等。</p>
<p>Destroy Session：销毁一个联网会话。需要指定要销毁的会话的信息，例如会话ID、会话名称等。</p>
<p>Start Session：启动一个已有的联网会话。需要指定要启动的会话的信息，例如会话ID、会话名称等。</p>
<p>End Session：结束一个已有的联网会话。需要指定要结束的会话的信息，例如会话ID、会话名称等。</p>
<p>Get Session State：获取一个联网会话的状态。可以获取会话的当前状态，例如正在创建、正在查找、已经加入等。</p>
<p>需要注意的是，以上联网会话节点只是UE4中的一部分，具体使用哪些节点取决于游戏的具体需求和设计。</p>
<h2 id="UE4中的字符串有哪些？"><a href="#UE4中的字符串有哪些？" class="headerlink" title="UE4中的字符串有哪些？"></a>UE4中的字符串有哪些？</h2><p>FName<br>FString<br>FText<br>官网给出的转换如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- **FName：FString**</span><br><span class="line">TestHUDString = TestHUDName.<span class="built_in">ToString</span>();</span><br><span class="line"></span><br><span class="line">- **FName：FText**</span><br><span class="line">TestHUDText = FText::<span class="built_in">FromName</span>(TestHUDName);FName -&gt; FText is valid in some cases, but be aware that the FNames<span class="number">&#x27;</span>s content will <span class="keyword">not</span> benefit from the FText<span class="number">&#x27;</span>s <span class="string">&quot;auto localization&quot;</span>.</span><br><span class="line"></span><br><span class="line">- **FString：FName**</span><br><span class="line">TestHUDName = <span class="built_in">FName</span>(*TestHUDString);FString -&gt; FName is dangerous as the conversion is lossy as FName<span class="number">&#x27;</span>s are <span class="keyword">case</span> insensitive.</span><br><span class="line"></span><br><span class="line">- **FString：FText**</span><br><span class="line">TestHUDText = FText::<span class="built_in">FromString</span>(TestHUDString);FString -&gt; FText is valid in some cases, but be aware that the FString<span class="number">&#x27;</span>s content will <span class="keyword">not</span> benefit from the FText<span class="number">&#x27;</span>s <span class="string">&quot;auto localization&quot;</span>.</span><br><span class="line"></span><br><span class="line">- **FText：FString**</span><br><span class="line">TestHUDString = TestHUDText.<span class="built_in">ToString</span>()；FText -&gt; FString is dangerous as it is a potentially lossy conversion <span class="keyword">for</span> some languages.</span><br><span class="line"></span><br><span class="line">- **FText：FName**</span><br><span class="line">There is no direct conversion from FText to FName. Instead, convert to FString <span class="keyword">and</span> then to FName.</span><br><span class="line">FText -&gt; FString -&gt; FName is dangerous as the conversion is lossy as FName<span class="number">&#x27;</span>s are <span class="keyword">case</span> insensitive.</span><br><span class="line"></span><br><span class="line">- **FString：int32**</span><br><span class="line">int32 TestInt = FCString::<span class="built_in">Atoi</span>(*MyFString);</span><br><span class="line"></span><br><span class="line">- **FString：<span class="keyword">float</span>**</span><br><span class="line"><span class="keyword">float</span> TestFloat = FCString::<span class="built_in">Atof</span>(*MyFString);</span><br><span class="line"></span><br><span class="line">- **int32：FString**</span><br><span class="line">FString TestString = FString::<span class="built_in">FromInt</span>(MyInt);</span><br><span class="line"></span><br><span class="line">- **<span class="keyword">float</span>：FString**</span><br><span class="line">FString TestString = FString::<span class="built_in">SanitizeFloat</span>(MyFloat);</span><br></pre></td></tr></table></figure>

<h2 id="获取和释放角色如何操作？"><a href="#获取和释放角色如何操作？" class="headerlink" title="获取和释放角色如何操作？"></a>获取和释放角色如何操作？</h2><p>获取和释放角色通常是通过获取和释放指向该角色的指针来完成的。在UE4中，可以使用以下方法来获取和释放角色：</p>
<p>获取角色指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ACharacter* MyCharacter = UGameplayStatics::<span class="built_in">GetPlayerCharacter</span>(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">上面的代码将获取当前游戏中的第一个玩家角色，并将其指针存储在MyCharacter变量中。如果需要获取其他玩家角色，可以将第二个参数更改为相应的玩家索引。</span><br><span class="line"></span><br><span class="line">释放角色指针：</span><br><span class="line">MyCharacter-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line">上面的代码将销毁MyCharacter指向的角色对象，并释放其内存。需要注意的是，释放角色指针后，该角色对象将不再存在，因此在使用该指针之前应该确保它不为空。</span><br><span class="line"></span><br><span class="line">另外，如果需要在蓝图中获取和释放角色，可以使用GetPlayerCharacter和DestroyActor节点来实现相同的功能。</span><br></pre></td></tr></table></figure>

<h2 id="设置地图的游戏模式，有哪些方法？"><a href="#设置地图的游戏模式，有哪些方法？" class="headerlink" title="设置地图的游戏模式，有哪些方法？"></a>设置地图的游戏模式，有哪些方法？</h2><p>在UE4中，设置地图的游戏模式通常有以下几种方法：</p>
<p>在关卡编辑器中设置默认游戏模式<br>在关卡编辑器中，可以通过以下步骤设置默认游戏模式：</p>
<p>打开关卡编辑器<br>在场景中选择一个Actor<br>在“详细信息”面板中，找到“游戏模式”选项<br>从下拉菜单中选择要使用的游戏模式<br>这将设置该关卡的默认游戏模式。在运行游戏时，将使用该游戏模式来控制游戏逻辑。</p>
<p>在代码中设置游戏模式<br>在代码中，可以使用以下方法来设置游戏模式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AGameModeBase* MyGameMode = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetAuthGameMode</span>();</span><br><span class="line"><span class="keyword">if</span> (MyGameMode)</span><br><span class="line">&#123;</span><br><span class="line">    MyGameMode-&gt;DefaultPawnClass = MyPawnClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码将获取当前世界中的游戏模式，并将其默认的Pawn类设置为MyPawnClass。需要注意的是，这将影响所有在该游戏模式下创建的角色。</p>
<p>在蓝图中设置游戏模式<br>在蓝图中，可以使用以下节点来设置游戏模式：</p>
<p>“Get Game Mode”节点：获取当前游戏模式对象的引用。<br>“Set Default Pawn Class”节点：设置游戏模式的默认Pawn类。<br>“Set Game State Class”节点：设置游戏模式的GameState类。<br>需要注意的是，这些节点只能在游戏模式蓝图中使用，而不能在关卡蓝图中使用。</p>
<h2 id="玩家操作事件放在PlayerController和Pawn中，该如何选择？"><a href="#玩家操作事件放在PlayerController和Pawn中，该如何选择？" class="headerlink" title="玩家操作事件放在PlayerController和Pawn中，该如何选择？"></a>玩家操作事件放在PlayerController和Pawn中，该如何选择？</h2><p>在UE4中，玩家操作事件可以放在PlayerController和Pawn中。选择哪个类来处理这些事件取决于游戏的具体需求和设计。</p>
<p>一般来说，PlayerController处理与玩家输入相关的事件，例如按键、鼠标和手柄输入。Pawn处理与角色移动和交互相关的事件，例如移动、跳跃、攻击和受伤等。</p>
<p>如果游戏中的角色需要响应玩家输入并进行移动和交互，通常会将玩家操作事件放在Pawn中。例如，如果你正在制作一个第三人称动作游戏，你可能会将角色的移动、跳跃、攻击和受伤事件放在Pawn中。</p>
<p>如果游戏中需要处理复杂的玩家输入逻辑，例如按键组合、手柄震动和UI交互等，通常会将玩家操作事件放在PlayerController中。例如，如果你正在制作一个多人在线游戏，你可能会将玩家的聊天、组队和交易事件放在PlayerController中。</p>
<p>需要注意的是，PlayerController和Pawn都可以处理玩家操作事件，因此在某些情况下，你可能需要在两个类中都实现相同的事件处理逻辑。</p>
<h2 id="切换关卡的命令是什么？"><a href="#切换关卡的命令是什么？" class="headerlink" title="切换关卡的命令是什么？"></a>切换关卡的命令是什么？</h2><p>一般地图比较小，且关卡各自独立的时候，<br>使用openLevel，通过输入一个LevelName来切换关卡。</p>
<p>当在开放世界，即地图特别大的时候，我们会将多个关卡拼接为一个大世界地图， 然后采用<br>无缝切换地图的方式，来加载当前的地图。<br>此时有三个用来驱动转移的主要函数：<br>UEngine::Browse<br>UWorld::ServerTravel<br>APlayerController::ClientTravel。</p>
<h2 id="UE4中是否可以支持回放？如何操作？"><a href="#UE4中是否可以支持回放？如何操作？" class="headerlink" title="UE4中是否可以支持回放？如何操作？"></a>UE4中是否可以支持回放？如何操作？</h2><p>是的，UE4中支持回放功能，可以通过以下步骤来实现：</p>
<p>在UE4编辑器中，选择Edit -&gt; Project Settings，然后选择Network选项卡。</p>
<p>在Network选项卡中，将Replay Recording选项设置为Enabled。</p>
<p>在需要记录回放的地方，调用UE4中的RecordReplay函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">APlayerController* PlayerController = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController)</span><br><span class="line">&#123;</span><br><span class="line">    PlayerController-&gt;<span class="built_in">RecordReplay</span>();</span><br><span class="line">&#125;</span><br><span class="line">这将记录当前游戏状态，并将其保存到磁盘上的回放文件中。</span><br><span class="line"></span><br><span class="line">在需要回放的地方，调用UE4中的PlayReplay函数，例如：</span><br><span class="line"></span><br><span class="line">APlayerController* PlayerController = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstPlayerController</span>();</span><br><span class="line"><span class="keyword">if</span> (PlayerController)</span><br><span class="line">&#123;</span><br><span class="line">    FString ReplayFilename = <span class="built_in">TEXT</span>(<span class="string">&quot;MyReplay.replay&quot;</span>);</span><br><span class="line">    PlayerController-&gt;<span class="built_in">PlayReplay</span>(ReplayFilename);</span><br><span class="line">&#125;</span><br><span class="line">这将从磁盘上的回放文件中读取游戏状态，并将其应用到当前游戏中，从而实现回放功能。</span><br><span class="line"></span><br><span class="line">需要注意的是，回放功能会增加游戏的开销，因此应该尽量减少回放的使用，只在必要时才使用。此外，还应该注意回放文件的大小和存储位置，以避免占用过多的磁盘空间。</span><br></pre></td></tr></table></figure>
<h2 id="UE4的蓝图类型有哪些？"><a href="#UE4的蓝图类型有哪些？" class="headerlink" title="UE4的蓝图类型有哪些？"></a>UE4的蓝图类型有哪些？</h2><p>在UE4中，蓝图是一种可视化编程工具，用于创建游戏逻辑和交互。蓝图可以分为以下几种类型：</p>
<p>Actor蓝图：Actor蓝图是一种用于创建游戏中的角色、道具、场景等物体的蓝图。Actor蓝图可以包含多个组件和变量，以及用于控制其行为的蓝图逻辑。</p>
<p>Level蓝图：Level蓝图是一种用于创建游戏关卡的蓝图。Level蓝图可以包含多个Actor蓝图和其他组件，以及用于控制关卡流程和事件的蓝图逻辑。</p>
<p>Widget蓝图：Widget蓝图是一种用于创建游戏UI界面的蓝图。Widget蓝图可以包含多个控件和变量，以及用于控制其行为和交互的蓝图逻辑。</p>
<p>Animation蓝图：Animation蓝图是一种用于创建游戏中的动画效果的蓝图。Animation蓝图可以包含多个动画片段和变量，以及用于控制动画播放和交互的蓝图逻辑。</p>
<p>Behavior Tree蓝图：Behavior Tree蓝图是一种用于创建游戏中的AI行为的蓝图。Behavior Tree蓝图可以包含多个行为节点和变量，以及用于控制AI行为的蓝图逻辑。</p>
<p>Blueprint Function Library：Blueprint Function Library是一种用于创建蓝图函数库的蓝图。Blueprint Function Library可以包含多个函数和变量，以供其他蓝图和代码使用。</p>
<p>需要注意的是，以上蓝图类型并不是互相独立的，它们可以相互组合和嵌套，以实现更复杂的游戏逻辑和交互。</p>
<h2 id="添加一个USTRUCT-MyStruct，是否可以？"><a href="#添加一个USTRUCT-MyStruct，是否可以？" class="headerlink" title="添加一个USTRUCT MyStruct，是否可以？"></a>添加一个USTRUCT MyStruct，是否可以？</h2><p>是的，可以在UE4中添加一个USTRUCT MyStruct。USTRUCT是一种用于定义结构体的宏，可以用于在C++代码中声明结构体，并在蓝图中使用。</p>
<p>以下是一个示例代码，演示如何声明一个名为MyStruct的结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UObject/NoExportTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyStruct.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FMyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="string">&quot;MyStruct&quot;</span>)</span><br><span class="line">    int32 MyInt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(BlueprintReadWrite, EditAnywhere, Category = <span class="string">&quot;MyStruct&quot;</span>)</span><br><span class="line">    FString MyString;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用USTRUCT宏声明了一个名为FMyStruct的结构体，并在其中定义了两个成员变量MyInt和MyString。我们还使用了UPROPERTY宏来声明这些成员变量，并指定它们在蓝图中可读写，并且可以在编辑器中进行编辑。</p>
<p>需要注意的是，为了使结构体在蓝图中可用，我们使用了BlueprintType参数来指定该结构体是蓝图类型。此外，我们还使用了GENERATED_BODY宏来生成结构体的默认实现代码。</p>
<p>声明完结构体后，我们可以在蓝图中使用该结构体，例如在Actor蓝图中添加一个MyStruct类型的变量，并在编辑器中设置其成员变量的值。</p>
<h2 id="若要C-中的属性暴露给蓝图，如何操作？"><a href="#若要C-中的属性暴露给蓝图，如何操作？" class="headerlink" title="若要C++中的属性暴露给蓝图，如何操作？"></a>若要C++中的属性暴露给蓝图，如何操作？</h2><p>要将C++中的属性暴露给蓝图，可以使用UE4中的UFUNCTION和UPROPERTY宏。</p>
<p>首先，在C++类中使用UPROPERTY宏来声明要暴露给蓝图的属性，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = <span class="string">&quot;MyCategory&quot;</span>)</span><br><span class="line"><span class="keyword">float</span> MyFloat;</span><br><span class="line"></span><br><span class="line">这将声明一个名为MyFloat的浮点数属性，并将其标记为可在蓝图中编辑和读写。</span><br><span class="line"></span><br><span class="line">接下来，在C++类中使用UFUNCTION宏来声明一个函数，该函数将返回要暴露给蓝图的属性，例如：</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintPure, Category = <span class="string">&quot;MyCategory&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetMyFloat</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> MyFloat; &#125;</span><br></pre></td></tr></table></figure>
<p>这将声明一个名为GetMyFloat的函数，并将其标记为纯蓝图函数，以便在蓝图中调用。该函数将返回MyFloat属性的值。</p>
<p>最后，在蓝图中，可以使用GetMyFloat函数来获取MyFloat属性的值，并且可以使用蓝图编辑器中的Details面板来编辑MyFloat属性的值。</p>
<p>需要注意的是，UPROPERTY和UFUNCTION宏的参数可以根据需要进行调整，以满足具体需求。</p>
<h2 id="在C-中为对象设置默认值有哪些方法？"><a href="#在C-中为对象设置默认值有哪些方法？" class="headerlink" title="在C++中为对象设置默认值有哪些方法？"></a>在C++中为对象设置默认值有哪些方法？</h2><p>在C++中，为对象设置默认值的方法有以下几种：</p>
<ul>
<li>构造函数：可以在对象的构造函数中设置默认值。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="keyword">int</span> value = <span class="number">0</span>) : <span class="built_in">m_value</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line">这将声明一个名为MyClass的类，并将其构造函数设置为接受一个整数参数value，并将m_value成员变量初始化为value的值。如果没有提供参数，则默认值为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">- 成员变量初始化器：可以在类的成员变量初始化器中设置默认值。例如：</span><br><span class="line">``` cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">这将声明一个名为MyClass的类，并将其成员变量m_value初始化为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">- 静态成员变量：可以使用静态成员变量来设置默认值。例如：</span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyClass::s_value = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
这将声明一个名为MyClass的类，并将其静态成员变量s_value初始化为0。</li>
</ul>
<p>需要注意的是，以上方法都可以用于设置默认值，但具体使用哪种方法取决于具体情况。例如，如果需要在对象创建时动态设置默认值，则应该使用构造函数；如果需要在类定义中设置默认值，则应该使用成员变量初始化器；如果需要在整个类中共享默认值，则应该使用静态成员变量。</p>
<h2 id="C-中Reliable的意义是什么，该如何实现对应的操作？"><a href="#C-中Reliable的意义是什么，该如何实现对应的操作？" class="headerlink" title="C++中Reliable的意义是什么，该如何实现对应的操作？"></a>C++中Reliable的意义是什么，该如何实现对应的操作？</h2><p>在UE4中，Reliable是指网络通信中的可靠性，即确保消息能够被正确地发送和接收。在网络游戏中，由于网络延迟和不稳定性等因素，消息可能会丢失或者乱序，因此需要使用Reliable来确保消息的可靠性。</p>
<p>在C++中，可以使用UE4中的RPC（Remote Procedure Call）来实现Reliable的操作。RPC是一种远程过程调用机制，可以在客户端和服务器之间传递消息和调用函数。</p>
<p>要实现Reliable的操作，可以在RPC函数的声明中使用UFUNCTION宏，并将其标记为Reliable，例如：</p>
<p>UFUNCTION(Server, Reliable, WithValidation)<br>void ServerFunction(float Param);<br>这将声明一个名为ServerFunction的RPC函数，并将其标记为可靠的。在客户端调用该函数时，UE4会自动处理网络通信，确保消息能够被正确地发送和接收。</p>
<p>需要注意的是，Reliable的操作会增加网络通信的开销，因此应该尽量减少Reliable的使用，只在必要时才使用。此外，还应该使用WithValidation参数来验证RPC函数的参数，以确保安全性。</p>
<h2 id="如果项目中需要专用服务器，如何操作？"><a href="#如果项目中需要专用服务器，如何操作？" class="headerlink" title="如果项目中需要专用服务器，如何操作？"></a>如果项目中需要专用服务器，如何操作？</h2><p>如果您的项目需要专用服务器，可以使用UE4中的Dedicated Server来实现。Dedicated Server是一种独立的服务器程序，可以在没有图形界面的情况下运行，用于处理游戏逻辑和网络通信等任务。</p>
<p>要创建Dedicated Server，可以按照以下步骤操作：</p>
<p>在UE4编辑器中，选择File -&gt; New Project，然后选择Blank项目模板。</p>
<p>在新项目中，选择Edit -&gt; Project Settings，然后选择Platforms -&gt; Windows。</p>
<p>在Windows选项卡中，将Server Configuration设置为Dedicated Server。</p>
<p>在新项目中，创建一个GameMode和一个GameState，并将它们分别设置为Server Game Mode和Server Game State。</p>
<p>在GameMode中，重写StartPlay函数，并在其中添加启动Dedicated Server的代码，例如：</p>
<p>void AMyGameMode::StartPlay()<br>{<br>    Super::StartPlay();</p>
<pre><code>if (IsRunningDedicatedServer())
&#123;
    // 启动Dedicated Server
    // ...
&#125;
</code></pre>
<p>}<br>在Dedicated Server中，可以使用UE4中的命令行参数来配置服务器，例如：<br>MyGameServer.exe -server -log<br>这将启动一个名为MyGameServer的Dedicated Server，并将其标记为服务器模式，并启用日志记录。</p>
<p>需要注意的是，Dedicated Server需要单独部署和运行，因此需要将其打包为可执行文件，并在服务器上运行。此外，还需要配置防火墙和端口转发等网络设置，以确保客户端能够连接到服务器。</p>
<h2 id="UE4中的Delegates有哪些？"><a href="#UE4中的Delegates有哪些？" class="headerlink" title="UE4中的Delegates有哪些？"></a>UE4中的Delegates有哪些？</h2><p>Multicast Delegate：多播委托，可以将多个回调函数绑定到同一个事件上，当事件触发时，所有绑定的回调函数都会被调用。</p>
<p>Dynamic Delegate：动态委托，可以在运行时动态地绑定和解绑回调函数。</p>
<p>Blueprint Delegate：蓝图委托，可以在蓝图中创建和绑定回调函数。</p>
<p>Event Dispatcher：事件分发器，可以在蓝图中创建和绑定事件，当事件触发时，所有绑定的回调函数都会被调用。</p>
<p>Timer Delegate：定时器委托，可以在一定时间后触发回调函数。</p>
<p>Input Delegate：输入委托，可以在输入事件发生时触发回调函数。</p>
<h2 id="如何分析性能瓶颈在哪儿？"><a href="#如何分析性能瓶颈在哪儿？" class="headerlink" title="如何分析性能瓶颈在哪儿？"></a>如何分析性能瓶颈在哪儿？</h2><p>在UE4中，可以使用以下工具和技术来分析性能瓶颈：</p>
<p>Profiler：UE4自带的Profiler可以帮助您分析游戏的性能瓶颈。您可以使用Profiler来查看CPU和GPU的使用情况，以及函数调用和内存分配等信息。在UE4编辑器中，选择Window -&gt; Developer Tools -&gt; Session Frontend，然后选择Profiler选项卡即可打开Profiler。</p>
<p>日志：UE4中的日志系统可以帮助您记录游戏中的事件和信息。您可以使用日志来记录函数调用、变量值、时间戳等信息，以便分析性能瓶颈。在C++中，可以使用UE_LOG宏来记录日志信息。</p>
<p>统计信息：UE4中的统计信息可以帮助您了解游戏的运行情况。您可以使用统计信息来查看帧率、内存使用情况、网络延迟等信息。在UE4编辑器中，选择Window -&gt; Developer Tools -&gt; Statistics即可打开统计信息。</p>
<p>第三方工具：除了UE4自带的工具外，还可以使用第三方工具来分析性能瓶颈。例如，可以使用Visual Studio的性能分析器来分析CPU的使用情况，使用NVIDIA Nsight来分析GPU的使用情况，使用Wireshark来分析网络通信等。</p>
<p>在分析性能瓶颈时，需要注意以下几点：</p>
<p>确定性能指标：在分析性能瓶颈之前，需要确定要分析的性能指标，例如帧率、CPU使用率、内存使用量等。</p>
<p>重现问题：在分析性能瓶颈之前，需要能够重现性能问题。如果无法重现问题，则很难分析性能瓶颈。</p>
<p>分析数据：在分析性能瓶颈时，需要仔细分析收集到的数据，例如Profiler输出、日志信息、统计信息等。</p>
<p>优化代码：在分析性能瓶颈之后，需要根据分析结果来优化代码。优化代码的方法有很多种，例如减少函数调用、使用更高效的算法、减少内存分配等。</p>
<h2 id="UE4的碰撞类型有哪些？"><a href="#UE4的碰撞类型有哪些？" class="headerlink" title="UE4的碰撞类型有哪些？"></a>UE4的碰撞类型有哪些？</h2><ul>
<li><p>无碰撞（No Collision）：该对象不会与其他对象发生碰撞。</p>
</li>
<li><p>碰撞（Collision）：该对象会与其他对象发生碰撞，但不会产生物理效果。</p>
</li>
<li><p>触发器（Trigger）：该对象会与其他对象发生碰撞，并且可以触发事件或脚本。</p>
</li>
<li><p>物理（Physics）：该对象会与其他对象发生碰撞，并且会产生物理效果，例如重力、惯性等。</p>
</li>
<li><p>隐藏（Overlap）：该对象会与其他对象发生碰撞，但不会产生物理效果，只会检测是否重叠。</p>
</li>
<li><p>阻挡（Block）：该对象会与其他对象发生碰撞，并且会阻挡其他对象的移动。</p>
</li>
</ul>
<h2 id="UE4的服务器是否适应于MMO？若不适应，有什么解决方案？"><a href="#UE4的服务器是否适应于MMO？若不适应，有什么解决方案？" class="headerlink" title="UE4的服务器是否适应于MMO？若不适应，有什么解决方案？"></a>UE4的服务器是否适应于MMO？若不适应，有什么解决方案？</h2><p>UE4的服务器可以用于开发MMO游戏，但需要根据游戏的具体需求和设计进行调整和优化。以下是一些可能需要考虑的问题和解决方案：</p>
<p>网络延迟<br>在MMO游戏中，网络延迟是一个非常重要的问题，可能会影响游戏的流畅度和体验。为了解决这个问题，可以采用以下方案：</p>
<p>使用预测和插值技术来减少网络延迟对游戏的影响。<br>使用分布式服务器架构来减少单个服务器的负载和网络延迟。<br>使用专门的网络优化工具来优化网络性能，例如使用CDN、加速器等。<br>服务器负载<br>在MMO游戏中，服务器负载是一个非常重要的问题，可能会影响游戏的性能和稳定性。为了解决这个问题，可以采用以下方案：</p>
<p>使用分布式服务器架构来分担服务器负载。<br>使用负载均衡技术来平衡服务器负载。<br>优化服务器代码和算法，减少服务器的计算和存储负载。<br>数据同步<br>在MMO游戏中，数据同步是一个非常重要的问题，需要确保所有玩家的数据都能够同步和更新。为了解决这个问题，可以采用以下方案：</p>
<p>使用可靠的数据同步协议来确保数据的同步和更新。<br>使用分布式数据库来存储和管理游戏数据。<br>使用数据压缩和优化技术来减少数据传输的带宽和延迟。<br>需要注意的是，以上方案只是一些可能的解决方案，具体使用哪些方案取决于游戏的具体需求和设计。在开发MMO游戏时，需要综合考虑游戏的性能、稳定性、流畅度和体验等方面的问题，进行合理的调整和优化。</p>
<h2 id="动画蓝图是否支持同步？若不支持，有什么解决方案？"><a href="#动画蓝图是否支持同步？若不支持，有什么解决方案？" class="headerlink" title="动画蓝图是否支持同步？若不支持，有什么解决方案？"></a>动画蓝图是否支持同步？若不支持，有什么解决方案？</h2><p>在UE4中，动画蓝图默认是不支持同步的，因为动画蓝图是在客户端上运行的，而客户端的运行速度和帧率可能会受到多种因素的影响，导致动画播放的速度和时间不同步。</p>
<p>为了解决这个问题，可以采用以下方案：</p>
<ul>
<li><p>使用同步点<br>可以在动画蓝图中添加同步点，用于同步动画的播放时间。同步点可以在动画的关键帧上添加，例如动画的起始帧、结束帧等。在同步点处，可以通过调用Multicast或Server函数来同步动画的播放时间。</p>
</li>
<li><p>使用时间戳<br>可以在动画蓝图中添加时间戳，用于同步动画的播放时间。时间戳可以在动画的关键帧上添加，例如动画的起始帧、结束帧等。在时间戳处，可以通过调用Multicast或Server函数来同步动画的播放时间。</p>
</li>
<li><p>使用插值<br>可以在动画蓝图中使用插值技术，来平滑地同步动画的播放时间。可以使用线性插值、样条插值等技术，来计算动画的播放时间。在插值计算中，可以考虑客户端和服务器之间的网络延迟和帧率等因素，来确保动画的同步性。</p>
</li>
</ul>
<h2 id="材质参数、特效参数、声音参数如何使用？"><a href="#材质参数、特效参数、声音参数如何使用？" class="headerlink" title="材质参数、特效参数、声音参数如何使用？"></a>材质参数、特效参数、声音参数如何使用？</h2><p>在UE4中，材质参数、特效参数和声音参数都是用于控制游戏中的材质、特效和声音的参数。以下是这些参数的使用方法：</p>
<p>材质参数<br>材质参数是用于控制材质的参数，可以在材质编辑器中创建和编辑。可以通过材质参数来控制材质的颜色、纹理、透明度等属性。在游戏中，可以通过蓝图或代码来修改材质参数，从而实现动态的材质效果。</p>
<p>特效参数<br>特效参数是用于控制特效的参数，可以在特效编辑器中创建和编辑。可以通过特效参数来控制特效的大小、速度、颜色等属性。在游戏中，可以通过蓝图或代码来修改特效参数，从而实现动态的特效效果。</p>
<p>声音参数<br>声音参数是用于控制声音的参数，可以在声音编辑器中创建和编辑。可以通过声音参数来控制声音的音量、音调、回声等属性。在游戏中，可以通过蓝图或代码来修改声音参数，从而实现动态的声音效果。</p>
<h2 id="若要对打包之后的版本进行跟踪和调试，如何操作？"><a href="#若要对打包之后的版本进行跟踪和调试，如何操作？" class="headerlink" title="若要对打包之后的版本进行跟踪和调试，如何操作？"></a>若要对打包之后的版本进行跟踪和调试，如何操作？</h2><p>在UE4中，可以通过以下步骤对打包之后的版本进行跟踪和调试：</p>
<p>生成符号文件<br>在打包游戏时，需要勾选“生成符号文件”选项，以便生成符号文件。符号文件包含了游戏代码的调试信息，可以用于在调试器中跟踪和调试游戏代码。</p>
<p>使用调试器<br>可以使用Visual Studio等调试器来跟踪和调试打包之后的游戏版本。需要将符号文件和游戏可执行文件一起加载到调试器中，然后设置断点、监视变量等，以便跟踪和调试游戏代码。</p>
<p>输出日志信息<br>可以在游戏代码中添加日志输出语句，以便在游戏运行时输出调试信息。可以使用UE_LOG宏来输出日志信息，例如：</p>
<p>cpp<br>复制<br>UE_LOG(LogTemp, Warning, TEXT(“Debug message”));<br>在游戏运行时，可以在输出日志窗口中查看日志信息，以便跟踪和调试游戏代码。</p>
<p>需要注意的是，对打包之后的版本进行跟踪和调试可能会影响游戏的性能和稳定性，因此应该尽量避免在正式发布的游戏版本中进行调试。建议在开发和测试阶段进行调试，以便及时发现和解决问题。</p>
<h2 id="C-中如何对组件或者Actor设置同步？"><a href="#C-中如何对组件或者Actor设置同步？" class="headerlink" title="C++中如何对组件或者Actor设置同步？"></a>C++中如何对组件或者Actor设置同步？</h2><p>在UE4中，可以通过以下步骤对组件或Actor进行同步：</p>
<ul>
<li><p>继承自Actor或Component<br>需要对Actor或Component进行同步，需要先继承自AActor或UActorComponent类。在继承类中，可以添加需要同步的属性和函数。</p>
</li>
<li><p>添加同步属性<br>在继承类中，可以添加需要同步的属性，例如位置、旋转、缩放等。需要使用UPROPERTY宏来声明同步属性，例如：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)</span><br><span class="line">FVector Location;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，Location属性被声明为同步属性，并使用Replicated标记来指示需要进行同步。</p>
<ul>
<li>添加同步函数<br>在继承类中，可以添加需要同步的函数，例如移动、旋转、缩放等。需要使用RPC宏来声明同步函数，例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(Server, Reliable)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerMoveToLocation</span><span class="params">(FVector NewLocation)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，ServerMoveToLocation函数被声明为同步函数，并使用Server标记来指示需要在服务器上执行。</p>
<ul>
<li>实现同步函数<br>在继承类中，需要实现同步函数的具体逻辑。在同步函数中，可以使用RPC调用来同步属性和执行函数，例如：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyActor::ServerMoveToLocation_Implementation</span><span class="params">(FVector NewLocation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Location = NewLocation;</span><br><span class="line">    <span class="built_in">SetActorLocation</span>(Location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，ServerMoveToLocation函数被实现为设置Location属性和Actor位置的函数。</p>
<h2 id="四元数相对于欧拉角的优点"><a href="#四元数相对于欧拉角的优点" class="headerlink" title="四元数相对于欧拉角的优点"></a>四元数相对于欧拉角的优点</h2><p>无万向锁问题：欧拉角存在万向锁问题，即在某些情况下，旋转会失去一个自由度。而四元数没有这个问题，因为它们使用四个值来表示旋转，而不是三个值。</p>
<p>插值更容易：使用四元数进行插值更容易，因为它们是连续的，而欧拉角则不是。在欧拉角中，插值可能会导致旋转路径不连续，而四元数则可以保证旋转路径连续。</p>
<p>更快的计算：四元数的计算速度比欧拉角更快，因为它们使用四个值来表示旋转，而不是三个值。此外，四元数的乘法比欧拉角的旋转矩阵乘法更快。</p>
<p>更少的存储空间：四元数只需要四个浮点数来表示旋转，而欧拉角需要三个浮点数。因此，使用四元数可以节省存储空间。</p>
<p>总之，四元数相对于欧拉角具有更好的数学性质和更好的性能，因此在需要进行旋转计算的情况下，使用四元数可能更好。</p>
<h2 id="UE4中需要对一个原本不支持寻路的Actor实现寻路功能，如何实现？"><a href="#UE4中需要对一个原本不支持寻路的Actor实现寻路功能，如何实现？" class="headerlink" title="UE4中需要对一个原本不支持寻路的Actor实现寻路功能，如何实现？"></a>UE4中需要对一个原本不支持寻路的Actor实现寻路功能，如何实现？</h2><p>如果您需要对一个原本不支持寻路的Actor实现寻路功能，可以使用UE4的Navigation System来实现。以下是一些可能的方法：</p>
<p>将Actor添加到Navigation System：将Actor添加到Navigation System中，使其成为可寻路的对象。要将Actor添加到Navigation System中，您需要将其设置为NavMeshBoundsVolume的子级，并将NavMeshBoundsVolume添加到Navigation System中。</p>
<p>使用NavModifierVolume：如果您只需要在Actor的某些区域内进行寻路，可以使用NavModifierVolume来修改NavMesh。NavModifierVolume可以添加、删除或修改NavMesh上的区域，以便在这些区域内进行寻路。</p>
<p>自定义寻路：如果您需要更精细的控制，可以编写自定义寻路逻辑。您可以使用UE4的AIController类来控制Actor的移动，并使用UE4的Navigation System API来进行寻路。您可以编写自己的寻路算法，并使用Navigation System API来查询NavMesh和路径。</p>
<h2 id="UI中的锚是用来干什么的？"><a href="#UI中的锚是用来干什么的？" class="headerlink" title="UI中的锚是用来干什么的？"></a>UI中的锚是用来干什么的？</h2><p>UI中的锚是用来确定UI元素在屏幕上的位置和大小的。锚点是UI元素的一个属性，它指定了UI元素相对于其父级容器的位置和大小。锚点通常是一个矩形，它定义了UI元素的左上角和右下角的位置。</p>
<p>使用锚点可以使UI元素在不同分辨率和屏幕尺寸的设备上保持一致的位置和大小。例如，如果您将一个按钮的锚点设置为左上角，那么无论屏幕的大小和分辨率如何，该按钮始终位于屏幕的左上角。</p>
<p>锚点通常与UI布局系统一起使用，例如UE4中的UMG系统。在UMG中，您可以使用锚点来定义UI元素的位置和大小，并使用布局系统来自动调整UI元素的位置和大小，以适应不同的屏幕尺寸和分辨率。</p>
<p>总之，锚点是UI设计中非常重要的概念，它可以使UI元素在不同的设备上保持一致的位置和大小</p>
<h2 id="如何基于UE4的网络接口，实现一个网络层，如Steam？"><a href="#如何基于UE4的网络接口，实现一个网络层，如Steam？" class="headerlink" title="如何基于UE4的网络接口，实现一个网络层，如Steam？"></a>如何基于UE4的网络接口，实现一个网络层，如Steam？</h2><p>确定网络协议：首先，您需要确定要使用的网络协议。Steam使用的是自己的网络协议，但您也可以使用其他协议，如TCP或UDP。</p>
<p>实现网络连接：使用UE4的Socket API或OnlineSubsystem模块，您可以实现网络连接。您需要编写代码来处理连接、断开连接、发送和接收数据等操作。</p>
<p>实现数据传输：一旦建立了网络连接，您需要实现数据传输。您可以使用UE4的Socket API或OnlineSubsystem模块来发送和接收数据。您需要编写代码来处理数据的序列化和反序列化，以及处理数据的可靠性和完整性。</p>
<p>实现网络同步：如果您的游戏需要进行网络同步，您需要编写代码来处理同步。您可以使用UE4的Replication System来处理同步，或者编写自己的同步逻辑。</p>
<p>实现网络安全：如果您的游戏需要进行网络安全，您需要编写代码来处理安全。您可以使用UE4的Encryption API来处理加密和解密，或者编写自己的加密逻辑。</p>
<h2 id="对于打包之后的游戏资源，有什么加密方案？"><a href="#对于打包之后的游戏资源，有什么加密方案？" class="headerlink" title="对于打包之后的游戏资源，有什么加密方案？"></a>对于打包之后的游戏资源，有什么加密方案？</h2><p>对于打包之后的游戏资源，有许多加密方案可供选择。以下是一些可能的方案：</p>
<p>加密游戏资源文件：您可以使用加密算法对游戏资源文件进行加密，以防止未经授权的访问。加密算法可以是对称加密算法，如AES，也可以是非对称加密算法，如RSA。</p>
<p>压缩游戏资源文件：您可以使用压缩算法对游戏资源文件进行压缩，以减小文件大小并提高下载速度。压缩算法可以是无损压缩算法，如LZ77，也可以是有损压缩算法，如JPEG。</p>
<p>使用数字签名：您可以使用数字签名来验证游戏资源文件的完整性和真实性。数字签名可以使用公钥加密算法，如RSA，来生成数字签名，并使用私钥解密算法来验证数字签名。</p>
<p>使用加密容器：您可以使用加密容器来存储游戏资源文件。加密容器可以是ZIP文件，也可以是RAR文件。加密容器可以使用加密算法来保护文件内容，并使用密码来解密文件内容。</p>
<p>请注意，加密游戏资源文件可能会影响游戏性能和加载时间。因此，您需要权衡安全性和性能之间的平衡。此外，加密游戏资源文件可能会增加开发和维护成本，因为您需要编写代码来处理加密和解密。</p>
<h2 id="在Actor中增加了输入事件，但是输入事件却无法触发，其原因可能有哪些？"><a href="#在Actor中增加了输入事件，但是输入事件却无法触发，其原因可能有哪些？" class="headerlink" title="在Actor中增加了输入事件，但是输入事件却无法触发，其原因可能有哪些？"></a>在Actor中增加了输入事件，但是输入事件却无法触发，其原因可能有哪些？</h2><p>Actor没有设置Input Component：如果Actor没有设置Input Component，那么它将无法接收输入事件。您需要将Input Component添加到Actor中，并将其绑定到输入事件。</p>
<p>输入事件被其他Actor或UI元素捕获：如果有其他Actor或UI元素在输入事件发生时捕获了该事件，那么该事件将不会传递到您的Actor中。您需要检查其他Actor或UI元素是否捕获了该事件，并根据需要进行调整。</p>
<p>输入事件被禁用：如果输入事件被禁用，那么它将无法触发。您需要检查Actor的输入设置，确保输入事件没有被禁用。</p>
<p>输入事件绑定错误：如果输入事件没有正确绑定到Actor的Input Component上，那么它将无法触发。您需要检查输入事件的绑定，确保它已正确绑定到Input Component上。</p>
<p>输入事件被屏蔽：如果输入事件被屏蔽，那么它将无法触发。您需要检查Actor的碰撞设置，确保输入事件没有被屏蔽。</p>
<h2 id="SpawnActor的位置不对，为什么？"><a href="#SpawnActor的位置不对，为什么？" class="headerlink" title="SpawnActor的位置不对，为什么？"></a>SpawnActor的位置不对，为什么？</h2><h2 id="在BeginPlay之后调用了某个RPC操作，客户端却没有执行到，可能原因是什么？"><a href="#在BeginPlay之后调用了某个RPC操作，客户端却没有执行到，可能原因是什么？" class="headerlink" title="在BeginPlay之后调用了某个RPC操作，客户端却没有执行到，可能原因是什么？"></a>在BeginPlay之后调用了某个RPC操作，客户端却没有执行到，可能原因是什么？</h2><p>1、客户端还没初始化完成，调用RPC的Actor还没被同步到客户端</p>
<p>2、使用了放入队列的不可靠RPC操作，即在属性同步的时候调用RPC，这种情况会在先进行属性修改再调用RPC的时候出现客户端不执行的情况。</p>
<p>（立即发送：如果是可靠的 RPC，会立即调用函数 SendBunch。可能立即发送出去，可能放入缓存 SendBuffer 中。</p>
<p>放入队列：如果是不可靠的 RPC，会暂时放入 RPC 缓冲区中，当调用函数 ReplicateProperties 去复制属性的时候，如果 RPC 缓冲区中有数据，会加入到 Bunch 结尾。<br>不可靠的 RPC 函数是随着属性的复制一起复制过去的，先解析属性，再调用函数。）</p>
<h2 id="在客户端没有连接到服务器之前，有什么同服务器进行通信的方案吗？"><a href="#在客户端没有连接到服务器之前，有什么同服务器进行通信的方案吗？" class="headerlink" title="在客户端没有连接到服务器之前，有什么同服务器进行通信的方案吗？"></a>在客户端没有连接到服务器之前，有什么同服务器进行通信的方案吗？</h2><ul>
<li><p>使用UE4的OnlineSubsystem模块：UE4的OnlineSubsystem模块提供了一种在客户端和服务器之间进行通信的标准化方法。您可以使用OnlineSubsystem模块来查找服务器、连接到服务器并与服务器进行通信。这种方法需要在客户端和服务器上都使用UE4，并且需要在项目设置中配置OnlineSubsystem模块。</p>
</li>
<li><p>使用Socket：您可以使用UE4的Socket API来与服务器进行通信。这种方法需要您编写自己的网络代码，并且需要在客户端和服务器上都使用Socket API。</p>
</li>
<li><p>使用第三方库：您可以使用第三方库，如Boost.Asio或libcurl，来与服务器进行通信。这种方法需要您编写自己的网络代码，并且需要在客户端和服务器上都使用第三方库。</p>
</li>
</ul>
<h2 id="如何在Actor中增加command命令？"><a href="#如何在Actor中增加command命令？" class="headerlink" title="如何在Actor中增加command命令？"></a>如何在Actor中增加command命令？</h2><p>在UE4中，可以通过重载AActor类的Exec函数来增加Actor的命令。Exec函数用于处理Actor接收到的命令，可以在其中添加自定义的命令处理逻辑。</p>
<p>以下是在Actor中增加命令的步骤：</p>
<p>在Actor的头文件中声明要添加的命令，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">MyCommand</span><span class="params">(FString&amp; Args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在Actor的源文件中实现命令处理逻辑，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AMyActor::MyCommand</span><span class="params">(FString&amp; Args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理命令逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Exec函数中添加命令处理逻辑，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AMyActor::Exec</span><span class="params">(UWorld* InWorld, <span class="keyword">const</span> TCHAR* Cmd, FOutputDevice&amp; Ar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FParse::<span class="built_in">Command</span>(&amp;Cmd, <span class="built_in">TEXT</span>(<span class="string">&quot;MyCommand&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        FString Args;</span><br><span class="line">        FParse::<span class="built_in">Token</span>(Cmd, Args, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MyCommand</span>(Args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Super::<span class="built_in">Exec</span>(InWorld, Cmd, Ar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，Exec函数首先判断接收到的命令是否为MyCommand，如果是，则解析命令参数并调用MyCommand函数处理命令。如果不是，则调用父类的Exec函数处理命令。</p>
<p>需要注意的是，以上代码只是演示如何在Actor中增加命令，具体实现还需要根据游戏的具体需求和设计进行调整。</p>
<h2 id="命令行中ce和ke有什么作用？"><a href="#命令行中ce和ke有什么作用？" class="headerlink" title="命令行中ce和ke有什么作用？"></a>命令行中ce和ke有什么作用？</h2><ol>
<li>关卡蓝图</li>
</ol>
<p>命令：ce +方法名 + 参数</p>
<p>说明：执行当前运行关卡蓝图中的方法。方法名不区分大小写，参数个数、格式根据蓝图自定义事件输入设计决定。</p>
<p>例如：ce test1 100</p>
<ol start="2">
<li>任意蓝图</li>
</ol>
<p>命令：ke + */蓝图类名 + 方法名 + 参数</p>
<p>说明：蓝图类名在蓝图名后加 _C，执行指定蓝图的该方法，或者 * 执行所有蓝图的指定方法</p>
<p>例如：ke BP_PrintString_C test1 100</p>
<h2 id="UE4中的智能指针有哪些？"><a href="#UE4中的智能指针有哪些？" class="headerlink" title="UE4中的智能指针有哪些？"></a>UE4中的智能指针有哪些？</h2><p>在UE4中，智能指针是一种用于管理对象生命周期的指针。智能指针可以自动管理对象的引用计数，并在对象不再需要时自动释放内存。UE4中的智能指针有以下几种：</p>
<p>TSharedPtr：TSharedPtr是一种共享指针，它可以在多个对象之间共享所有权。TSharedPtr使用引用计数来管理对象的生命周期，当引用计数为0时，对象将被自动释放。</p>
<p>TWeakPtr：TWeakPtr是一种弱指针，它可以引用TSharedPtr所管理的对象，但不会增加对象的引用计数。TWeakPtr通常用于避免循环引用。</p>
<p>TUniquePtr：TUniquePtr是一种独占指针，它拥有对象的唯一所有权。TUniquePtr使用移动语义来管理对象的生命周期，当TUniquePtr被销毁时，对象将被自动释放。</p>
<p>TAutoPtr：TAutoPtr是一种自动指针，它类似于TUniquePtr，但不支持移动语义。TAutoPtr通常用于管理栈上的对象。</p>
<p>TWeakObjectPtr：TWeakObjectPtr是一种弱指针，它可以引用UObject的子类对象，但不会增加对象的引用计数。TWeakObjectPtr通常用于避免循环引用。</p>
<p>总之，UE4中的智能指针可以帮助开发人员更好地管理对象的生命周期，并避免内存泄漏和悬空指针等问题。</p>
<h2 id="对根组件设置Scale会有问题吗？"><a href="#对根组件设置Scale会有问题吗？" class="headerlink" title="对根组件设置Scale会有问题吗？"></a>对根组件设置Scale会有问题吗？</h2><p>在UE4中，对根组件设置Scale可能会导致一些问题。这是因为根组件的缩放会影响其所有子组件的缩放，这可能会导致一些不可预测的行为。</p>
<p>例如，如果您将根组件的缩放设置为2，那么所有子组件的缩放也将变为2。这可能会导致一些问题，例如碰撞体积的大小不正确，或者在进行物理模拟时出现不正确的行为。</p>
<p>因此，建议在UE4中不要对根组件设置缩放。相反，您可以使用其他组件来实现所需的缩放效果。例如，您可以使用Scene Component或Static Mesh Component来实现缩放效果，而不会影响根组件或其他子组件。</p>
<p>总之，尽管在UE4中可以对根组件设置缩放，但这可能会导致一些问题。</p>
<h2 id="如何在UE4中使用静态库或者动态库？"><a href="#如何在UE4中使用静态库或者动态库？" class="headerlink" title="如何在UE4中使用静态库或者动态库？"></a>如何在UE4中使用静态库或者动态库？</h2><p>将库文件添加到UE4项目中：将库文件添加到UE4项目中，可以通过将库文件复制到项目目录下的“ThirdParty”文件夹中，或者将库文件添加到项目的构建脚本中。</p>
<p>配置UE4项目的构建脚本：在UE4项目的构建脚本中，需要添加库文件的路径和名称，以便编译器可以找到并链接库文件。这可以通过修改项目的Build.cs文件来实现。</p>
<p>在UE4项目中使用库文件：在UE4项目中使用库文件，需要包含库文件的头文件，并在代码中调用库文件的函数。如果使用的是动态库，还需要将库文件复制到项目的运行时目录中，以便在运行时加载库文件。</p>
<h2 id="试分析GameMode的运行流程，如从InitGame至Logout。"><a href="#试分析GameMode的运行流程，如从InitGame至Logout。" class="headerlink" title="试分析GameMode的运行流程，如从InitGame至Logout。"></a>试分析GameMode的运行流程，如从InitGame至Logout。</h2><p>GameMode是UE4中用于管理游戏逻辑的类，它负责处理游戏的初始化、玩家加入、玩家离开等事件。下面是GameMode的运行流程，从InitGame至Logout：</p>
<p>InitGame：当游戏开始时，UE4会调用GameMode的InitGame函数。在这个函数中，GameMode可以执行一些初始化操作，例如创建游戏世界、生成游戏对象等。</p>
<p>PostLogin：当玩家加入游戏时，UE4会调用GameMode的PostLogin函数。在这个函数中，GameMode可以处理玩家加入的逻辑，例如创建玩家角色、设置玩家属性等。</p>
<p>BeginPlay：当游戏开始时，UE4会调用GameMode的BeginPlay函数。在这个函数中，GameMode可以执行一些游戏开始时的逻辑，例如播放开场动画、显示游戏UI等。</p>
<p>Tick：在游戏运行期间，UE4会每帧调用GameMode的Tick函数。在这个函数中，GameMode可以处理游戏逻辑，例如检测玩家输入、更新游戏状态等。</p>
<p>Logout：当玩家离开游戏时，UE4会调用GameMode的Logout函数。在这个函数中，GameMode可以处理玩家离开的逻辑，例如销毁玩家角色、保存玩家数据等。</p>
<h2 id="UE4的自动化测试如何搞？"><a href="#UE4的自动化测试如何搞？" class="headerlink" title="UE4的自动化测试如何搞？"></a>UE4的自动化测试如何搞？</h2><p>UE4提供了一套自动化测试框架，可以帮助开发人员自动化测试游戏的各个方面，包括游戏逻辑、UI、性能等。下面是UE4自动化测试的搭建步骤：</p>
<p>创建测试项目：在UE4中创建一个新的项目，选择“Blank”模板，并勾选“With Editor Tests”选项。这将创建一个包含测试框架的项目。</p>
<p>创建测试用例：在UE4中创建一个新的测试用例，可以使用UE4自带的测试框架，也可以使用第三方测试框架，例如Google Test。在测试用例中编写测试代码，测试游戏的各个方面。</p>
<p>运行测试用例：在UE4中运行测试用例，可以使用UE4自带的测试运行器，也可以使用第三方测试运行器，例如Jenkins。测试运行器将自动运行测试用例，并生成测试报告。</p>
<p>分析测试报告：在测试运行完成后，可以分析测试报告，查看测试结果和测试覆盖率等信息。如果测试失败，可以根据测试报告中的错误信息进行调试和修复。</p>
<h2 id="多个摄像机之间如何切换？"><a href="#多个摄像机之间如何切换？" class="headerlink" title="多个摄像机之间如何切换？"></a>多个摄像机之间如何切换？</h2><p>使用Camera Switcher：UE4提供了一个Camera Switcher组件，可以用于在多个摄像机之间切换。将Camera Switcher组件添加到场景中，然后将多个摄像机添加到Camera Switcher组件中。在需要切换摄像机时，可以通过蓝图或代码调用Camera Switcher组件的函数来切换摄像机。</p>
<p>使用Level Sequence：UE4中的Level Sequence可以用于创建场景中的动画序列。可以在Level Sequence中添加多个摄像机，并设置它们的位置、旋转和时间等属性。在需要切换摄像机时，可以通过蓝图或代码调用Level Sequence的函数来切换摄像机。</p>
<h2 id="更新UI的方式有哪些？"><a href="#更新UI的方式有哪些？" class="headerlink" title="更新UI的方式有哪些？"></a>更新UI的方式有哪些？</h2><p>使用UMG Widget：UE4提供了一个UMG（Unreal Motion Graphics）系统，可以用于创建UI界面。可以在UMG Widget中添加各种UI元素，例如文本、按钮、图像等，并通过蓝图或代码来更新UI元素的属性，例如文本内容、按钮状态、图像显示等。</p>
<p>使用Slate Widget：UE4中的Slate Widget是一种基于C++的UI框架，可以用于创建高度自定义的UI界面。可以通过代码来创建Slate Widget，并通过代码来更新UI元素的属性，例如文本内容、按钮状态、图像显示等。</p>
<p>使用HUD（Head-Up Display）：UE4中的HUD可以用于在游戏中显示2D元素，例如血条、计分板等。可以通过蓝图或代码来更新HUD中的UI元素，例如文本内容、图像显示等。</p>
<h2 id="如何区分并调节不同的音效？"><a href="#如何区分并调节不同的音效？" class="headerlink" title="如何区分并调节不同的音效？"></a>如何区分并调节不同的音效？</h2><p>使用Sound Cue：UE4中的Sound Cue可以用于创建音效，可以在Sound Cue中添加多个音轨，并为每个音轨设置不同的音效。可以通过蓝图或代码来播放Sound Cue，并通过蓝图或代码来调节每个音轨的音量、音调等属性。</p>
<p>使用Audio Component：UE4中的Audio Component可以用于播放音效，可以通过蓝图或代码来创建Audio Component，并为每个Audio Component设置不同的音效。可以通过蓝图或代码来调节每个Audio Component的音量、音调等属性。</p>
<p>使用Sound Mix：UE4中的Sound Mix可以用于调节多个音效的音量、音调等属性。可以在Sound Mix中添加多个Sound Cue或Audio Component，并为每个Sound Cue或Audio Component设置不同的音量、音调等属性。可以通过蓝图或代码来播放Sound Mix，并通过蓝图或代码来调节每个Sound Cue或Audio Component的音量、音调等属性。</p>
<h2 id="如何销毁AIController？"><a href="#如何销毁AIController？" class="headerlink" title="如何销毁AIController？"></a>如何销毁AIController？</h2><p>在C++中，可以调用AIController的Destroy()函数来销毁AIController。<br>在蓝图中，可以使用Destroy Actor节点来销毁AIController。</p>
<h2 id="在C-和蓝图中如何打印调试信息？"><a href="#在C-和蓝图中如何打印调试信息？" class="headerlink" title="在C++和蓝图中如何打印调试信息？"></a>在C++和蓝图中如何打印调试信息？</h2><p>在C++中，可以使用UE_LOG宏来打印调试信息。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;Debug message&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>在蓝图中，可以使用Print String节点来打印调试信息。将要打印的信息作为Print String节点的输入即可。</p>
<h2 id="轴输入事件在值为0的时候会触发吗？"><a href="#轴输入事件在值为0的时候会触发吗？" class="headerlink" title="轴输入事件在值为0的时候会触发吗？"></a>轴输入事件在值为0的时候会触发吗？</h2><p>在UE4中，轴输入事件在值为0的时候不会触发。轴输入事件只会在轴的值发生变化时触发，例如从正向移动到反向移动。如果需要在轴的值为0时触发事件，可以使用按键输入事件来实现。</p>
<h2 id="3DWidget如何使用？"><a href="#3DWidget如何使用？" class="headerlink" title="3DWidget如何使用？"></a>3DWidget如何使用？</h2><p>创建一个Widget Blueprint，并在其中添加需要显示的UI元素。<br>将Widget Blueprint拖拽到场景中，创建一个3DWidget Component。<br>将3DWidget Component添加到需要显示UI的Actor中。<br>在需要显示UI的Actor的蓝图中，通过调用3DWidget Component的函数来更新UI元素的属性。</p>
<h2 id="游戏中的AI技术有哪些？"><a href="#游戏中的AI技术有哪些？" class="headerlink" title="游戏中的AI技术有哪些？"></a>游戏中的AI技术有哪些？</h2><p>在游戏中，常用的AI技术包括以下几种：</p>
<p>行为树（Behavior Tree）：用于描述AI角色的行为和决策过程。<br>人工神经网络（Artificial Neural Network）：用于训练AI角色的智能水平。<br>路径规划（Pathfinding）：用于计算AI角色的移动路径。<br>状态机（State Machine）：用于描述AI角色的状态和状态转换过程。<br>感知系统（Perception System）：用于感知AI角色周围的环境和其他角色。</p>
<h2 id="导航网格和寻路组件各有什么作用？"><a href="#导航网格和寻路组件各有什么作用？" class="headerlink" title="导航网格和寻路组件各有什么作用？"></a>导航网格和寻路组件各有什么作用？</h2><p>导航网格（Navigation Mesh）：用于描述场景中的可行走区域和障碍物。导航网格可以通过NavMesh Bounds Volume Actor来创建。<br>寻路组件（Pathfinding Component）：用于计算AI角色的移动路径。寻路组件可以通过AI Controller的Pathfinding Component属性来设置。</p>
<h2 id="对于编译整个引擎耗费的大量时间，有什么解决方案？"><a href="#对于编译整个引擎耗费的大量时间，有什么解决方案？" class="headerlink" title="对于编译整个引擎耗费的大量时间，有什么解决方案？"></a>对于编译整个引擎耗费的大量时间，有什么解决方案？</h2><p>只编译需要的模块：可以通过修改引擎的BuildConfiguration.xml文件来指定需要编译的模块。<br>使用预编译头文件（PCH）：可以将常用的头文件打包成PCH文件，加快编译速度。<br>使用分布式编译工具：可以使用像IncrediBuild这样的分布式编译工具，将编译任务分配给多台计算机，加快编译速度。</p>
<h2 id="如何联机构建光照？"><a href="#如何联机构建光照？" class="headerlink" title="如何联机构建光照？"></a>如何联机构建光照？</h2><p>在主机上打开场景，并构建光照。<br>在客户端上打开场景，并将场景中的所有Actor的Replicates属性设置为true。<br>在客户端上运行游戏，并连接到主机。<br>在客户端上，通过调用ServerTravel函数来切换到主机的场景。<br>在客户端上，等待场景加载完成后，可以看到主机上构建的光照效果。</p>
<h2 id="Montage是什么？"><a href="#Montage是什么？" class="headerlink" title="Montage是什么？"></a>Montage是什么？</h2><p>在UE4中，Montage是一种用于管理动画序列的机制。Montage可以将多个动画片段组合成一个整体，并通过蓝图或代码来控制动画的播放和停止。Montage还可以设置动画片段之间的过渡效果，例如淡入淡出、融合等。</p>
<h2 id="执行动画时，将动画和声音、特效匹配的较好的方案是什么？"><a href="#执行动画时，将动画和声音、特效匹配的较好的方案是什么？" class="headerlink" title="执行动画时，将动画和声音、特效匹配的较好的方案是什么？"></a>执行动画时，将动画和声音、特效匹配的较好的方案是什么？</h2><p>在UE4中，可以使用Animation Notify来实现将动画和声音、特效匹配的效果。Animation Notify是一种在动画播放过程中触发事件的机制，可以在动画的特定时间点触发声音、特效等效果。可以在动画的蓝图中添加Animation Notify，并通过蓝图或代码来控制触发事件。</p>
<h2 id="如何获取动画的执行事件？"><a href="#如何获取动画的执行事件？" class="headerlink" title="如何获取动画的执行事件？"></a>如何获取动画的执行事件？</h2><p>在UE4中，可以使用Animation Notify来获取动画的执行事件。Animation Notify是一种在动画播放过程中触发事件的机制，可以在动画的特定时间点触发事件。可以在动画的蓝图中添加Animation Notify，并通过蓝图或代码来控制触发事件。</p>
<h2 id="Service的执行时机是什么时候？"><a href="#Service的执行时机是什么时候？" class="headerlink" title="Service的执行时机是什么时候？"></a>Service的执行时机是什么时候？</h2><p>在UE4中，Service是一种在Behavior Tree中执行的任务。Service的执行时机是在Behavior Tree的每个执行周期中，即每帧都会执行一次Service。Service可以用于检测AI角色的状态和环境，并根据检测结果来更新AI角色的行为。</p>
<h2 id="Observer-Aborts的用途是什么？"><a href="#Observer-Aborts的用途是什么？" class="headerlink" title="Observer Aborts的用途是什么？"></a>Observer Aborts的用途是什么？</h2><p>在UE4中，Observer Aborts是一种在Behavior Tree中控制任务执行的机制。Observer Aborts可以在任务执行过程中检测某些条件，并在条件满足时中断任务的执行。Observer Aborts可以用于实现任务的优先级控制、任务的中断和重试等功能。</p>
<h2 id="如何更改UE4默认的同步带宽？"><a href="#如何更改UE4默认的同步带宽？" class="headerlink" title="如何更改UE4默认的同步带宽？"></a>如何更改UE4默认的同步带宽？</h2><p>在UE4中，可以通过修改Engine.ini文件来更改默认的同步带宽。具体步骤如下：</p>
<p>打开Engine.ini文件，该文件位于项目目录下的Config文件夹中。</p>
<p>在文件末尾添加以下内容：</p>
<p>[/Script/Engine.NetworkSettings]<br>NetServerMaxTickRate=60</p>
<p>其中，NetServerMaxTickRate表示同步带宽的最大值，可以根据实际需求进行调整。</p>
<h2 id="UE4中的数据存取方法有哪些？"><a href="#UE4中的数据存取方法有哪些？" class="headerlink" title="UE4中的数据存取方法有哪些？"></a>UE4中的数据存取方法有哪些？</h2><p>保存和加载游戏状态：可以使用SaveGame和LoadGame函数来保存和加载游戏状态。<br>保存和加载配置文件：可以使用Config文件来保存和加载配置信息。<br>保存和加载用户数据：可以使用UserSettings文件来保存和加载用户数据。<br>保存和加载存档：可以使用SaveGame和LoadGame函数来保存和加载存档。</p>
<h2 id="怎么理解C-多态的“父类指针或引用指向子类对象”？"><a href="#怎么理解C-多态的“父类指针或引用指向子类对象”？" class="headerlink" title="怎么理解C++多态的“父类指针或引用指向子类对象”？"></a>怎么理解C++多态的“父类指针或引用指向子类对象”？</h2><p>动态多态<br>动态多态的实现是通过子类重写父类的虚函数实现的。</p>
<p>动态多态需要满足的条件：<br>有继承关系<br>子类重写父类中的虚函数<br>动态多态的使用方法：<br>父类指针或引用指向子类对象<br>假设我们现在有如下的类，其中Animal为基类，Cat和Dog都是其派生类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1.父类指针指向子类对象<br>调用时，可以定义父类的指针，然后指向子类的对象，指向哪个对象，便执行其对象的虚函数实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog B;</span><br><span class="line">    Animal *A=&amp;B;</span><br><span class="line">    A-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    </span><br><span class="line">    A=<span class="keyword">new</span> Cat;</span><br><span class="line">    A-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.父类引用指向子类对象<br>这种实现，我们需要额外定义一个“实现函数”，其参数是基类的引用（否则不能实现多态）。这样在调用时就实现了父类引用指向子类对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; X)</span></span>&#123; <span class="comment">//</span></span><br><span class="line">    X.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat A;</span><br><span class="line">    <span class="built_in">DoSpeak</span>(A);</span><br><span class="line">    Dog B;</span><br><span class="line">    <span class="built_in">DoSpeak</span>(B);</span><br><span class="line">    Animal C;</span><br><span class="line">    <span class="built_in">DoSpeak</span>(C);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么父类指针可以指向子类？<br>可以通俗的理解，子类可能含有一些父类没有的成员变量或者方法函数，但是子类肯定继承了父类所有的成员变量和方法函数。<br>所以用父类指针指向子类时，没有问题，因为父类有的，子类都有，不会出现非法访问问题。但是如果用子类指针指向父类的话，一旦访问子类特有的方法函数或者成员变量，就会出现非法。</p>
<p>虽然父类指针可以指向子类，但是其访问范围还是仅仅局限于父类本身有的数据，那些子类的数据，父类指针是无法访问的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/Unreal/" rel="tag"># Unreal</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/23/C++Study/CppStudy1/" rel="prev" title="C++随笔1">
      <i class="fa fa-chevron-left"></i> C++随笔1
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/05/UnrealStudy/UE4-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="next" title="UE4 性能优化相关">
      UE4 性能优化相关 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="SOHUCS"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Actor%E7%9A%84EndPlay%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%97%B6%E5%80%99%E4%BC%9A%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">Actor的EndPlay事件在哪些时候会调用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlueprintImplementableEvent%E5%92%8CBlueprintNativeEvent%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">BlueprintImplementableEvent和BlueprintNativeEvent之间有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlurprintPure%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">BlurprintPure在什么时候使用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E7%9A%84%E8%93%9D%E5%9B%BE%E4%B8%AD%E5%AF%B9%E4%BA%8EForeach%E7%AD%89%E5%BE%AA%E7%8E%AF%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF%E7%B1%BB%E4%BC%BC%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%AF%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E8%A1%8C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">UE4的蓝图中对于Foreach等循环采用的是类似并行的方式，试实现一个串行的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%AD%90%E5%BC%B9%E7%A9%BF%E5%A2%99%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">如何解决子弹穿墙问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E5%AF%B9UStruct%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86%E5%90%97%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">UE4对UStruct的内存会自动管理吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E5%88%B0AIController%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">在客户端是否可以获取到AIController？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E9%9D%A2%E8%83%BD%E5%A4%9F%E6%89%A7%E8%A1%8CRPC%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">客户端上面能够执行RPC的对象有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8C-%E4%B8%AD%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8windows%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">如果在C++中需要使用windows的头文件，如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84-generated-h%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">在头文件中经常出现的*.generated.h是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4-%E5%85%A5%E9%97%A8%E5%AE%8F"><span class="nav-number">11.</span> <span class="nav-text">UE4 入门宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%B8%80%E4%B8%AAActor%E8%B0%83%E7%94%A8AIMoveTo%E5%A4%B1%E8%B4%A5%E4%BA%86%EF%BC%8C%E5%85%B6%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">对一个Actor调用AIMoveTo失败了，其可能原因是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%95%E8%AF%B4%E5%87%BA%E5%AE%8F%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%83%A8%E5%88%86%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">13.</span> <span class="nav-text">试说出宏、函数、事件的部分区别和联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%95%E4%BD%BF%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%93%9D%E5%9B%BE%E4%B8%AD%E4%BB%BB%E6%84%8FActor%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="nav-number">14.</span> <span class="nav-text">试使用C++实现一个对蓝图中任意Actor排序的框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Blueprintable%E5%92%8CBlueprintType%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">15.</span> <span class="nav-text">Blueprintable和BlueprintType的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E9%9D%A2%E5%AF%B9%E4%B8%80%E4%B8%AAActor%E4%B8%AD%E7%9A%84RPC%E4%BA%8B%E4%BB%B6%E8%B0%83%E7%94%A8%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">客户端上面对一个Actor中的RPC事件调用失败，可能原因是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%E7%9A%84RPC%E4%BA%8B%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">UE4中的RPC事件有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEActor%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%B4%E9%9A%94%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">如何设置Actor的同步间隔？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8B%A5%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E6%92%AD%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">若需要实现一个多播事件，如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">连接服务器的命令是什么，如何传递参数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81TWeakPtr%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">为什么需要TWeakPtr？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E7%9A%84%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F"><span class="nav-number">22.</span> <span class="nav-text">UE4的模块系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%EF%BC%88UObject%E7%B1%BB%EF%BC%89%E5%92%8C%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%88UClass%E7%B1%BB%EF%BC%89"><span class="nav-number">23.</span> <span class="nav-text">简单介绍一下对象系统（UObject类）和类型系统（UClass类）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Core%E6%A8%A1%E5%9D%97%E5%8C%85%E5%90%AB%E4%BA%86%E5%93%AA%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%B1%BB"><span class="nav-number">24.</span> <span class="nav-text">Core模块包含了哪些基础类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RHI%E6%A8%A1%E5%9D%97"><span class="nav-number">25.</span> <span class="nav-text">RHI模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Engine%E6%A8%A1%E5%9D%97"><span class="nav-number">26.</span> <span class="nav-text">Engine模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UMG-%E6%A8%A1%E5%9D%97"><span class="nav-number">27.</span> <span class="nav-text">UMG 模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-number">28.</span> <span class="nav-text">UE4中的类型系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%EF%BC%8C%E5%90%84%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">UE4中，各种字符编码如何转换？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A%E5%9C%A8%E8%93%9D%E5%9B%BE%E4%B8%AD%E6%98%BE%E7%A4%BA%E4%B8%BA%E4%B9%B1%E7%A0%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">C++源文件中的注释在蓝图中显示为乱码，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84LoadingPhase%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">31.</span> <span class="nav-text">插件中的LoadingPhase是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E4%B8%8D%E5%90%8C%E7%9A%84%E5%BC%95%E6%93%8E%E7%89%88%E6%9C%AC%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">如何切换不同的引擎版本？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%9B%A2%E9%98%9F%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86DDC%EF%BC%9F"><span class="nav-number">33.</span> <span class="nav-text">对于一个团队项目，如何处理DDC？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UFUNCTION%EF%BC%8CUPROPERTY%E7%AD%89%E5%AE%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">UFUNCTION，UPROPERTY等宏的作用是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99AI%E5%A2%9E%E5%8A%A0playerstate%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">如何给AI增加playerstate？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ProjectileComponent%E6%98%AF%E5%90%A6%E5%90%8C%E6%AD%A5%EF%BC%9F%E8%8B%A5%E6%9C%AA%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">ProjectileComponent是否同步？若未同步，如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8B%A5%E8%A6%81%E6%9B%B4%E6%94%B9%E6%9F%90%E4%B8%AAActor%E4%B8%AD%E7%9A%84%E7%BB%84%E4%BB%B6%E4%B8%BA%E5%85%B6%E6%B4%BE%E7%94%9F%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">37.</span> <span class="nav-text">若要更改某个Actor中的组件为其派生的组件，如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9%EF%BC%9F"><span class="nav-number">38.</span> <span class="nav-text">UE4的游戏框架包含哪些内容？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E5%89%8DUE4%E5%9C%A8%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E4%B8%8A%E9%9D%A2%E7%9A%84%E9%97%AE%E9%A2%98%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">39.</span> <span class="nav-text">当前UE4在移动平台上面的问题有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%BB%98%E8%AE%A4%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%93%AA%E4%B8%80%E4%B8%AA%EF%BC%9F%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AFUDP%E8%BF%98%E6%98%AFTCP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">UE4服务器的默认监听端口是哪一个？采用的是UDP还是TCP协议？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tick%E4%B8%AD%E7%9A%84%E5%B8%A7%E6%97%B6%E9%97%B4%E6%98%AF%E5%90%A6%E5%8F%AF%E9%9D%A0%EF%BC%9F%E8%8B%A5%E4%B8%8D%E5%8F%AF%E9%9D%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">Tick中的帧时间是否可靠？若不可靠，如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E7%9A%84%E6%89%93%E5%8C%85%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">42.</span> <span class="nav-text">UE4的打包方法有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%B7%AE%E5%BC%82%E5%8C%85%E6%88%96%E8%80%85%E8%A1%A5%E4%B8%81%EF%BC%9F"><span class="nav-number">43.</span> <span class="nav-text">如何制作差异包或者补丁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%95%E8%AF%B4%E5%87%BASelector%E3%80%81Sequence%E3%80%81Parallel%E7%9A%84%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">44.</span> <span class="nav-text">试说出Selector、Sequence、Parallel的运作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%E7%9A%84AI%E6%84%9F%E7%9F%A5%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">45.</span> <span class="nav-text">UE4中的AI感知组件有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8UE4%E7%9A%84C-%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">46.</span> <span class="nav-text">在UE4的C++中调用父类的函数，如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E5%86%85%E7%BD%AE%E7%9A%84%E4%BC%A4%E5%AE%B3%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">47.</span> <span class="nav-text">UE4内置的伤害接口是什么，有哪些类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%E7%9A%84%E8%81%94%E7%BD%91%E4%BC%9A%E8%AF%9D%E8%8A%82%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">UE4中的联网会话节点有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">49.</span> <span class="nav-text">UE4中的字符串有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE%E8%A7%92%E8%89%B2%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">50.</span> <span class="nav-text">获取和释放角色如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%9C%B0%E5%9B%BE%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">设置地图的游戏模式，有哪些方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%A9%E5%AE%B6%E6%93%8D%E4%BD%9C%E4%BA%8B%E4%BB%B6%E6%94%BE%E5%9C%A8PlayerController%E5%92%8CPawn%E4%B8%AD%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-number">52.</span> <span class="nav-text">玩家操作事件放在PlayerController和Pawn中，该如何选择？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E6%8D%A2%E5%85%B3%E5%8D%A1%E7%9A%84%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">53.</span> <span class="nav-text">切换关卡的命令是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%AF%E6%8C%81%E5%9B%9E%E6%94%BE%EF%BC%9F%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">54.</span> <span class="nav-text">UE4中是否可以支持回放？如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E7%9A%84%E8%93%9D%E5%9B%BE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">55.</span> <span class="nav-text">UE4的蓝图类型有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAUSTRUCT-MyStruct%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%EF%BC%9F"><span class="nav-number">56.</span> <span class="nav-text">添加一个USTRUCT MyStruct，是否可以？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8B%A5%E8%A6%81C-%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E6%9A%B4%E9%9C%B2%E7%BB%99%E8%93%9D%E5%9B%BE%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">57.</span> <span class="nav-text">若要C++中的属性暴露给蓝图，如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8C-%E4%B8%AD%E4%B8%BA%E5%AF%B9%E8%B1%A1%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">58.</span> <span class="nav-text">在C++中为对象设置默认值有哪些方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%ADReliable%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">59.</span> <span class="nav-text">C++中Reliable的意义是什么，该如何实现对应的操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">60.</span> <span class="nav-text">如果项目中需要专用服务器，如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%E7%9A%84Delegates%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">61.</span> <span class="nav-text">UE4中的Delegates有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%9C%A8%E5%93%AA%E5%84%BF%EF%BC%9F"><span class="nav-number">62.</span> <span class="nav-text">如何分析性能瓶颈在哪儿？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E7%9A%84%E7%A2%B0%E6%92%9E%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">63.</span> <span class="nav-text">UE4的碰撞类型有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E9%80%82%E5%BA%94%E4%BA%8EMMO%EF%BC%9F%E8%8B%A5%E4%B8%8D%E9%80%82%E5%BA%94%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">64.</span> <span class="nav-text">UE4的服务器是否适应于MMO？若不适应，有什么解决方案？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%90%8C%E6%AD%A5%EF%BC%9F%E8%8B%A5%E4%B8%8D%E6%94%AF%E6%8C%81%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">65.</span> <span class="nav-text">动画蓝图是否支持同步？若不支持，有什么解决方案？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%90%E8%B4%A8%E5%8F%82%E6%95%B0%E3%80%81%E7%89%B9%E6%95%88%E5%8F%82%E6%95%B0%E3%80%81%E5%A3%B0%E9%9F%B3%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">66.</span> <span class="nav-text">材质参数、特效参数、声音参数如何使用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8B%A5%E8%A6%81%E5%AF%B9%E6%89%93%E5%8C%85%E4%B9%8B%E5%90%8E%E7%9A%84%E7%89%88%E6%9C%AC%E8%BF%9B%E8%A1%8C%E8%B7%9F%E8%B8%AA%E5%92%8C%E8%B0%83%E8%AF%95%EF%BC%8C%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">67.</span> <span class="nav-text">若要对打包之后的版本进行跟踪和调试，如何操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AF%B9%E7%BB%84%E4%BB%B6%E6%88%96%E8%80%85Actor%E8%AE%BE%E7%BD%AE%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="nav-number">68.</span> <span class="nav-text">C++中如何对组件或者Actor设置同步？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0%E7%9B%B8%E5%AF%B9%E4%BA%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">69.</span> <span class="nav-text">四元数相对于欧拉角的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%E9%9C%80%E8%A6%81%E5%AF%B9%E4%B8%80%E4%B8%AA%E5%8E%9F%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81%E5%AF%BB%E8%B7%AF%E7%9A%84Actor%E5%AE%9E%E7%8E%B0%E5%AF%BB%E8%B7%AF%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">70.</span> <span class="nav-text">UE4中需要对一个原本不支持寻路的Actor实现寻路功能，如何实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UI%E4%B8%AD%E7%9A%84%E9%94%9A%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="nav-number">71.</span> <span class="nav-text">UI中的锚是用来干什么的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8EUE4%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%8C%E5%A6%82Steam%EF%BC%9F"><span class="nav-number">72.</span> <span class="nav-text">如何基于UE4的网络接口，实现一个网络层，如Steam？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E6%89%93%E5%8C%85%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%A0%E5%AF%86%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">73.</span> <span class="nav-text">对于打包之后的游戏资源，有什么加密方案？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8Actor%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%BA%86%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%BD%86%E6%98%AF%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E5%8D%B4%E6%97%A0%E6%B3%95%E8%A7%A6%E5%8F%91%EF%BC%8C%E5%85%B6%E5%8E%9F%E5%9B%A0%E5%8F%AF%E8%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">74.</span> <span class="nav-text">在Actor中增加了输入事件，但是输入事件却无法触发，其原因可能有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpawnActor%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%AF%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">75.</span> <span class="nav-text">SpawnActor的位置不对，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8BeginPlay%E4%B9%8B%E5%90%8E%E8%B0%83%E7%94%A8%E4%BA%86%E6%9F%90%E4%B8%AARPC%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8D%B4%E6%B2%A1%E6%9C%89%E6%89%A7%E8%A1%8C%E5%88%B0%EF%BC%8C%E5%8F%AF%E8%83%BD%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">76.</span> <span class="nav-text">在BeginPlay之后调用了某个RPC操作，客户端却没有执行到，可能原因是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B2%A1%E6%9C%89%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E5%89%8D%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F"><span class="nav-number">77.</span> <span class="nav-text">在客户端没有连接到服务器之前，有什么同服务器进行通信的方案吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Actor%E4%B8%AD%E5%A2%9E%E5%8A%A0command%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="nav-number">78.</span> <span class="nav-text">如何在Actor中增加command命令？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%ADce%E5%92%8Cke%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">79.</span> <span class="nav-text">命令行中ce和ke有什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">80.</span> <span class="nav-text">UE4中的智能指针有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%A0%B9%E7%BB%84%E4%BB%B6%E8%AE%BE%E7%BD%AEScale%E4%BC%9A%E6%9C%89%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="nav-number">81.</span> <span class="nav-text">对根组件设置Scale会有问题吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8UE4%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%BA%93%E6%88%96%E8%80%85%E5%8A%A8%E6%80%81%E5%BA%93%EF%BC%9F"><span class="nav-number">82.</span> <span class="nav-text">如何在UE4中使用静态库或者动态库？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%95%E5%88%86%E6%9E%90GameMode%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BB%8EInitGame%E8%87%B3Logout%E3%80%82"><span class="nav-number">83.</span> <span class="nav-text">试分析GameMode的运行流程，如从InitGame至Logout。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%A6%82%E4%BD%95%E6%90%9E%EF%BC%9F"><span class="nav-number">84.</span> <span class="nav-text">UE4的自动化测试如何搞？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E6%91%84%E5%83%8F%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="nav-number">85.</span> <span class="nav-text">多个摄像机之间如何切换？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0UI%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">86.</span> <span class="nav-text">更新UI的方式有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E5%B9%B6%E8%B0%83%E8%8A%82%E4%B8%8D%E5%90%8C%E7%9A%84%E9%9F%B3%E6%95%88%EF%BC%9F"><span class="nav-number">87.</span> <span class="nav-text">如何区分并调节不同的音效？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%94%80%E6%AF%81AIController%EF%BC%9F"><span class="nav-number">88.</span> <span class="nav-text">如何销毁AIController？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8C-%E5%92%8C%E8%93%9D%E5%9B%BE%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="nav-number">89.</span> <span class="nav-text">在C++和蓝图中如何打印调试信息？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%B4%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E5%9C%A8%E5%80%BC%E4%B8%BA0%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%90%97%EF%BC%9F"><span class="nav-number">90.</span> <span class="nav-text">轴输入事件在值为0的时候会触发吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3DWidget%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">91.</span> <span class="nav-text">3DWidget如何使用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84AI%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">92.</span> <span class="nav-text">游戏中的AI技术有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC%E5%92%8C%E5%AF%BB%E8%B7%AF%E7%BB%84%E4%BB%B6%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">93.</span> <span class="nav-text">导航网格和寻路组件各有什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E7%BC%96%E8%AF%91%E6%95%B4%E4%B8%AA%E5%BC%95%E6%93%8E%E8%80%97%E8%B4%B9%E7%9A%84%E5%A4%A7%E9%87%8F%E6%97%B6%E9%97%B4%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">94.</span> <span class="nav-text">对于编译整个引擎耗费的大量时间，有什么解决方案？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%81%94%E6%9C%BA%E6%9E%84%E5%BB%BA%E5%85%89%E7%85%A7%EF%BC%9F"><span class="nav-number">95.</span> <span class="nav-text">如何联机构建光照？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Montage%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">96.</span> <span class="nav-text">Montage是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%8A%A8%E7%94%BB%E6%97%B6%EF%BC%8C%E5%B0%86%E5%8A%A8%E7%94%BB%E5%92%8C%E5%A3%B0%E9%9F%B3%E3%80%81%E7%89%B9%E6%95%88%E5%8C%B9%E9%85%8D%E7%9A%84%E8%BE%83%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">97.</span> <span class="nav-text">执行动画时，将动画和声音、特效匹配的较好的方案是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%8A%A8%E7%94%BB%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BA%8B%E4%BB%B6%EF%BC%9F"><span class="nav-number">98.</span> <span class="nav-text">如何获取动画的执行事件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%EF%BC%9F"><span class="nav-number">99.</span> <span class="nav-text">Service的执行时机是什么时候？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Observer-Aborts%E7%9A%84%E7%94%A8%E9%80%94%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">100.</span> <span class="nav-text">Observer Aborts的用途是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9UE4%E9%BB%98%E8%AE%A4%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B8%A6%E5%AE%BD%EF%BC%9F"><span class="nav-number">101.</span> <span class="nav-text">如何更改UE4默认的同步带宽？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UE4%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">102.</span> <span class="nav-text">UE4中的数据存取方法有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3C-%E5%A4%9A%E6%80%81%E7%9A%84%E2%80%9C%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E2%80%9D%EF%BC%9F"><span class="nav-number">103.</span> <span class="nav-text">怎么理解C++多态的“父类指针或引用指向子类对象”？</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">VisionXie</p>
  <div class="site-description" itemprop="description">生活在树上，始终热爱大地，升入天空。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VisionXie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <script>
  NexT.utils.loadComments(document.querySelector('#SOHUCS'), () => {
    var appid = 'cyvS0HjaG';
    var conf = '26c6eae6e21dfb5a6535a5e53425e9ec';
    var width = window.innerWidth || document.documentElement.clientWidth;
    if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
    } else {
      var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})});
    }
  });
  </script>
  <script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>

</body>
</html>
