<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一些编程基础相关">
<meta property="og:type" content="article">
<meta property="og:title" content="一些杂七杂八的编程知识随笔">
<meta property="og:url" content="http://example.com/2018/02/12/OtherStudy/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="XiMo">
<meta property="og:description" content="一些编程基础相关">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-02-12T16:00:00.000Z">
<meta property="article:modified_time" content="2020-12-01T16:00:00.000Z">
<meta property="article:author" content="VisionXie">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="编程基础">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2018/02/12/OtherStudy/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>一些杂七杂八的编程知识随笔 | XiMo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XiMo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">醉后不知天在水，满船清梦压星河。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>All<span class="badge">30</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/02/12/OtherStudy/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="VisionXie">
      <meta itemprop="description" content="生活在树上，始终热爱大地，升入天空。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiMo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          一些杂七杂八的编程知识随笔
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-02-13 00:00:00" itemprop="dateCreated datePublished" datetime="2018-02-13T00:00:00+08:00">2018-02-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 00:00:00" itemprop="dateModified" datetime="2020-12-02T00:00:00+08:00">2020-12-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index"><span itemprop="name">Other</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    
      <a title="changyan" href="/2018/02/12/OtherStudy/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/#SOHUCS" itemprop="discussionUrl">
        <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2018/02/12/OtherStudy/编程语言学习/" itemprop="commentCount"></span>
      </a>
    
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>一些编程基础相关</p>
<span id="more"></span>
<h1 id="编程语言学习"><a href="#编程语言学习" class="headerlink" title="编程语言学习"></a>编程语言学习</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p>抽象类中可以有部分实现，接口中不支持<br>接口更像是一种规则，一个实现类可以继承多个接口，也就是多个规则，且必须实现接口，抽象类的实现只能继承一个抽象类。<br>抽象类中添加了一个方法，子类中就有了这个方法，可以选择是否重写，而接口中添加一个方法，实现他的类需要重新编写方法。<br>接口成员属性方法不能加修饰词因为都是默认public，抽象类的成员可以是私有的，受保护的，内部的或受保护的内部的<br>接口不能有字段、构造函数、析构函数、静态变量或常量</p>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><ol>
<li>委托是一种引用方法的类型。</li>
<li>委托类似于 C++ 函数指针，但它是类型安全的。</li>
<li>委托允许将方法作为参数进行传递。</li>
<li>委托可用于定义回调方法。</li>
<li>委托是一种引用方法的类型。</li>
<li>委托类似于 C++ 函数指针，但它是类型安全的。</li>
<li>委托允许将方法作为参数进行传递。</li>
<li>委托可用于定义回调方法。</li>
<li>作用是把方法当作参数传入给别的方法，通过这个能实现其他重要特性</li>
<li>可以定义类的地方也可以定义委托</li>
<li>委托多播：相同类型的委托可以使用+来合并委托，也可以使用-来移除委托，利用这个特点，创建一个调用列表，在需要调用的时候调用委托，这是委托多播。</li>
</ol>
<h3 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a>结构体和类的区别</h3><p>结构体可以带有方法，字段，属性等，可以定义构造函数但不能有析构函数<br>结构体不支持继承<br>结构体可以实现接口<br>结构成员不能声明成abstract、virtual或protect（不支持继承嘛）<br>结构体时值类型，类是引用类型</p>
<h2 id="一、C-语言"><a href="#一、C-语言" class="headerlink" title="一、C#语言"></a>一、C#语言</h2><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><ol>
<li>所处位置不同 重载在同类中 重写在父子类中</li>
<li>定义方式不同 重载方法名相同 参数列表不同 重写方法名和参数列表都相同</li>
<li>调用方式不同 重载使用相同对象以不同参数调用 重写用不同对象以相同参数调用</li>
<li>多态时机不同 重载时编译时多态 重写是运行时多态</li>
</ol>
<h3 id="简述值类型和引用类型有什么区别"><a href="#简述值类型和引用类型有什么区别" class="headerlink" title="简述值类型和引用类型有什么区别"></a>简述值类型和引用类型有什么区别</h3><ol>
<li>值类型存储在内存栈中，引用类型数据存储在内存堆中，而内存单元中存放的<br>是堆中存放的地址。值copy与地址copy</li>
<li>值类型存取快，引用类型存取慢。</li>
<li>值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针和引用。</li>
<li>栈的内存是自动释放的，堆内存是 .NET 中会由 GC 来自动释放。</li>
<li>值类型继承自 System.ValueType,引用类型继承自 System.Object。</li>
</ol>
<h3 id="请简述private，public，protected，internal的区别"><a href="#请简述private，public，protected，internal的区别" class="headerlink" title="请简述private，public，protected，internal的区别"></a>请简述private，public，protected，internal的区别</h3><ul>
<li>public：对任何类和成员都公开，无限制访问</li>
<li>private：仅对该类公开</li>
<li>protected：对该类和其派生类公开</li>
<li>internal：只能在包含该类的程序集中访问该类</li>
<li>protected internal：protected + internal</li>
</ul>
<h3 id="C-中所有引用类型的基类是什么"><a href="#C-中所有引用类型的基类是什么" class="headerlink" title="C#中所有引用类型的基类是什么"></a>C#中所有引用类型的基类是什么</h3><p>引用类型的基类是 System.Object 值类型的基类是 System.ValueType<br>同时，值类型也隐式继承自 System.Object</p>
<h3 id="请简述-ArrayList-和-List-lt-Int-gt-的主要区别"><a href="#请简述-ArrayList-和-List-lt-Int-gt-的主要区别" class="headerlink" title="请简述 ArrayList 和 List&lt; Int &gt;的主要区别"></a>请简述 ArrayList 和 List&lt; Int &gt;的主要区别</h3><p>ArrayList 不带泛型 数据类型丢失<br>List&lt; T &gt; 带泛型 数据类型不丢失</p>
<h3 id="请简述-GC（垃圾回收）产生的原因，并描述如何避免？"><a href="#请简述-GC（垃圾回收）产生的原因，并描述如何避免？" class="headerlink" title="请简述 GC（垃圾回收）产生的原因，并描述如何避免？"></a>请简述 GC（垃圾回收）产生的原因，并描述如何避免？</h3><p>GC 为了避免内存溢出而产生的回收机制<br>避免：</p>
<ol>
<li>减少 new 产生对象的次数</li>
<li>使用公用的对象（静态成员）</li>
<li>将 String 换为 StringBuilder</li>
</ol>
<h3 id="命名空间namespace"><a href="#命名空间namespace" class="headerlink" title="命名空间namespace"></a>命名空间namespace</h3><p>命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。两个命名空间中可以有相同名字的类，使用时加前缀。也可以嵌套命名空间。</p>
<h3 id="请描述-Interface-与抽象类之间的不同"><a href="#请描述-Interface-与抽象类之间的不同" class="headerlink" title="请描述 Interface 与抽象类之间的不同"></a>请描述 Interface 与抽象类之间的不同</h3><ol>
<li>接口不是类 不能实例化 抽象类可以间接实例化</li>
<li>接口是完全抽象 抽象类为部分抽象</li>
<li>接口可以多继承 抽象类是单继承</li>
</ol>
<h3 id="下列代码在运行中会产生几个临时对象？"><a href="#下列代码在运行中会产生几个临时对象？" class="headerlink" title="下列代码在运行中会产生几个临时对象？"></a>下列代码在运行中会产生几个临时对象？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a = new string(&quot;abc&quot;);</span><br><span class="line">a=(a.ToUpper()+&quot;123&quot;).Substring(0,2);</span><br></pre></td></tr></table></figure>

<p>其实在 C#中第一行是会出错的（Java 中倒是可行）。应该这样初始化：<br>string b = new string(new char[]{‘a’,’b’,’c’});<br>忽略错误的话：</p>
<ol>
<li>“abc”</li>
<li>a.ToUpper()</li>
<li>“123”</li>
<li>a.ToUpper()+”123”</li>
</ol>
<h3 id="下列代码在运行中会发生什么问题？如何避免？"><a href="#下列代码在运行中会发生什么问题？如何避免？" class="headerlink" title="下列代码在运行中会发生什么问题？如何避免？"></a>下列代码在运行中会发生什么问题？如何避免？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;int&gt; ls = new List&lt;int&gt;(new int[]&#123;1，2，3，4，5&#125;)；</span><br><span class="line">foreach(int item in ls)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(aitem*item);</span><br><span class="line">    ls.Remove(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会产生运行时错误，因为 foreach 是只读的。不能一边遍历一边修改。</p>
<h3 id="请简述关键字-Sealed-用在类声明和函数声明时的作用"><a href="#请简述关键字-Sealed-用在类声明和函数声明时的作用" class="headerlink" title="请简述关键字 Sealed 用在类声明和函数声明时的作用"></a>请简述关键字 Sealed 用在类声明和函数声明时的作用</h3><p>类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。</p>
<h3 id="反射的实现原理？"><a href="#反射的实现原理？" class="headerlink" title="反射的实现原理？"></a>反射的实现原理？</h3><p>可以在加载程序运行时，动态获取和加载程序集，并且可以获取到程序集的信息<br>反射即在运行期动态获取类、对象、方法、对象数据等的一种重要手段<br>主要使用的类库：System.Reflection<br>核心类：<br>1.Assembly描述了程序集<br>2.Type描述了类这种类型<br>3.ConstructorInfo描述了构造函数<br>4.MethodInfo描述了所有的方法<br>5.FieldInfo描述了类的字段<br>6.PropertyInfo描述类的属性<br>通过以上核心类可在运行时动态获取程序集中的类，并执行类构造产生类对象，动态获取对象的字段或属性值，更可以动态执行类方法和实例方法等。</p>
<h3 id="Net-与-Mono-的关系？"><a href="#Net-与-Mono-的关系？" class="headerlink" title=".Net 与 Mono 的关系？"></a>.Net 与 Mono 的关系？</h3><p>.Net是一个语言平台，Mono为.Net提供集成开发环境，集成并实现了.NET的编译器、CLR 和基础类库，使得.Net既可以运行在windows也可以运行于 linux，Unix，Mac OS 等。</p>
<h3 id="在类的构造函数前加上-static-会报什么错-为什么"><a href="#在类的构造函数前加上-static-会报什么错-为什么" class="headerlink" title="在类的构造函数前加上 static 会报什么错?为什么?"></a>在类的构造函数前加上 static 会报什么错?为什么?</h3><p>构造函数格式为 public+类名如果加上 static 会报错（静态构造函数不能有访问修饰符）<br>原因：静态构造函数不允许访问修饰符，也不接受任何参数；无论创建多少类型的对象，静态构造函数只执行一次；运行库创建类实例或者首次访问静态成员之前，运行库调用静态构造函数；静态构造函数执行先于任何实例级别的构造函数；显然也就无法使用 this 和 base 来调用构造函数。</p>
<h3 id="C-String-类型比-stringBuilder-类型的优势是什么"><a href="#C-String-类型比-stringBuilder-类型的优势是什么" class="headerlink" title="C# String 类型比 stringBuilder 类型的优势是什么?"></a>C# String 类型比 stringBuilder 类型的优势是什么?</h3><ul>
<li>如果是处理字符串的话，用 string 中的方法每次都需要创建一个新的字符串对象并且分配新的内存地址，而 stringBuilder 是在原来的内存里对字符串进行修改，所以在字符串处理方面还是建议用 stringBuilder 这样比较节约内存。但是 string 类的方法和功能仍然还是比 stringBuilder 类要强。</li>
<li>string 类由于具有不可变性（即对一个 string 对象进行任何更改时，其实都是创建另外一个 string 类的对象），所以当需要频繁的对一个 string 类对象进行更改的时候，建议使用StringBuilder 类</li>
<li>StringBuilder 类的原理是首先在内存中开辟一定大小的内存空间，当对此 StringBuilder 类对象进行更改时， 如果内存空间大小不够， 会对此内存空间进行扩充，而不是重新创建一个对象，这样如果对一个字符串对象进行频繁操作的时候，不会造成过多的内存浪费，其实本质上并没有很大区别，都是用来存储和操作字符串的，唯一的区别就在于性能上。</li>
<li>String 主要用于公共 API，通用性好、用途广泛、读取性能高、占用内存小。</li>
<li>StringBuilder 主要用于拼接 String，修改性能好。不过现在的编译器已经把 String 的 + 操作优化成 StringBuilder 了， 所以一般用String 就可以了</li>
<li>String 是不可变的，所以天然线程同步。</li>
<li>StringBuilder 可变，非线程同步。</li>
</ul>
<h3 id="C-函数-Func-string-a-string-b-用-Lambda-表达式怎么写"><a href="#C-函数-Func-string-a-string-b-用-Lambda-表达式怎么写" class="headerlink" title="C# 函数 Func(string a, string b)用 Lambda 表达式怎么写?"></a>C# 函数 Func(string a, string b)用 Lambda 表达式怎么写?</h3><p>(a,b) =&gt; {};</p>
<h3 id="什么是弱引用？弱引用的使用和作用？弱引用和强引用的区别？"><a href="#什么是弱引用？弱引用的使用和作用？弱引用和强引用的区别？" class="headerlink" title="什么是弱引用？弱引用的使用和作用？弱引用和强引用的区别？"></a>什么是弱引用？弱引用的使用和作用？弱引用和强引用的区别？</h3><p>区别：强引用GC是不会回收对象<br>使用：.NET中提供了WeakReference来实现<br>WeakReference weakObj=new WeakReference(Object);<br>作用：同时保持对对象的引用，而又可以让GC需要的时候回收这个对象，防止内存泄露。<br>使用情景：对于那些创建便宜但耗费大量内存的对象，即希望保持该对象，又要在应用程序需要时使用，同时希望GC必要时回收时，可以考虑使用弱引用。</p>
<h3 id="Using的使用方法"><a href="#Using的使用方法" class="headerlink" title="Using的使用方法"></a>Using的使用方法</h3><ul>
<li>引用命名空间，使用命名空间中的名称</li>
<li>起别名using a=space.b.a;</li>
<li>Using static指定无需指定类型名称即可访问其静态成员的类型<br>  using static System.Math;<br>  var = PI; // 直接使用System.Math.PI</li>
</ul>
<h3 id="C-中有哪些常用的容器类，各有什么特点"><a href="#C-中有哪些常用的容器类，各有什么特点" class="headerlink" title="C#中有哪些常用的容器类，各有什么特点"></a>C#中有哪些常用的容器类，各有什么特点</h3><p>List,HashTable,Dictionary,Stack,Queue<br>List：索引泛型容器 访问速度快 修改速度慢<br>HashTable/Dictionary：散列表格式 查询效率高 空间占用较大<br>Stack：后进先出<br>Queue: 先进先出</p>
<h3 id="C-中常规容器和泛型容器有什么区别，哪种效率高？"><a href="#C-中常规容器和泛型容器有什么区别，哪种效率高？" class="headerlink" title="C#中常规容器和泛型容器有什么区别，哪种效率高？"></a>C#中常规容器和泛型容器有什么区别，哪种效率高？</h3><p>不带泛型的容器需要装箱和拆箱操作 速度慢 所以泛型容器效率更高 数据类型更安全</p>
<h3 id="有哪些常见的数值类？"><a href="#有哪些常见的数值类？" class="headerlink" title="有哪些常见的数值类？"></a>有哪些常见的数值类？</h3><p>简单值类型–包括 整数类型、实数类型、字符类型、布尔类型<br>复合值类型–包括 结构类型、枚举类型</p>
<h3 id="C-中委托和接口有什么区别？各用在什么场合？"><a href="#C-中委托和接口有什么区别？各用在什么场合？" class="headerlink" title="C#中委托和接口有什么区别？各用在什么场合？"></a>C#中委托和接口有什么区别？各用在什么场合？</h3><p>接口（interface）是约束类应该具备的功能集合，约束了类应该具备的功能，使类从千变万化的具体逻辑中解脱出来，便于类的管理和扩展，同时又合理解决了类的单继承问题。<br>C#中的委托是约束方法集合的一个类，可以便捷的使用委托对这个方法集合进行操作。<br>在以下情况中使用接口：</p>
<ol>
<li>无法使用继承的场合</li>
<li>完全抽象的场合</li>
<li>多人协作的场合 以上等等</li>
</ol>
<p>在以下情况中使用委托：多用于事件处理中</p>
<h3 id="C-中unsafe关键字是用来做什么的？什么场合下使用？"><a href="#C-中unsafe关键字是用来做什么的？什么场合下使用？" class="headerlink" title="C#中unsafe关键字是用来做什么的？什么场合下使用？"></a>C#中unsafe关键字是用来做什么的？什么场合下使用？</h3><p>非托管代码才需要这个关键字 一般用在带指针操作的场合</p>
<h3 id="For，foreach，Enumerator-MoveNext的使用，与内存消耗情况"><a href="#For，foreach，Enumerator-MoveNext的使用，与内存消耗情况" class="headerlink" title="For，foreach，Enumerator.MoveNext的使用，与内存消耗情况"></a>For，foreach，Enumerator.MoveNext的使用，与内存消耗情况</h3><p>for 循环可以通过索引依次进行遍历，foreach和Enumerator.MoveNext通过迭代的方式进行遍历。内存消耗上本质上并没有太大的区别。但是在Unity中的Update中，一般不推荐使用foreach 因为会遗留内存垃圾。</p>
<h3 id="函数中多次使用string的-处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决"><a href="#函数中多次使用string的-处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决" class="headerlink" title="函数中多次使用string的+=处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决"></a>函数中多次使用string的+=处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决</h3><p>通过StringBuilder那进行append，这样可以减少内存垃圾</p>
<h3 id="当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？"><a href="#当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？" class="headerlink" title="当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？"></a>当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？</h3><p>设计单例模式进行创建对象或者使用对象池</p>
<h3 id="JIT-和AOT区别"><a href="#JIT-和AOT区别" class="headerlink" title="JIT 和AOT区别"></a>JIT 和AOT区别</h3><p>Just-In-Time - 实时编译<br>执行慢 安装快 占空间小一点<br>Ahead-Of-Time - 预先编译<br>执行快 安装慢 占内存占外存大</p>
<h3 id="给定一个存放参数的数组，重新排列数组"><a href="#给定一个存放参数的数组，重新排列数组" class="headerlink" title="给定一个存放参数的数组，重新排列数组"></a>给定一个存放参数的数组，重新排列数组</h3><p>void SortArray(Array arr){Array.Sort(arr);}</p>
<h3 id="Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？-注：Try…-Catch捕捉异常，发送信息不可行"><a href="#Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？-注：Try…-Catch捕捉异常，发送信息不可行" class="headerlink" title="Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？(注：Try…..Catch捕捉异常，发送信息不可行)"></a>Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？(注：Try…..Catch捕捉异常，发送信息不可行)</h3><p>foreach 不能进行元素的删除，因为迭代器会锁定迭代的集合，解决方法：记录找到索引或者key值，迭代结束后再进行删除。</p>
<h3 id="GameObject-a-new-GameObject-GameObject-b-a-实例化出来了A，将A赋给B，现在将B删除，问A还存在吗？"><a href="#GameObject-a-new-GameObject-GameObject-b-a-实例化出来了A，将A赋给B，现在将B删除，问A还存在吗？" class="headerlink" title="GameObject a=new GameObject()  GameObject b=a  实例化出来了A，将A赋给B，现在将B删除，问A还存在吗？"></a>GameObject a=new GameObject()  GameObject b=a  实例化出来了A，将A赋给B，现在将B删除，问A还存在吗？</h3><p>存在，b删除只是将它在栈中的内存删除，而A对象本身是在堆中，所以A还存在</p>
<h3 id="C-面向对象三大特性"><a href="#C-面向对象三大特性" class="headerlink" title="C#面向对象三大特性"></a>C#面向对象三大特性</h3><ul>
<li>封装:封装是将数据和行为相结合，通过行为约束代码修改数据的程度，增强数据的安全性，属性是C#封装实现的最好体现。</li>
<li>继承:提高代码重用度，增强软件可维护性的重要手段，符合开闭原则。</li>
<li>多态，多态性是指同名的方法在不同环境下，自适应的反应出不同得表现，是方法动态展示的重要手段。实现一个接口多个功能<br>  静态多态性：函数重载，运算符重载，<br>  动态多态性使用抽象类（abstract修饰）和虚函数（允许在派生类中重写）实现，virtual声明虚函数，Override重写该方法</li>
</ul>
<h3 id="抽象方法和虚方法的区别"><a href="#抽象方法和虚方法的区别" class="headerlink" title="抽象方法和虚方法的区别"></a>抽象方法和虚方法的区别</h3><p>1.虚方法必须有实现部分，抽象方法没有提供实现部分，抽象方法是一种强制派生类覆盖的方法，否则派生类将不能被实例化。<br>2.抽象方法只能在抽象类中声明，虚方法不是。如果类包含抽象方法，那么该类也是抽象的，也必须声明类是抽象的。<br>3.抽象方法必须在派生类中重写，这一点和接口类似，虚方法不需要再派生类中重写。<br>简单说，抽象方法是需要子类去实现的。虚方法是已经实现了的，可以被子类覆盖，也可以不覆盖，取决于需求。</p>
<h3 id="重写-override"><a href="#重写-override" class="headerlink" title="重写(override)"></a>重写(override)</h3><p>子类中为满足自己的需要来重复定义某个方法的不同实现，需要用 override 关键字，被重写的方法必须是虚方法，用的是 virtual 关键字。它的特点是(三个相同):相同的方法名、参数列表、返回值<br> 抽象方法和虚方法都可以供派生类重写</p>
<h2 id="C-集合"><a href="#C-集合" class="headerlink" title="C#集合"></a>C#集合</h2><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>可以使用索引在指定的位置添加和移除项目，动态数组会自动重新调整它的大小。它也允许在列表中进行动态内存分配、增加、搜索、排序各项。<br>动态数组中Capacity属性是数组动态扩容的机制—-翻倍增长的</p>
<h3 id="哈希表HashTable：键值对，适用于任何需要提高效率的地方"><a href="#哈希表HashTable：键值对，适用于任何需要提高效率的地方" class="headerlink" title="哈希表HashTable：键值对，适用于任何需要提高效率的地方"></a>哈希表HashTable：键值对，适用于任何需要提高效率的地方</h3><p>字典Dictionary：必须包含名空间System.Collection.Generic ，Dictionary里面的每一个元素都是一个键值对(由二个元素组成：键和值) ，键必须是唯一的,而值不需要唯一的,键和值都可以是任何类型(比如：string, int, 自定义类型，等等),通过一个键读取一个值的时间是接近O(1),键值对之间的偏序可以不定义</p>
<h3 id="哈希表和字典比起来怎么样？什么时候用？"><a href="#哈希表和字典比起来怎么样？什么时候用？" class="headerlink" title="哈希表和字典比起来怎么样？什么时候用？"></a>哈希表和字典比起来怎么样？什么时候用？</h3><p>1、字典支持泛型，哈希表不支持<br>2、单线程中使用字典，因为字典具有泛型优势，且读取速度更快，容量利用更充分<br>多线程中使用哈希表，哈希表具有Synchronized()方法获取到完全线程安全类型，而字典需要认为添加lock语句，大大降低效率<br>3、Dictionary有按插入顺序排列数据的特性(注:但当调用Remove()删除过节点后顺序被打乱), 因此在需要体现顺序的情境中使用字典能获得一定方便<br>4、HashTable是经过优化的，访问下标的对象先散列过，所以内部是无序散列的，保证了高效率，也就是说，其输出不是按照开始加入的顺序，而Dictionary遍历输出的顺序，就是加入的顺序，这点与Hashtable不同<br>5、哈希表的索引方式特别迅速，在数据量大的时候尤其明显<br>6、字典无需进行装箱拆箱操作，在需要频繁拆装箱的时候效率更高，哈希表在对int，float等值类型存储或检索时需要进行装箱拆箱操作</p>
<h3 id="排序列表"><a href="#排序列表" class="headerlink" title="排序列表"></a>排序列表</h3><p>代表了一系列按照键来排序的键/值对，这些键值对可以通过键和索引来访问。<br>排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组，如果您使用键访问各项，则它是一个哈希表。集合中的各项总是按键值排序</p>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>后进先出，Peek()返回在 Stack 的顶部的对象，但不移除它</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>先进先出</p>
<h3 id="点阵列"><a href="#点阵列" class="headerlink" title="点阵列"></a>点阵列</h3><p>……不懂怎么用，什么时候用</p>
<h3 id="C-泛型"><a href="#C-泛型" class="headerlink" title="C#泛型"></a>C#泛型</h3><ul>
<li>泛型允许编写一个可以与任何数据类型一起工作的类或方法。</li>
<li>可以通过数据类型的替代参数编写类或方法的规范。</li>
<li>当编译器遇到类的构造函数或方法的函数调用时，它会生成代码来处理指定的数据类型</li>
<li>可以用来重用代码，保护类型的安全以及提高性能</li>
<li>可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。<br>Public class genericClass&lt; T &gt;{}</li>
<li>可以对泛型类进行约束以访问特定数据类型的方法。</li>
<li>关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取</li>
</ul>
<h3 id="C-事件"><a href="#C-事件" class="headerlink" title="C#事件"></a>C#事件</h3><ul>
<li><p>C# 中使用事件机制实现线程间的通信<br>通过事件可使用委托  发布-订阅 模型<br>（和委托的区别，使用场合区别）</p>
</li>
<li><p>事件Event：它封装了委托类型的变量，使得：在类的内部，不管你声明它是public还是protected，它总是private 的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同</p>
</li>
<li><p>事件和委托的关系与区别理解：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yijun494610095/article/details/62422746">https://blog.csdn.net/yijun494610095/article/details/62422746</a></p>
</li>
</ul>
<h3 id="Assembly-Defination"><a href="#Assembly-Defination" class="headerlink" title="Assembly Defination"></a>Assembly Defination</h3><p>Assembly Definition是什么？<br>    我们知道Unity是自动定义脚本如何编译为托管程序集，所有脚本编译之后会生成一个托管程序集。那么自然随着我们添加的脚本越来越多，编译时间就会越来越久。如果当项目变的足够大之后，这个等待的编译时间是相当可怕的。<br>    如此以来Assembly Definition File（程序集定义文件）应运而生，可以用它来减少这个编译时间。<br> 原理依据：<br>    将脚本分文件夹保存，一个包含多个脚本的文件夹生成一个Assembly Definition File（程序集定义文件），当修改了其中一个脚本之后，只会重新编译包含该脚本的Assembly Definition File（程序集定义文件），其他的不用重新编译，从而减少编译时间。</p>
<h3 id="Switch-case的替换方案"><a href="#Switch-case的替换方案" class="headerlink" title="Switch case的替换方案"></a>Switch case的替换方案</h3><p>使用Dictionary</p>
<h2 id="请简述拆箱和装箱"><a href="#请简述拆箱和装箱" class="headerlink" title="请简述拆箱和装箱"></a>请简述拆箱和装箱</h2><p>装箱操作：值类型隐式转换为object类型或由此值类型实现的任何接口类型的过程。</p>
<ol>
<li>在堆中开辟内存空间。</li>
<li>将值类型的数据复制到堆中。</li>
<li>返回堆中新分配对象的地址。</li>
</ol>
<p>拆箱操作：<br>object类型显示转换为值类型或从接口类型到实现该接口值类型的过程。</p>
<ol>
<li>判断给定类型是否是装箱时的类型。</li>
<li>返回已装箱实例中属于原值类型字段的地址。</li>
</ol>
<h2 id="C-中，string-str-null-与-string-str-“”，说明区别"><a href="#C-中，string-str-null-与-string-str-“”，说明区别" class="headerlink" title="C#中，string str = null 与 string str = “”，说明区别"></a>C#中，string str = null 与 string str = “”，说明区别</h2><p>string str = “” 初始化对象分配空间。<br>string str = null 表示一个空引用,没有占用空间。</p>
<h2 id="ref与out关键字"><a href="#ref与out关键字" class="headerlink" title="ref与out关键字"></a>ref与out关键字</h2><p>ref 关键字使参数按引用传递。其效果是，当控制权传递回调用方法时，在方法中对参数所做的任何更改都将反映在该变量中。若要使用 ref 参数，则方法定义和调用方法都必须显式使用 ref 关键字。<br>out 关键字会导致参数通过引用来传递。这与 ref 关键字类似，不同之处在于 ref 要求变量必须在传递之前进行初始化。若要使用 out 参数，方法定义和调用方法都必须显式使用 out 关键字。</p>
<h2 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h2><p>序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</p>
<h2 id="sealed-修饰符有什么特点"><a href="#sealed-修饰符有什么特点" class="headerlink" title="sealed 修饰符有什么特点"></a>sealed 修饰符有什么特点</h2><ol>
<li>sealed 修饰符可以应用于类、实例方法和属性。密封类不能被继承。密封方法会重写基类中的方法，但其本身不能在任何派生类中进一步重写。当应用于方法或属性时，sealed 修饰符必须始终与 override一起使用。</li>
<li>将密封类用作基类或将 abstract 修饰符与密封类一起使用是错误的。</li>
<li>结构是隐式密封的；因此它们不能被继承。</li>
<li>sealed 修饰符可以应用于类、实例方法和属性。密封类不能被继承。密封方法会重写基类中的方法，但其本身不能在任何派生类中进一步重写。当应用于方法或属性时，sealed 修饰符必须始终与 override一起使用。</li>
<li>将密封类用作基类或将 abstract 修饰符与密封类一起使用是错误的。</li>
<li>结构是隐式密封的；因此它们不能被继承。</li>
</ol>
<h2 id="class和struct的异同"><a href="#class和struct的异同" class="headerlink" title="class和struct的异同"></a>class和struct的异同</h2><p>相同点：</p>
<ol>
<li>语法类似。</li>
</ol>
<p>不同点：</p>
<ol>
<li>class是引用类型，继承自System.Object类; struct是值类型，继承自System.ValueType类，因此不具多态性。但是注意，System.ValueType是个引用类型。</li>
<li>从职能观点来看，class表现为行为; 而struct常用于存储数据。</li>
<li>class支持继承，可以继承自类和接口; 而struct没有继承性，struct不能从class继承，也不能作为class的基类，但struct支持接口继承。</li>
<li>实例化时，class要使用new关键字; 而struct可以不使用new关键字，struct在声明时就进行了初始化过程，所有的成员变量均默认为0或null。</li>
</ol>
<h2 id="如何选择结构struct还是类class"><a href="#如何选择结构struct还是类class" class="headerlink" title="如何选择结构struct还是类class"></a>如何选择结构struct还是类class</h2><ol>
<li>堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。</li>
<li>结构表示如点、矩形和颜色这样的轻量对象。例如，如果声明一个含有 1000 个点对象的数组，则将为引用每个对象分配附加的内存。在此情况下，结构的成本较低。</li>
<li>在表现抽象和多级别的对象层次时，类是最好的选择。</li>
<li>大多数情况下该类型只是一些数据时，结构时最佳的选择。</li>
<li>堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。</li>
<li>结构表示如点、矩形和颜色这样的轻量对象。例如，如果声明一个含有 1000 个点对象的数组，则将为引用每个对象分配附加的内存。在此情况下，结构的成本较低。</li>
<li>在表现抽象和多级别的对象层次时，类是最好的选择。</li>
<li>大多数情况下该类型只是一些数据时，结构时最佳的选择。</li>
</ol>
<h2 id="抽象类（abstract-class）和接口（interface）的区别"><a href="#抽象类（abstract-class）和接口（interface）的区别" class="headerlink" title="抽象类（abstract class）和接口（interface）的区别"></a>抽象类（abstract class）和接口（interface）的区别</h2><p>抽象类：</p>
<ol>
<li>抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法。</li>
<li>抽象类不能被实例化。</li>
<li>抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类。</li>
<li>具体派生类必须覆盖基类的抽象方法。</li>
<li>抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们。</li>
</ol>
<p>接口：</p>
<ol>
<li>接口不能被实例化。</li>
<li>接口只能包含方法声明。</li>
<li>接口的成员包括方法、属性、索引器、事件。</li>
<li>接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员。</li>
<li>接口中的所有成员默认为public，因此接口中不能有private修饰符。</li>
<li>派生类必须实现接口的所有成员。</li>
<li>一个类可以直接实现多个接口，接口之间用逗号隔开。</li>
<li>一个接口可以有多个父接口，实现该接口的类必须实现所有父接口中的所有成员。</li>
</ol>
<p>抽象类和接口的异同：</p>
<p>相同点：</p>
<ol>
<li>都可以被继承。</li>
<li>都不能被实例化。</li>
<li>都可以包含方法声明。</li>
<li>派生类必须实现未实现的方法。</li>
</ol>
<p>区别：</p>
<ol>
<li>抽象基类可以定义字段、属性、方法实现。接口只能定义属性、索引器、事件、和方法声明，不能包含字段。</li>
<li>抽象类是一个不完整的类，需要进一步细化，而接口是一个行为规范。微软的自定义接口总是后带able字段，证明其是表述一类“我能做。。。”。</li>
<li>接口可以被多重实现，抽象类只能被单一继承。</li>
<li>抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中。</li>
<li>抽象类是从一系列相关对象中抽象出来的概念，因此反映的是事物的内部共性；接口是为了满足外部调用而定义的一个功能约定，因此反映的是事物的外部特性。</li>
<li>接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法。</li>
<li>接口可以用于支持回调,而继承并不具备这个特点。</li>
<li>抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的。</li>
<li>如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法。</li>
</ol>
<h3 id="什么是强类型"><a href="#什么是强类型" class="headerlink" title="什么是强类型"></a>什么是强类型</h3><p>为所有变量指定数据类型称为“强类型”。C#是强类型语言。</p>
<h3 id="什么是托管代码"><a href="#什么是托管代码" class="headerlink" title="什么是托管代码"></a>什么是托管代码</h3><p>使用基于公共语言运行库的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。</p>
<h3 id="什么是CLR？"><a href="#什么是CLR？" class="headerlink" title="什么是CLR？"></a>什么是CLR？</h3><p>CLR：公共语言运行库 Common Language Runtime。是一个运行时环境，它负责资源管理（内存分配和垃圾收集），并保证应用和底层操作系统之间必要的分离。</p>
<h3 id="C-中虚方法的底层实现"><a href="#C-中虚方法的底层实现" class="headerlink" title="C#中虚方法的底层实现"></a>C#中虚方法的底层实现</h3><h3 id="堆和栈的区别-详细说明"><a href="#堆和栈的区别-详细说明" class="headerlink" title="堆和栈的区别(详细说明)"></a>堆和栈的区别(详细说明)</h3><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="C-如何管理内存"><a href="#C-如何管理内存" class="headerlink" title="C++如何管理内存"></a>C++如何管理内存</h3><h3 id="C-引用和指针的区别"><a href="#C-引用和指针的区别" class="headerlink" title="C++引用和指针的区别"></a>C++引用和指针的区别</h3><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><h3 id="Lua框架？"><a href="#Lua框架？" class="headerlink" title="Lua框架？"></a>Lua框架？</h3><h3 id="XLua如何实现热更新？"><a href="#XLua如何实现热更新？" class="headerlink" title="XLua如何实现热更新？"></a>XLua如何实现热更新？</h3><h3 id="Lua如何实现面向对象？"><a href="#Lua如何实现面向对象？" class="headerlink" title="Lua如何实现面向对象？"></a>Lua如何实现面向对象？</h3><h3 id="Lua协程？"><a href="#Lua协程？" class="headerlink" title="Lua协程？"></a>Lua协程？</h3><h3 id="Lua-GC垃圾回收机制？"><a href="#Lua-GC垃圾回收机制？" class="headerlink" title="Lua GC垃圾回收机制？"></a>Lua GC垃圾回收机制？</h3><h3 id="Lua如何调用C-C-函数"><a href="#Lua如何调用C-C-函数" class="headerlink" title="Lua如何调用C/C++函数"></a>Lua如何调用C/C++函数</h3>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C#</a>
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 面试题</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="tag"># 编程基础</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2018/05/12/Unity3DStudy/Unity%E7%9B%B8%E5%85%B3/" rel="next" title="一些杂七杂八的Unity知识随笔">
      一些杂七杂八的Unity知识随笔 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="SOHUCS"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">编程语言学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.1.</span> <span class="nav-text">抽象类和接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98"><span class="nav-number">1.1.2.</span> <span class="nav-text">委托</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.3.</span> <span class="nav-text">结构体和类的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81C-%E8%AF%AD%E8%A8%80"><span class="nav-number">1.2.</span> <span class="nav-text">一、C#语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.</span> <span class="nav-text">重载和重写的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">简述值类型和引用类型有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0private%EF%BC%8Cpublic%EF%BC%8Cprotected%EF%BC%8Cinternal%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.3.</span> <span class="nav-text">请简述private，public，protected，internal的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E6%89%80%E6%9C%89%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.4.</span> <span class="nav-text">C#中所有引用类型的基类是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0-ArrayList-%E5%92%8C-List-lt-Int-gt-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.5.</span> <span class="nav-text">请简述 ArrayList 和 List&lt; Int &gt;的主要区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0-GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%B9%B6%E6%8F%8F%E8%BF%B0%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">1.2.6.</span> <span class="nav-text">请简述 GC（垃圾回收）产生的原因，并描述如何避免？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4namespace"><span class="nav-number">1.2.7.</span> <span class="nav-text">命名空间namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%8F%8F%E8%BF%B0-Interface-%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">1.2.8.</span> <span class="nav-text">请描述 Interface 与抽象类之间的不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B8%AD%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%87%A0%E4%B8%AA%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">1.2.9.</span> <span class="nav-text">下列代码在运行中会产生几个临时对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B8%AD%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">1.2.10.</span> <span class="nav-text">下列代码在运行中会发生什么问题？如何避免？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0%E5%85%B3%E9%94%AE%E5%AD%97-Sealed-%E7%94%A8%E5%9C%A8%E7%B1%BB%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%97%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.11.</span> <span class="nav-text">请简述关键字 Sealed 用在类声明和函数声明时的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">1.2.12.</span> <span class="nav-text">反射的实现原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Net-%E4%B8%8E-Mono-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.2.13.</span> <span class="nav-text">.Net 与 Mono 的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%89%8D%E5%8A%A0%E4%B8%8A-static-%E4%BC%9A%E6%8A%A5%E4%BB%80%E4%B9%88%E9%94%99-%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.14.</span> <span class="nav-text">在类的构造函数前加上 static 会报什么错?为什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-String-%E7%B1%BB%E5%9E%8B%E6%AF%94-stringBuilder-%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.2.15.</span> <span class="nav-text">C# String 类型比 stringBuilder 类型的优势是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%87%BD%E6%95%B0-Func-string-a-string-b-%E7%94%A8-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%8E%E4%B9%88%E5%86%99"><span class="nav-number">1.2.16.</span> <span class="nav-text">C# 函数 Func(string a, string b)用 Lambda 表达式怎么写?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F%E5%BC%B1%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%BC%B1%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%BA%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.17.</span> <span class="nav-text">什么是弱引用？弱引用的使用和作用？弱引用和强引用的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.18.</span> <span class="nav-text">Using的使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BB%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.19.</span> <span class="nav-text">C#中有哪些常用的容器类，各有什么特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%B8%B8%E8%A7%84%E5%AE%B9%E5%99%A8%E5%92%8C%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%93%AA%E7%A7%8D%E6%95%88%E7%8E%87%E9%AB%98%EF%BC%9F"><span class="nav-number">1.2.20.</span> <span class="nav-text">C#中常规容器和泛型容器有什么区别，哪种效率高？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E5%80%BC%E7%B1%BB%EF%BC%9F"><span class="nav-number">1.2.21.</span> <span class="nav-text">有哪些常见的数值类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E5%A7%94%E6%89%98%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%90%84%E7%94%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E5%90%88%EF%BC%9F"><span class="nav-number">1.2.22.</span> <span class="nav-text">C#中委托和接口有什么区别？各用在什么场合？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%ADunsafe%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E4%BB%80%E4%B9%88%E5%9C%BA%E5%90%88%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">1.2.23.</span> <span class="nav-text">C#中unsafe关键字是用来做什么的？什么场合下使用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#For%EF%BC%8Cforeach%EF%BC%8CEnumerator-MoveNext%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8E%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97%E6%83%85%E5%86%B5"><span class="nav-number">1.2.24.</span> <span class="nav-text">For，foreach，Enumerator.MoveNext的使用，与内存消耗情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A4%9A%E6%AC%A1%E4%BD%BF%E7%94%A8string%E7%9A%84-%E5%A4%84%E7%90%86%EF%BC%8C%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%A4%A7%E9%87%8F%E5%86%85%E5%AD%98%E5%9E%83%E5%9C%BE%EF%BC%88%E5%9E%83%E5%9C%BE%E7%A2%8E%E7%89%87%EF%BC%89%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3"><span class="nav-number">1.2.25.</span> <span class="nav-text">函数中多次使用string的+&#x3D;处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E9%9C%80%E8%A6%81%E9%A2%91%E7%B9%81%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E6%9D%A5%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">1.2.26.</span> <span class="nav-text">当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT-%E5%92%8CAOT%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.27.</span> <span class="nav-text">JIT 和AOT区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%98%E6%94%BE%E5%8F%82%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.28.</span> <span class="nav-text">给定一个存放参数的数组，重新排列数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Foreach%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%E6%97%B6%EF%BC%8C%E8%8B%A5%E6%8A%8A%E5%85%B6%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4%EF%BC%8C%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99%EF%BC%8C%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E9%82%A3%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%85%B7%E4%BD%93%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9F-%E6%B3%A8%EF%BC%9ATry%E2%80%A6-Catch%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E4%B8%8D%E5%8F%AF%E8%A1%8C"><span class="nav-number">1.2.29.</span> <span class="nav-text">Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？(注：Try…..Catch捕捉异常，发送信息不可行)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GameObject-a-new-GameObject-GameObject-b-a-%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%87%BA%E6%9D%A5%E4%BA%86A%EF%BC%8C%E5%B0%86A%E8%B5%8B%E7%BB%99B%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%B0%86B%E5%88%A0%E9%99%A4%EF%BC%8C%E9%97%AEA%E8%BF%98%E5%AD%98%E5%9C%A8%E5%90%97%EF%BC%9F"><span class="nav-number">1.2.30.</span> <span class="nav-text">GameObject a&#x3D;new GameObject()  GameObject b&#x3D;a  实例化出来了A，将A赋给B，现在将B删除，问A还存在吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.31.</span> <span class="nav-text">C#面向对象三大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E8%99%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.32.</span> <span class="nav-text">抽象方法和虚方法的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99-override"><span class="nav-number">1.2.33.</span> <span class="nav-text">重写(override)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E9%9B%86%E5%90%88"><span class="nav-number">1.3.</span> <span class="nav-text">C#集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.1.</span> <span class="nav-text">动态数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8HashTable%EF%BC%9A%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%BB%E4%BD%95%E9%9C%80%E8%A6%81%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">1.3.2.</span> <span class="nav-text">哈希表HashTable：键值对，适用于任何需要提高效率的地方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%92%8C%E5%AD%97%E5%85%B8%E6%AF%94%E8%B5%B7%E6%9D%A5%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%EF%BC%9F"><span class="nav-number">1.3.3.</span> <span class="nav-text">哈希表和字典比起来怎么样？什么时候用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E5%88%97%E8%A1%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">排序列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E6%A0%88"><span class="nav-number">1.3.5.</span> <span class="nav-text">堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">1.3.6.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E9%98%B5%E5%88%97"><span class="nav-number">1.3.7.</span> <span class="nav-text">点阵列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.3.8.</span> <span class="nav-text">C#泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.3.9.</span> <span class="nav-text">C#事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assembly-Defination"><span class="nav-number">1.3.10.</span> <span class="nav-text">Assembly Defination</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Switch-case%E7%9A%84%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88"><span class="nav-number">1.3.11.</span> <span class="nav-text">Switch case的替换方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0%E6%8B%86%E7%AE%B1%E5%92%8C%E8%A3%85%E7%AE%B1"><span class="nav-number">1.4.</span> <span class="nav-text">请简述拆箱和装箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%EF%BC%8Cstring-str-null-%E4%B8%8E-string-str-%E2%80%9C%E2%80%9D%EF%BC%8C%E8%AF%B4%E6%98%8E%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">C#中，string str &#x3D; null 与 string str &#x3D; “”，说明区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref%E4%B8%8Eout%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.6.</span> <span class="nav-text">ref与out关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="nav-number">1.7.</span> <span class="nav-text">什么是序列化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sealed-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="nav-number">1.8.</span> <span class="nav-text">sealed 修饰符有什么特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class%E5%92%8Cstruct%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.9.</span> <span class="nav-text">class和struct的异同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84struct%E8%BF%98%E6%98%AF%E7%B1%BBclass"><span class="nav-number">1.10.</span> <span class="nav-text">如何选择结构struct还是类class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%88abstract-class%EF%BC%89%E5%92%8C%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.11.</span> <span class="nav-text">抽象类（abstract class）和接口（interface）的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.11.1.</span> <span class="nav-text">什么是强类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81"><span class="nav-number">1.11.2.</span> <span class="nav-text">什么是托管代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCLR%EF%BC%9F"><span class="nav-number">1.11.3.</span> <span class="nav-text">什么是CLR？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E8%99%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.11.4.</span> <span class="nav-text">C#中虚方法的底层实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="nav-number">1.11.5.</span> <span class="nav-text">堆和栈的区别(详细说明)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C"><span class="nav-number">1.12.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-number">1.12.1.</span> <span class="nav-text">C++如何管理内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.12.2.</span> <span class="nav-text">C++引用和指针的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lua"><span class="nav-number">1.13.</span> <span class="nav-text">Lua</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lua%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="nav-number">1.13.1.</span> <span class="nav-text">Lua框架？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XLua%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%9F"><span class="nav-number">1.13.2.</span> <span class="nav-text">XLua如何实现热更新？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lua%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">1.13.3.</span> <span class="nav-text">Lua如何实现面向对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lua%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.13.4.</span> <span class="nav-text">Lua协程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lua-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">1.13.5.</span> <span class="nav-text">Lua GC垃圾回收机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lua%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8C-C-%E5%87%BD%E6%95%B0"><span class="nav-number">1.13.6.</span> <span class="nav-text">Lua如何调用C&#x2F;C++函数</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">VisionXie</p>
  <div class="site-description" itemprop="description">生活在树上，始终热爱大地，升入天空。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VisionXie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <script>
  NexT.utils.loadComments(document.querySelector('#SOHUCS'), () => {
    var appid = 'cyvS0HjaG';
    var conf = '26c6eae6e21dfb5a6535a5e53425e9ec';
    var width = window.innerWidth || document.documentElement.clientWidth;
    if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
    } else {
      var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})});
    }
  });
  </script>
  <script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>

</body>
</html>
