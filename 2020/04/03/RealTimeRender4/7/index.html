<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第7章 阴影 Chapter 7 Shadows“所有的变化，所有的魅力，所有的美丽 生活是由光与影组成的。” —— 托尔斯泰">
<meta property="og:type" content="article">
<meta property="og:title" content="RealTimeRendering 7">
<meta property="og:url" content="http://example.com/2020/04/03/RealTimeRender4/7/index.html">
<meta property="og:site_name" content="XiMo">
<meta property="og:description" content="第7章 阴影 Chapter 7 Shadows“所有的变化，所有的魅力，所有的美丽 生活是由光与影组成的。” —— 托尔斯泰">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201015193500483.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201015193738697.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201015200303568.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20p_%7Bz%7D%3D%28l_%7By%7D-v_%7Bz%7D%29/%28l_%7By%7D-v_%7By%7D%29">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7BM%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201015200509273.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201015200623178.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201015200909802.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201015200942813.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202010161940506.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201016200131843.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201019120142257.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201018230600921.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201018234427936.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201019122735422.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201019130621415.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D_%7Ba%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20a">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D_%7Ba%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D_%7Bb%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20b">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201019131517205.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201019132616246.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201019211741931.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201019212713192.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201020135045664.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201020135544526.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201020212115548.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201020212511437.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201020212927830.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201020213340745.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201020214024960.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201021133803674.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201021204115215.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201021204400419.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201021203805597.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020102215021243.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201021211007217.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?d_%7Br%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20M_%7B1%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20t">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201022202103843.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20p_%7Bmax%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%5Csigma%20%5E%7B2%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20t">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20M_%7B1%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20M_%7B2%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201022203223724.png">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20p_%7Bmax%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20p">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20p%3Dp_%7Bmax%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20%28t-M_%7B1%7D%29%5E%7B2%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20p_%7Bmax%7D">
<meta property="og:image" content="https://private.codecogs.com/gif.latex?%5Clarge%20p_%7Bmax%7D">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201022212611925.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201022212811180.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201022215837688.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201023134238742.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201023192754240.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201023195505906.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020102320245778.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20201023202825479.png">
<meta property="article:published_time" content="2020-04-03T16:00:00.000Z">
<meta property="article:modified_time" content="2021-05-09T16:00:00.000Z">
<meta property="article:author" content="VisionXie">
<meta property="article:tag" content="渲染">
<meta property="article:tag" content="RealTimeRendering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20201015193500483.png">

<link rel="canonical" href="http://example.com/2020/04/03/RealTimeRender4/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RealTimeRendering 7 | XiMo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XiMo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">醉后不知天在水，满船清梦压星河。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>All<span class="badge">30</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/03/RealTimeRender4/7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="VisionXie">
      <meta itemprop="description" content="生活在树上，始终热爱大地，升入天空。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiMo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RealTimeRendering 7
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-04 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-04T00:00:00+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-10 00:00:00" itemprop="dateModified" datetime="2021-05-10T00:00:00+08:00">2021-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RealTimeRendering/" itemprop="url" rel="index"><span itemprop="name">RealTimeRendering</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    
      <a title="changyan" href="/2020/04/03/RealTimeRender4/7/#SOHUCS" itemprop="discussionUrl">
        <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2020/04/03/RealTimeRender4/7/" itemprop="commentCount"></span>
      </a>
    
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第7章-阴影-Chapter-7-Shadows"><a href="#第7章-阴影-Chapter-7-Shadows" class="headerlink" title="第7章 阴影 Chapter 7 Shadows"></a><strong>第7章 阴影</strong> <strong>Chapter 7 Shadows</strong></h1><p><strong>“所有的变化，所有的魅力，所有的美丽 生活是由光与影组成的。”</strong> —— 托尔斯泰</p>
<span id="more"></span>
<p>阴影对于创建真实的图像以及为用户提供有关对象放置感的视觉提示非常重要。本章重点介绍计算阴影的基本原理，并介绍最重要和最受欢迎的实时算法。我们还将简要讨论不太流行但体现重要原理的方法。在本章中，我们不会花时间讨论所有的选择和方法，因为已有两本全面的书深入研究了阴影领域  <strong>[412，1902]</strong> 。相反，我们专注于研究一些文章和演示，并且偏向于那些经过实战测试的技术。</p>
<p>在本章中使用的术语如图 7.1 所示，其中遮挡物（occluders）是将阴影投射到接收器（receivers）上的对象。精确光源（Punctual light sources），即没有面积的光源，只会产生完全阴影的区域，有时也称为硬阴影（hard shadows）。如果使用区域光（area light）或体积光（volume light），则会产生柔和的阴影。这样，每个阴影都可以具有称为“本影”（umbra）的完全阴影区域和称为“半影”（penumbra）的部分阴影区域。拥有模糊边缘的阴影，是软阴影。但是，重要的是要注意，通常仅使用低通滤波器去模糊硬阴影的边缘是无法正确渲染软阴影的。从图 7.2 可以看出，正确的软阴影越接近阴影投射几何形状，就越清晰。软阴影的本影区域并不等于由点光源产生的硬阴影。取而代之的是，随着光源的变大，软阴影的本影区域的面积会减小，并且在光源足够大且接收器距离遮挡物足够远的情况下，它甚至可能消失。通常更偏好使用软阴影，因为半阴影边缘会让观察者知道阴影确实是阴影。硬边缘的阴影通常看起来不太真实，有时可能被观察者误解为实际的几何特征，例如表面上的折痕。但是，硬阴影比软阴影的渲染速度更快。</p>
<img alt="" height="343" src="https://img-blog.csdnimg.cn/20201015193500483.png" width="711">

<blockquote>
<p>图 7.1  阴影术语：光源，遮挡物，接收器，阴影，本影和半影。</p>
</blockquote>
<img alt="" height="595" src="https://img-blog.csdnimg.cn/20201015193738697.png" width="738">

<blockquote>
<p>图 7.2  硬阴影和软阴影的混合。由于遮挡物靠近接收器，因此板条箱的阴影很锐利。该人的阴影在接触点处很锐利，随着与封堵器距离的增加而变柔和。遥远的树枝给人柔和的阴影 <strong>[1711]</strong> 。（图片来自“全境封锁”，“Tom Clancy’s The Division”，由育碧提供。）</p>
</blockquote>
<p>比实现半影更重要的是要有阴影。没有一些阴影作为视觉提示，场景效果通常令人难以信服，并且更难以感知。正如 Wanger  <strong>[1846]</strong> 所言，不准确的阴影通常比根本没有阴影要好，因为眼睛对阴影的形状相当宽容。例如，在地板上用作纹理的模糊黑色圆片就可以让人觉得角色是固定在地面上。</p>
<p>在以下各节中，我们将介绍这些简单的阴影模型，并介绍从场景中的遮挡物实时自动自动计算阴影的方法。第一部分处理在平面上投射阴影的特殊情况，第二部分介绍更通用的阴影算法，即将阴影投射到任意表面上。硬阴影和软阴影都将被提及。最后，本章会提出一些适用于各种阴影算法的优化技术。</p>
<h2 id="7-1-平面阴影-Planar-Shadows"><a href="#7-1-平面阴影-Planar-Shadows" class="headerlink" title="7.1 平面阴影 Planar Shadows"></a>7.1 平面阴影 Planar Shadows</h2><p>当对象将阴影投射到平面上时，就会产生简单的阴影。本节介绍了几种用于平面阴影的算法，每种算法在阴影的柔和度和真实度上都有所不同。</p>
<h3 id="7-1-1-投射阴影-Projection-Shadows"><a href="#7-1-1-投射阴影-Projection-Shadows" class="headerlink" title="7.1.1 投射阴影 Projection Shadows"></a>7.1.1 投射阴影 Projection Shadows</h3><p>在此方案中，三维对象会进行第二次渲染以创建阴影。我们可以推导出将对象的顶点投影到平面上的矩阵  <strong>[162，1759]</strong> 。参考图 7.3 中的情况，其中光源位于 l 处，要投影的顶点在 v 处，而投影的顶点在 p 处。对于阴影平面为 y = 0 的特殊情况，我们将推导出投影矩阵，然后将该结果推广到适用于任何平面。</p>
<p>我们首先推导 x 坐标的投影。从图 7.3 左侧的相似三角形中，我们得到</p>
<img alt="" height="68" src="https://img-blog.csdnimg.cn/20201015200303568.png" width="593">

<p>以相同的方式获得 z 坐标：<img alt="\large p_{z}=(l_{y}-v_{z})/(l_{y}-v_{y})" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20p_%7Bz%7D%3D%28l_%7By%7D-v_%7Bz%7D%29/%28l_%7By%7D-v_%7By%7D%29">，而 y 坐标为零。现在，这些方程式可以转换为投影矩阵 <img alt="\large \textbf{M}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7BM%7D">：</p>
<img alt="" height="121" src="https://img-blog.csdnimg.cn/20201015200509273.png" width="501">

<p>验证 Mv = p 很简单，这意味着 M 确实是投影矩阵。</p>
<img alt="" height="293" src="https://img-blog.csdnimg.cn/20201015200623178.png" width="740">

<blockquote>
<p>图 7.3  左：位于 l 处的光源将阴影投射到平面 y = 0 上。顶点 v 投射到平面上。投影点称为 p。相似的三角形用于投影矩阵的推导。右：阴影正在投射到一个平面上，π：n·x + d = 0。</p>
</blockquote>
<p>在一般情况下，应将阴影投射到的平面并不是平面 y = 0，而是 π：n·x + d =0。这种情况在图 7.3 的右侧部分进行了描述。接下来的目标是找到一个将 v 投影到 p 的矩阵。为此，在 l 处发出的，穿过 v 的光线与平面 π 相交。得出投影点 p：</p>
<img alt="" height="65" src="https://img-blog.csdnimg.cn/20201015200909802.png" width="507">

<p>该方程式也可以转换成投影矩阵，如方程式 7.4 所示，满足Mv = p：</p>
<img alt="" height="122" src="https://img-blog.csdnimg.cn/20201015200942813.png" width="709">

<p>如预期的那样，如果平面为 y = 0，即 n =（0,1,0）且 d = 0，则此矩阵变为公式 7.2 中的矩阵。</p>
<p>要渲染阴影，只需将此矩阵应用于应该在平面 π 上投影阴影的对象，然后使用深色且无照明的方式渲染此投影对象。在实践中，必须采取措施避免将投影的三角形渲染到接收三角形的曲面下方。一种方法是在投影的平面上增加一些偏差（bias），以使阴影三角形始终呈现在曲面的前面。</p>
<p>一种更保险的方法是先绘制地面，然后在关闭 z 缓冲区的情况下绘制投影的三角形，然后照常渲染其余的几何图形。然后，由于不进行深度比较，因此总是会将投影的三角形绘制在地面的顶部。</p>
<p>如果地面是有限的（例如，它只是一个矩形），则投影的阴影可能会落在其外部，从而破坏视觉效果。为了解决这个问题，我们可以使用模板缓冲区。首先，将接收器放到屏幕和模板缓冲区中。然后，在关闭 z 缓冲区的情况下，仅在绘制接收器的位置绘制投影的三角形，然后再正常渲染场景的其余部分。</p>
<p>另一种阴影算法是将三角形渲染为纹理，然后将其应用于地面。这种纹理是一种光照贴图（light map），它是一种调节底层表面光照强度的纹理（第 11.5.1 节）。可以看出，这种将阴影投影渲染为纹理的想法还允许在曲面上产生半影和阴影。该技术的一个缺点是纹理可能被放大，结果造成单个纹理像素覆盖多个像素，从而破坏视觉效果。</p>
<p>如果阴影的情况在帧与帧之间没有变化，即光和阴影投射器之间没有相对移动，则可以重新使用此纹理。另外，如果阴影没有发生变化，那么大多数阴影技术都可以受益于帧与帧之间重用中间计算结果。</p>
<p>所有的阴影投射器必须位于灯光和地面接收器之间。如果光源在对象的最高点之下，则会生成反阴影（antishadow）  <strong>[162]</strong> ，因为每个顶点都投影到光源的点上。正确的阴影和反阴影如图 7.4 所示。如果我们在接收平面下方投影一个对象，也会发生错误，因为它也不应该投射阴影。</p>
<p>当然我们可以明确地剔除和修整阴影三角形以避免此类伪像。接下来，一个更简单的方法是使用现有的 GPU 流水线来执行带有裁剪的投影。</p>
<img alt="" height="348" src="https://img-blog.csdnimg.cn/202010161940506.png" width="737">

<blockquote>
<p>图 7.4 在左侧，显示了正确的阴影，而在右侧图中，由于光源位于对象的最高顶点之下，因此出现了反阴影。</p>
</blockquote>
<h3 id="7-1-2-软阴影-Soft-Shadows"><a href="#7-1-2-软阴影-Soft-Shadows" class="headerlink" title="7.1.2 软阴影 Soft Shadows"></a>7.1.2 软阴影 Soft Shadows</h3><p>通过使用多种技术，也可以使投射阴影变柔和。在这里，我们描述了一种来自 Heckbert 和 Herf <strong>[697，722]</strong> 的算法，该算法会生成柔和的阴影。该算法的目标是在地面上显示柔和阴影纹理。然后，接下来我们就将描述这种精度较低，速度较快的方法。</p>
<p>只要光源是有一定面积的，不是单个点，那么就会出现柔和的阴影。一种产生这种近似区域光效果的方法是通过使用放置在其表面上的多个点光源对其进行采样。对于每个精确光源，图像都会被渲染并累积到缓冲区中。这些图像的平均值就是带有柔和阴影的图像。请注意，从理论上讲，任何生成硬阴影的算法都可以与这种累积技术一起使用，以产生半影。实际上，由于涉及执行时间，因此以实时渲染交互速率来进行这种操作通常是不可行的。</p>
<p>Heckbert 和 Herf 使用基于视锥的方法生成阴影。思路是将光视为观察者，并且地面形成了视锥的远剪切平面。而视锥体的宽度已足够容纳遮挡物。</p>
<p>通过生成一系列地面纹理的采样计算，可以形成柔和的阴影纹理。面光源在其表面上进行采样，每个位置都用于对替代地面的图像进行着色处理，然后将投射阴影对象投影到该图像上。将所有这些图像相加并取平均值，以生成地面上的阴影纹理。有关示例，请参见图  7.5 的左侧。</p>
<img alt="" height="313" src="https://img-blog.csdnimg.cn/20201016200131843.png" width="734">

<blockquote>
<p>图  7.5   左侧是使用 Heckbert 和 Herf 方法进行的渲染，使用了 256 次渲染。右边是 Haines 的方法。使用 Haines 方法时，本影尤其醒目，这在门口和窗户周围尤为明显。</p>
</blockquote>
<p>采样面积光方法的一个问题是，它看起来像点光源发出的多个重叠阴影。此外，对于 n 次阴影遍历，只能生成 n + 1 个不同的阴影。大量的阴影采样可以得到准确的结果，但是要付出高昂的消耗。该方法可用于获取（字面上的）“真实地面” 图像，以对比测试其他更快算法的质量。</p>
<p>一种更有效的方法是使用卷积，即滤波。在某些情况下，对单个点生成的硬阴影进行模糊处理就足够了，并且能生成可与实际内容结合的半透明纹理。参见图 7.6。但是，在物体与地面接触的位置附近出现均匀的模糊可能无法令人信服。</p>
<img alt="" height="440" src="https://img-blog.csdnimg.cn/20201019120142257.png" width="738">

<blockquote>
<p>图 7.6  落地阴影（Drop shadow）。通过从上方渲染阴影投射器，然后模糊图像并将其渲染在地平面上，可以生成阴影纹理。（图像是在Autodesk的A360查看器中生成的，该图像来自Autodesk的Inventor示例。）</p>
</blockquote>
<p>还有许多其他方法可以提供更好的近似效果，但需要额外的消耗。例如，Haines  <strong>[644]</strong> 从投影的硬阴影开始，接下来用从中央的暗部到边缘的白色的渐变来渲染轮廓边缘，以创建合理的半影。参见图 7.5 的右侧。但是，这些半影在物理上是不正确的，因为它们还应该延伸到轮廓边缘内的区域。Iwanicki  <strong>[356，806]</strong> 借鉴了球谐函数的思想，并用椭圆体近似去遮挡角色以产生柔和的阴影。所有这些方法都有各种近似和缺点，但是都比对大量阴影图像进行平均处理要有效得多。</p>
<h2 id="7-2-曲面上的阴影-Shadows-on-Curved-Surfaces"><a href="#7-2-曲面上的阴影-Shadows-on-Curved-Surfaces" class="headerlink" title="7.2 曲面上的阴影 Shadows on Curved Surfaces"></a>7.2 曲面上的阴影 Shadows on Curved Surfaces</h2><p>将平面阴影的概念扩展到曲面的一种简单方法是将生成的阴影图像用作投影纹理  <strong>[1192、1254、1272、1597]</strong> 。从光作为观察者的角度考虑阴影。无论从光的视角看到了什么，那么就都会照亮；光所看不见的东西，就处在阴影中。那么我们从从光源的角度来看，遮挡物就会被渲染为黑色，否则的话就呈现白色纹理。然后可以将此纹理投影到要接收阴影的表面上。事实上，接收器上的每个顶点都有一个为其计算的（u，v）纹理坐标，并对其应用了纹理。这些纹理坐标可以由应用程序显式地进行计算。这与上一部分中提到的的地面阴影纹理有所不同，在前一部分中，对象被投影到特定的物理平面上。在这里，图像是从光的角度看的，就像放映机中的胶卷一样。</p>
<p>渲染时，投影的阴影纹理会改变接收器的表面。它也可以与其他阴影方法结合使用，有时主要用于帮助感知对象的位置。例如，在跳跃平台游戏中，即使角色处于完全阴影状态，也可能总是在其正下方给主角一个投影 <strong>[1343]</strong> 。其他更精确的算法可以带来更好的结果。例如，Eisemann 和 D´ecoret <strong>[411]</strong> 假定使用矩形顶灯，并创建关于对象的水平截面的阴影图像堆栈，然后将其转换为 mipmap 或类似图像。通过使用其 mipmap，可以按照与截面到接收器的距离成比例的方式访问每个截面的相应区域，这意味着距离较远的截面将投射更柔和的阴影。</p>
<p>纹理投影方法有一些严重的缺点。首先，应用程序必须标识哪些对象是遮挡物，哪些是它们的接收器。程序必须将接收器保持在距离遮挡物较远的地方，否则阴影将“向后投射”。此外，遮挡对象也无法对自身产生阴影。接下来的两个部分介绍了无需这种干预或限制即可生成正确阴影的算法。</p>
<p>请注意，通过使用预构建的投影纹理可以获得各种照明图案。聚光灯只是一个正方形投影的纹理，并且在其中的一个圆中定义了光源。可以通过由水平线组成的投影纹理来创建百叶帘效果。这种纹理称为光衰减蒙版（light attenuation mask），Cookie 纹理（cookie texture）或戈波贴图（gobo map）。只需将两个纹理相乘即可将预建图案与动态创建的投影纹理相结合。在第 6.9 节中将进一步讨论此类指示灯。</p>
<h2 id="7-3-阴影体-Shadow-Volumes"><a href="#7-3-阴影体-Shadow-Volumes" class="headerlink" title="7.3 阴影体 Shadow Volumes"></a>7.3 阴影体 Shadow Volumes</h2><p>一种基于 Crow 的阴影体（shadow volumes）的方法  <strong>[311]</strong> 可以通过巧妙地使用模板缓冲区将阴影投射到任意对象上，这是由海德曼（Heidmann）在 1991 年提出的  <strong>[701]。</strong>它可以在任何 GPU 上使用，因为唯一的要求就是模板缓冲区。它不是基于图像的（不同于下面描述的阴影贴图算法），因此避免了采样问题，从而在各处产生正确的清晰阴影。但有时这可能是一个缺点。例如，角色的服装可能会折叠起来，形成薄而硬的阴影，从而严重走样。由于阴影体的性能成本不可预测，因此如今很少使用它们 <strong>[1599]</strong> 。我们在这里对算法进行简要说明，因为它说明了一些重要的原理，并在此基础上继续进行研究。</p>
<p>首先，想象一个点和一个三角形。将线从点延伸到三角形的顶点到无穷远会产生一个无限的三棱锥。三角形下面的部分，即不包括该点的部分，是一个截断的无限金字塔，而上部只是一个金字塔。如图 7.7 所示。现在想象一下，该点实际上是一个点光源。然后，位于截断的金字塔体内部（在三角形下方）的对象的任何部分都处于阴影中。该部分体积称为阴影体（shadow volume）。</p>
<img alt="" height="315" src="https://img-blog.csdnimg.cn/20201018230600921.png" width="736">

<blockquote>
<p>图 7.7  左：来自点光源的线延伸穿过三角形的顶点以形成无限金字塔。右图：上部是金字塔，下部是无限的截头金字塔，也称为阴影体。阴影体内的所有几何图形均处于阴影中。</p>
</blockquote>
<p>假设我们查看某个场景，然后从眼睛通过像素追踪光线，直到光线照射到要在屏幕上显示的对象。当光线在到达该对象的途中时，每当光线穿过阴影体的面向正面（即面向观察者）的面时，我们都会增加一个计数器。因此，每次光线进入阴影时，计数器都会增加。以相同的方式，每当光线穿过截顶的金字塔的背面时，我们便减小相同的计数器。然后，光线从阴影中射出。我们继续进行操作，增加和减少计数器，直到射线照射到要显示在该像素上的对象。如果计数器大于零，则该像素处于阴影中；否则，该像素不在阴影中。当有多个三角形投射阴影时，此原理也适用。参见图 7.8。</p>
<img alt="" height="397" src="https://img-blog.csdnimg.cn/20201018234427936.png" width="731">

<blockquote>
<p>图 7.8 使用两种不同的计数方法对阴影-体积交叉点进行计数的二维侧视图。在 z 遍体积计数中，当光线穿过阴影体的正面三角形时，计数会增加，而在穿过背面三角形时，计数会减小。因此，在点 A，射线进入两个阴影体为+2，然后离开两个阴影体，净计数为零，因此该点处于光照状态。在 z-fail 体积计数中，计数从表面开始（这些计数以斜体显示）。对于点 B 处的射线，z 传递方法通过穿过两个正面三角形给出 +2 计数，而 z-fail 方法通过穿过两个背面三角形给出相同的计数。点 C 显示了必须限制 z-fail 阴影体的大小。从点 C 开始的光线首先到达正面三角形，为-1。然后，它退出两个阴影体（通过它们的底面，这是该方法正常工作所必需的），净计数为+1。计数不为零，所以该点在阴影中。两种方法都始终为所查看曲面上的所有点提供相同的计数结果。</p>
</blockquote>
<p>用射线进行此操作很耗时。但是有一个更聪明的解决方案 <strong>[701]</strong> ：模板缓冲区可以为我们做计数。第一，清除模板缓冲区。第二，将整个场景仅使用未照明材质的颜色绘制到帧缓冲区中，以将这些阴影分量存储在颜色缓冲区中，并将深度信息获取到 z 缓冲区中。第三，关闭 z 缓冲区更新和写入颜色缓冲区（尽管仍会进行 z 缓冲区测试），之后再绘制阴影体的正面三角形。在此过程中，将模板操作设置为在绘制三角形的任何地方增加模板缓冲区中的值。第四，使用模板缓冲区进行另一遍处理，这次仅绘制阴影体的背面三角形。对于此过程，绘制三角形时，模版缓冲区中的值将减小。仅当渲染的阴影体的面的像素可见（即，未被任何实际几何图形遮盖）时，才进行增量和减量。此时，模板缓冲区将为每个像素保留阴影状态。最后，再次渲染整个场景，这次仅使用受光影响的材质的参数，并且仅在模板缓冲区中的值为 0 的位置显示。值为 0 表示光线脱离阴影体的次数与进入阴影体的次数相同，即该位置会被光线照亮。</p>
<p>这种计数方法是阴影体方法背后的基本思想。阴影体算法生成的阴影示例如图 7.9 所示。有一些有效的方法可以在单遍中实现该算法  <strong>[1514]</strong> 。但是，当物体穿透相机的近平面时，就会发生计数问题。该解决方案称为 z-fail，涉及计算隐藏在可见表面后面而不是前面的交叉点  <strong>[450，775]</strong> 。图 7.8 给出了这种方法的简要概述。</p>
<img alt="" height="270" src="https://img-blog.csdnimg.cn/20201019122735422.png" width="737">

<blockquote>
<p>图 7.9 阴影体。在左侧，角色投射阴影。右侧显示了模型的拉伸三角形。（来自Microsoft SDK  <strong>[1208]</strong> 的图像示例“ Shadow Volume”。）</p>
</blockquote>
<p>为每个三角形创建四边形会产生大量的 overdraw。也就是说，每个三角形将创建三个必须渲染的四边形。由一千个三角形组成的球体将创建三千个四边形，并且这些四边形中的每一个都可以跨越屏幕。一种解决方案是沿对象的轮廓边缘仅绘制那些四边形，例如，我们的球体可能仅具有五十个轮廓边，因此仅需要五十个四边形。几何着色器可用于自动生成此类轮廓边  <strong>[1702]</strong> 。剔除（culling）和夹取（clamping）技术还可用于降低填充成本 <strong>[1061]</strong> 。</p>
<p>但是，阴影体算法仍然有一个可怕的缺点：极端的可变性。想象一下有一个单一的小三角形。如果摄像机和光源的位置完全相同，则阴影体的成本将降至最低。所形成的四边形不会覆盖任何像素，因为它们在视图上处于边缘位置。只有三角形本身很重要。假设观众现在绕着三角形旋转，并保持在可见状态。随着摄像机远离光源，阴影体的四边形将变得更加可见，并覆盖更多的屏幕，从而导致更多的计算发生。如果观察者者碰巧进入了三角形的阴影，则阴影体积将完全填满屏幕，与原始视图相比，需要花费大量时间进行计算。这种可变性使阴影体无法在交互式应用中使用，在这些应用中，稳定的帧率很重要。与其他情况一样，朝着光线观察可能会导致算法成本发生巨大且无法预测的跳跃性变化。</p>
<p>由于以上这些原因，阴影体在很大程度上已被应用程序所放弃。但是，鉴于不断有新的和不同的方式来访问 GPU 上的数据，并且研究人员巧妙地重新利用了这种功能，阴影体可能在某一天会重新投入使用。例如，Sintorn等人  <strong>[1648]</strong> 给出了阴影体算法的概述，该算法提高了效率并提出了自己的分层加速结构。</p>
<p>我们下一个要呈现的算法，阴影贴图，具有可预测的性能消耗，并且非常适合 GPU，因此构成了许多应用程序中阴影生成的基础。</p>
<h2 id="7-4-阴影贴图-Shadow-Maps"><a href="#7-4-阴影贴图-Shadow-Maps" class="headerlink" title="7.4 阴影贴图 Shadow Maps"></a>7.4 阴影贴图 Shadow Maps</h2><p>1978年，Williams <strong>[1888]</strong> 提出可以使用基于 z 缓冲区的通用渲染器在任意对象上快速生成阴影。这个想法是使用 z 缓冲区从要投射阴影的光源位置去渲染场景。光所“看到”的部分会被照亮，其余的都在阴影中。生成此图像时，仅需要 z 缓冲。照明，纹理化，将值写入颜色缓冲区，这三个步骤可以被关闭 。</p>
<p>现在，z 缓冲区中的每个像素都包含最靠近光源的对象的 z 深度。我们将 z 缓冲区的全部内容称为阴影贴图（shadow map），有时也称为阴影深度图（shadow depth map）或阴影缓冲区（shadow buffer）。要使用阴影贴图，场景会进行第二次渲染，但这次是相对于观察者的渲染。渲染每个绘图图元时，会将它在每个像素处的位置与阴影贴图进行比较。如果渲染的点比阴影贴图中的对应值更远离光源，则该点在阴影中，否则就不在阴影中。我们通过使用纹理映射来实现此技术。参见图 7.10。阴影贴图是一种流行的算法，因为它是相对可预测的。建立阴影贴图的成本与渲染图元的数量大致成线性关系，并且访问的时间是恒定的。阴影贴图可以一次生成，并且可以在光线和对象不移动的场景（例如计算机辅助设计）的每一帧中重复使用。</p>
<p>当生成单个 z 缓冲区时，灯光只能像摄像机一样在特定方向上“看”。对于诸如太阳之类的远距离方向光，该光的观察角度会设置为包含所有将阴影投射到眼睛所见的视锥体中的对象。如果光线使用正交投影，那么其视线必须在 x 和 y 方向足够宽且足够高才能看到这组对象。局部光源需要尽可能进行类似的调整。如果局部光源距离阴影投射对象足够远，则单个视锥体就足以包含所有这些内容。或者，如果局部光源是聚光灯，则它具有与之相关的天然视锥体，并且视锥体外的所有内容都不会被照亮。</p>
<p>如果局部光源在场景内部并且被阴影投射器包围，则典型的解决方案是使用六视图立方体，这类似于立方体环境映射  <strong>[865]</strong> 。这些六视图立方体被称为全向阴影贴图（omnidirectional shadow maps）。全向阴影贴图的主要挑战是避免在两个单独的地图相交处的接缝处出现伪像（artifacts）。King and Newhall  <strong>[895]</strong> 深入分析了问题并提供了解决方案，而 Gerasimov <strong>[525]</strong> 提供了一些实施细节。Forsyth <strong>[484，486]</strong> 提出了一种用于全向光的通用多视锥体分割方案，该方案还在需要时提供了更高的阴影贴图分辨率。Crytek <strong>[1590，1678，1679]</strong> 根据每个视图的投影视锥体的屏幕空间覆盖范围，可为点光源设置六个视图中每个视图的分辨率，并且所有贴图都存储在纹理贴图集中。</p>
<p>并非场景中的所有对象都需要渲染到光源的视锥体内。首先，仅需要渲染可以投射阴影的对象。例如，如果已知地面只能接收阴影而不能投射阴影，则不必将其渲染到阴影贴图中。</p>
<img alt="" height="579" src="https://img-blog.csdnimg.cn/20201019130621415.png" width="730">

<blockquote>
<p>图 7.10 阴影贴图。在左上方，通过存储视图中的深度来形成阴影图。在右上方，显示了眼睛看着两个位置。在<img alt="\large \textbf{v}_{a}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D_%7Ba%7D">点看到该球体，发现该点位于阴影贴图上的纹理像素 <img alt="\large a" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20a"> 处。存储在该处的深度不（远）小于光的 <img alt="\large \textbf{v}_{a}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D_%7Ba%7D"> 点，因此该点被照亮。在点 <img alt="\large \textbf{v}_{b}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D_%7Bb%7D"> 处命中的矩形比存储在纹理像素 <img alt="\large b" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20b"> 处的深度更加远离光源，因此在阴影中也是如此。左下角是从灯光角度看的场景视图，白色则更远。右下角是使用此阴影贴图渲染的场景。</p>
</blockquote>
<p>从定义上讲，阴影投射器是指位于灯光视锥体中的角色。可以通过多种方式增加或收紧这种视锥体，使我们可以安全地忽略一些 阴影投射器 <strong>[896，1812]</strong> 。让我们来考虑一下观察者可见的阴影接收器组。这组对象在沿光源的视线方向的最大距离内。超出此距离的任何物体都不能在可见的接收器上蒙上阴影。同样，可见接收器的集合可能会比光源的原始 x 和 y 视图范围小。见图 7.11。另一个例子是，如果光源在观察视锥体的内部，则该视锥体之外的任何物体都不能在接收器上投射阴影。仅渲染相关对象不仅可以节省渲染时间，还可以减小光源的视锥体所需的大小，因此可以提高阴影贴图的有效分辨率，从而提高质量。此外，视锥体的近平面距离光源越远越好，并且远平面越近越好，这也是有帮助的。这么做可以提高 z 缓冲区的有效精度 <strong>[1792]</strong> （第4.7.2节）。</p>
<p>阴影贴图的一个缺点是阴影的质量取决于阴影贴图的分辨率（以像素为单位）以及 z 缓冲区的数值精度。由于阴影贴图是在深度比较期间进行采样的，因此该算法容易出现走样问题，尤其是靠近对象之间的接触点。一个常见的问题是自阴影走样（self-shadow aliasing），通常被称为“表面痤疮”（surface acne）或“阴影痤疮”（shadow acne），其中三角形会错误地对自身产生阴影。此问题有两个来源。一种就是处理器精度的数值极限。另一个来源是几何图形，这是因为使用了点样本的值来表示区域的深度。也就是说，为光源生成的样本几乎永远不会与屏幕样本位于相同的位置（例如，像素经常在其中心进行采样）。将灯光的存储深度值与要查看的曲面的深度进行比较时，灯光的值可能会略低于曲面的深度，从而导致自阴影。这种错误的影响如图 7.12 所示。</p>
<img alt="" height="369" src="https://img-blog.csdnimg.cn/20201019131517205.png" width="738">

<blockquote>
<p>图 7.12  阴影贴图偏差伪像。在左侧，偏差值（bias）太低，因此发生自阴影。在右侧，高偏差值会导致鞋子不产生接触阴影。阴影贴图的分辨率也太低，从而使阴影显得块状。（图像来自 Christoph Peters 的阴影演示。）</p>
</blockquote>
<p>帮助避免（但不总是会消除）各种阴影贴图伪像的一种常用方法是引入偏差值参数。在检查阴影贴图中发现的距离与被测位置的距离时，会从接收器的距离中减去一个小的偏差值。见图 7.13。该偏差可能是一个恒定值  <strong>[1022]</strong> ，但是当接收器未完全面向光线时，这样做可能会失败。一种更有效的方法是使用与接收器与光的角度成比例的偏差值。表面远离光的程度越大，偏差值就越大，这样就可以避免此问题。这种类型的偏差值称为斜率比例偏差值（slope scale bias）。这两种偏差都可以通过使用诸如 OpenGL 的 glPolygonOffset 之类的命令来施加，以使每个多边形向远处偏离光线。请注意，如果表面直接面向光，则斜率比例偏差值根本不会将其向后偏移。因此，我们会将恒定偏差与斜率比例偏差混合使用以避免可能的精度误差。斜率比例偏差通常也被限制在某个最大值，因为当从光的角度观察接近于边缘的表面时，切线值（tangent value）可能会非常高。</p>
<img alt="" height="253" src="https://img-blog.csdnimg.cn/20201019132616246.png" width="746">

<blockquote>
<p>图 7.13 阴影偏差值。将表面渲染为顶灯（overhead light）的阴影贴图，垂直线表示阴影贴图的像素中心。遮挡物深度记录在 × 位置。我们想知道在三个显示为点的样本处表面是否被照亮。每个阴影贴图深度值的最接近值以相同的颜色 × 表示。在左侧，如果未添加任何偏差值，则蓝色和橙色样本将被错误地确定为处于阴影中，因为它们距光源的距离比其对应的阴影贴图深度更远。在中间，从每个样本中减去恒定的深度偏差值，可使每个样本更靠近光线。蓝色样本仍被认为是处于阴影中，因为它离光线比被测试的阴影贴图深度更近。在右侧，通过将每个多边形移离与光线成比例的斜率来形成阴影贴图。现在，所有采样深度都比其阴影贴图深度更近，因此都被照亮了。</p>
</blockquote>
<p>Holbert <strong>[759，760]</strong> 引入了法线偏移偏差（normal offset bias），它首先使接收器的世界空间位置沿表面法线方向稍微偏移一点，与光的方向和几何法线之间的角度的正弦成正比。请参阅第 250 页的图 7.24。这不仅会改变深度，还会改变在阴影贴图上测试样本的 x 和 y 坐标。随着光的角度向表面变浅，此偏移量增加，我们希望看到样品在表面上方足够远以避免自阴影。该方法可以可视化为将样品移至接收器上方的“虚拟表面” 。该偏移量是一个世界空间距离，因此 Pettineo <strong>[1403]</strong> 建议根据阴影贴图的深度范围对其进行缩放。Pesce  <strong>[1391]</strong> 提出了沿摄像机视图方向增加偏差的思路，该思路也可以通过调整阴影贴图坐标来实现。在第 7.5 节中讨论了其他偏差方法，因为那里介绍的阴影方法还需要测试几个相邻的样本。</p>
<p>太大的偏斜会引起称为漏光（light leaks）或彼得潘宁（Peter Panning） 的问题，在该问题中，对象似乎悬浮在底层的表面之上。之所以会出现这种伪像，是因为该物体的接触点下方的区域（例如脚下的地面）被推得太向前，因此不会收到阴影。</p>
<p>避免自阴影问题的一种方法是仅对阴影贴图渲染背面。这种方案称为二次深度阴影贴图（second-depth shadow mapping）  <strong>[1845]</strong> ，此方案在许多情况下都可以很好地工作，特别是对于不能手动调整偏差的渲染系统而言。当对象是双面的，薄的或彼此接触时，就会出现问题情况。如果对象是网格的两面都可见的模型（例如，棕榈叶或纸），则由于背面和正面位于相同的位置，因此可能会发生自阴影。同样，如果不执行任何偏移偏差操作，则轮廓边缘或薄物体附近可能会出现问题，因为在这些区域中，背面接近正面。增加一个偏差可以帮助避免表面痤疮（surface acne），但是该方案会更容易造成漏光，因为接收器和遮挡物背面之间在接触点之间没有分隔。见图 7.14。选择哪种方案可能取决于具体情况。例如，Sousa 等人  <strong>[1679]</strong> 发现使用正面去生成太阳的阴影，背面去生成室内照明阴影，这样最为适合。</p>
<img alt="" height="251" src="https://img-blog.csdnimg.cn/20201019211741931.png" width="750">

<blockquote>
<p>图 7.14   以上是顶灯环境下的阴影贴图表面。在左侧，面向光的表面（标记为红色）被发送到阴影贴图。表面可能被错误地确定为阴影自身（acne，“痤疮”），因此需要远离光线。在中间，仅将背面三角形渲染到阴影贴图中。向下增加这些遮挡器的偏差可能会使光泄漏到位置 a 附近的接地平面上；向前增加偏差会导致阴影标记为 b 的轮廓边界附近的照明位置被视为阴影。在右侧，在阴影贴图的每个位置上找到的最接近的正面和背面三角形之间的中点处形成中间表面。点 c 附近可能会发生光泄漏现象（第二深度阴影贴图也可能发生），因为最近的阴影贴图样本可能在此位置左侧的中间表面上，因此该点将更靠近光源。</p>
</blockquote>
<p>请注意，对于阴影贴图，对象必须是“水密的”（watertight，流形和封闭的，即实心；第16.3.3节），或者必须在贴图上同时显示正面和背面，否则对象可能无法完全投射阴影。Woo  <strong>[1900]</strong> 提出了一种通用方法，该方法试图在字面上仅使用正面或背面进行阴影生成，成为一种快乐的媒介 。这个想法是将实体对象渲染到阴影贴图上，并跟踪两个最接近光源的表面。我们可以通过深度剥离或其他与透明度相关的技术来执行该过程。两个对象之间的平均深度会形成一个中间层，该中间层的深度用作阴影贴图，有时这也称为双重阴影贴图（dual shadow map） <strong>[1865]</strong> 。如果物体足够厚，则自阴影和漏光伪像会降至最低。Bavoil 等人  <strong>[116]</strong> 讨论了解决潜在伪像的方法，以及其他实现细节。主要缺点是使用两个阴影贴图会造成额外的消耗。Myers  <strong>[1253]</strong>  讨论了遮挡物和接收器之间由艺术家控制的深度层。</p>
<p>随着观察者的移动，灯光的视锥体通常会随着阴影投射器的设置而改变大小。这样的变化又会导致阴影在帧与帧之间产生略微偏移。发生这种情况是因为光源的阴影贴图采样的是与光源不同的一组方向，并且这些方向与前一组方向不一致。对于方向光，解决方案是强制生成的每个后续阴影贴图在世界空间中保持相同的相对纹理像素光束位置 <strong>[927、1227、1792、1810]</strong> 。也就是说，你可以将阴影贴图视为在整个世界上施加二维网格化参照系，每个网格单元代表贴图上的一个像素样本。在移动时，将为这些相同的网格单元的不同集合生成阴影贴图。换句话说，光线的视线投影被强制移至该网格以维持帧与帧之间的连贯性。</p>
<h3 id="7-4-1-分辨率增强-Resolution-Enhancement"><a href="#7-4-1-分辨率增强-Resolution-Enhancement" class="headerlink" title="7.4.1 分辨率增强 Resolution Enhancement"></a>7.4.1 分辨率增强 Resolution Enhancement</h3><p>与使用纹理的方式类似，理想情况下，我们希望一个阴影贴图纹理覆盖大约一个图像像素。如果我们的光源位于与眼睛相同的位置，则阴影贴图将与屏幕空间像素完美地一对一映射（并且没有可见阴影，因为光线恰好照亮了眼睛所看到的）。光线的方向一改变，此每像素比率就会改变，这可能会导致伪像。一个例子如图 7.15 所示。由于前景中的大量像素与阴影贴图的每个纹理像素相关联，因此阴影会呈现块状且定义不清。这种不匹配称为透视走样（perspective aliasing）。如果一个表面接近光线边缘，但面向观察者，则单个阴影贴图纹理像素也可以覆盖许多像素。这个问题被称为投影走样 <strong>[1792]</strong> 。见图 7.16。可以通过增加阴影贴图的分辨率来降低其块状性，但是这要以增加内存和处理为代价。</p>
<img alt="" height="498" src="https://img-blog.csdnimg.cn/20201019212713192.png" width="739">

<blockquote>
<p>图 7.15  左侧的图像是使用标准阴影贴图创建的。右边的图像使用 LiSPSM 。显示了每个阴影贴图的纹理像素的投影。这两个阴影贴图具有相同的分辨率，不同之处在于 LiSPSM 重新构造了光源的矩阵，以在靠近观察者的位置提供更高的采样率。（图片由维也纳科技大学的 Daniel Scherzer 提供。）</p>
</blockquote>
<img alt="" height="319" src="https://img-blog.csdnimg.cn/20201020135045664.png" width="736">

<blockquote>
<p>图 7.16   左边的灯几乎在头顶上。相比于真实世界的眼睛所看到的，这里由于分辨率较低，阴影的边缘有点参差不齐。在右侧，光源接近地平线，因此每个阴影纹理像素在水平方向上覆盖了更大的屏幕区域，因此边缘更多锯齿。（由 TheRealMJP 的 Github 上的“ Shadows” 程序生成的图像。）</p>
</blockquote>
<p>还有另一种方法来创建灯光的采样图案，使其更接近于相机的图案。这是通过更改场景投影到灯光的方式来完成的 。通常，我们认为观察视图是对称的，观察向量（view vector）位于视锥的中心。然而，观察方向仅定义了观察平面，而不定义了哪些像素被采样。定义视锥的窗口可以在此平面上移动，倾斜或旋转，从而创建四边形，从而提供不同的世界视图空间映射。四边形仍按固定间隔进行采样，因为这是线性变换矩阵的性质以及 GPU 对其的使用。我们可以通过改变光源的观察方向和观察窗口的边界来修改采样率。见图 7.17。</p>
<p>将光线的视线映射到眼睛的视线有 22 个自由度  <strong>[896]</strong> 。对这种解决方案空间的探索导致了几种不同的算法，它们都试图更好地将光的采样率与眼睛的采样率匹配。方法包括透视阴影贴图（perspective shadow maps，PSM） <strong>[1691]</strong> ，梯形阴影贴图（trapezoidal shadow maps，TSM） <strong>[1132]</strong> 和光照空间透视阴影贴图（light space perspective shadow maps，LiSPSM） <strong>[1893、1895]</strong> 。有关示例，请参见第 254 页的图 7.15 和图 7.26。此类技术被称为透视变形（perspective warping）方法。</p>
<p>这些矩阵变形算法的一个优点是，除了修改光源矩阵外，不需要做其他工作。每种方法都有其优点和缺点  <strong>[484]</strong> ，因为每种方法都可以帮助在某些几何形状和光照情况下匹配采样率，而在另一些情况下则会降低采样率。Lloyd 等人  <strong>[1062，1063]</strong> 分析了PSM，TSM 和 LiSPSM之间的等效性，从而很好地概述了这些方法的采样和走样问题。当光线的方向垂直于视图的方向（例如头顶）时，这些方案最有效，因为可以移动透视变换以使更多的样本更靠近眼睛。</p>
<img alt="" height="220" src="https://img-blog.csdnimg.cn/20201020135544526.png" width="741">

<blockquote>
<p>图 7.17  对于顶灯，左边的地板上的采样与眼睛的比率不匹配。通过更改右侧的光线的观看方向和投影窗口，采样率将偏向于具有更高密度的像素，使其更接近眼睛 。</p>
</blockquote>
<p>矩阵扭曲技术无法提供帮助的一种照明情况是，当光线在相机前面并指向相机时。这种情况被称为视锥决斗（dueling frusta），或更通俗地说是“顶灯下的鹿” 。要接近眼睛的感觉，需要更多阴影贴图样本，但是线性扭曲只会使情况变得更糟  <strong>[1555]</strong> 。这个问题和其他一些问题，例如画面质量的突然变化 <strong>[430]</strong> 和相机运动过程中产生的阴影的“紧张”，不稳定的质量 <strong>[484，1227]</strong> ，使这些方法不受欢迎。</p>
<p>在观看者所在的位置添加更多样本的想法是一个不错的主意，导致产生针对给定视图生成多个阴影贴图的算法。当 Carmack 在 2004 年 Quakecon 的主题演讲中描述这一想法时，它首先产生了显着的影响。Blow 独立地实现了这种系统  <strong>[174]</strong> 。这个想法很简单：生成一组固定的阴影贴图（可能以不同的分辨率），覆盖场景的不同区域。在 Blow 的方案中，在观察者周围嵌套了四个阴影贴图。这样，高分辨率地图可用于附近的对象，而远处的那些对象的分辨率会下降。Forsyth  <strong>[483，486]</strong> 提出了一个相关的想法，为不同的可见对象集生成不同的阴影贴图。在他的设置中避免了如何处理跨两个阴影贴图之间的边界的对象的过渡问题，因为每个对象都有一个且只有一个阴影图与之关联。旗舰工作室（Flagship Studios）开发了一种融合了这两种想法的系统。一个阴影贴图用于附近的动态对象，另一个阴影贴图用于观察者附近的静态对象的网格区域，第三阴影贴图用于整个场景中的静态对象。第一个阴影贴图按逐帧来生成。由于光源和几何形状是静态的，因此其他两个阴影贴图只能生成一次。尽管所有这些特定系统现在都已经很老了，但是针对不同对象和情况的多个映射（有些是预先计算的，有些是动态的）的思想是此后开发的算法中的一个共同主题。</p>
<p>2006年，Engel  <strong>[430]</strong> ，Lloyd 等人 <strong>[1062，1063]</strong> ，和 Zhang 等。 <strong>[1962，1963]</strong> 独立研究了相同的基本概念。**(1)** 这个概念是将视锥体平行于视线方向切成几部分。见图 7.18。随着深度的增加，每个连续的视锥体的深度范围大约是先前体积的深度范围的两到三倍 <strong>[430，1962]</strong> 。对于每个视锥体，光源都可以形成一个将视锥体紧紧包围的视锥，然后生成阴影贴图。通过使用纹理地图集或阵列，可以将不同的阴影贴图视为一个大型纹理对象，从而最大程度地减少了缓存访问延迟。图 7.19 显示了获得的质量改进的比较。Engel 将此算法称为层级阴影贴图（cascaded shadow maps，CSM），比 Zhang 的术语平行分割阴影贴图（parallel-split shadow maps）更常用，但两者都出现在文献中并且实际上是相同的  <strong>[1964]</strong> 。</p>
<p>这种类型的算法易于实现，可以覆盖较大的场景区域并具有合理的结果，并且功能强大。可以通过以更高的速度靠近眼睛来采样并解决视锥问题，并且没有严重的最坏情况问题。由于这些优点，在许多应用程序中使用了层级阴影贴图。</p>
<img alt="" height="427" src="https://img-blog.csdnimg.cn/20201020212115548.png" width="743">

<blockquote>
<p>图 7.18 在左侧，从视线看到的视锥体被分成四个部分。在右侧，为视锥体创建了边界框，该边界框确定了方向光条件下四个阴影贴图中对应渲染的视锥体。（在 Engel  <strong>[430]</strong> 之后。）</p>
</blockquote>
<img alt="" height="454" src="https://img-blog.csdnimg.cn/20201020212511437.png" width="736">

<blockquote>
<p>图 7.19   在左侧，场景的可视范围广，导致单个 2048 × 2048 分辨率的阴影贴图具有透视锯齿。在右边，沿视轴放置的四个1024 × 1024 阴影贴图可显着提高质量  <strong>[1963]</strong> 。栅栏前方的缩放显示红色框中。（图片由香港中文大学的张凡提供。）</p>
</blockquote>
<img alt="" height="298" src="https://img-blog.csdnimg.cn/20201020212927830.png" width="713">

<blockquote>
<p>图 7.20   阴影层级可视化。紫色，绿色，黄色和红色表示最近到最远的层级。（图片由Unity Technologies提供。）</p>
</blockquote>
<p>虽然可以使用透视变形将更多样本打包到单个阴影贴图的细分区域中 <strong>[1783]</strong> ，但为了规范，每个层级会使用单独的阴影贴图。如图 7.18 所示，图 7.20 从观察者的角度显示，每张地图所覆盖的区域可以变化。较小的阴影贴图的较小视锥体在需要的地方提供了更多样本。确定如何在地图之间划分 z 深度的范围（称为 z 分区任务）可能非常简单，也可能复杂难懂 <strong>[412，991，1791]</strong> 。一种方法是对数分区（logarithmic partitioning） <strong>[1062]</strong> ，其中每个层级图的远近平面距离之比都相同：</p>
<img alt="" height="72" src="https://img-blog.csdnimg.cn/20201020213340745.png" width="430">

<p>其中，n 和 f 是整个场景的近平面和远平面，c 是地图的数量，r 是结果比率。例如，如果场景的最近对象是 1 米远，最大距离是1000米，并且我们有三个层级贴图，则 <img alt="" height="27" src="https://img-blog.csdnimg.cn/20201020214024960.png" width="175"> 最近视图的近平面距离和远平面距离将是 1 和 10，则下一个间隔为 10 到 100 ，以保持该比例，最后一个间隔为 100 到 1000 米。初始近平面深度对该分区影响很大。如果近平面深度只有 0.1 米，则 10000 的立方根为 21.54，这是一个相当高的比率，例如 0.1 到 2.154 到 46.42 到 1000。这意味着生成的每个阴影贴图必须覆盖更大的区域，从而降低了其精度 。在实践中，这样的划分为靠近近平面的区域提供了相当大的分辨率，如果该区域中没有任何对象，这将被浪费。避免这种资源不匹配的一种方法是将分区距离设置为对数分布和等距分布的加权混合  <strong>[1962，1963]</strong> ，但是如果我们可以确定场景的紧密视域（tight view bounds），那么会更好。</p>
<p>此方法的挑战在于设置近平面。如果距离眼睛太远，则该平面可能会将物体裁剪，这是非常糟糕的伪像。对于剪辑场景，美术人员可以预先精确设置此值  <strong>[1590]</strong> ，但是对于交互式环境，此问题更具挑战性。Lauritzen 等人 <strong>[991，1403]</strong> 提出了样本分布阴影贴图（sample distribution shadow maps，SDSM），它使用前一帧的 z 深度值，并通过两种方法之一来确定更好的分区。</p>
<p>第一种方法是查看 z 深度的最小值和最大值，并使用它们来设置近平面和远平面。这是通过在 GPU 上执行 reduce 操作来执行的，在该操作中，将会计算或者其他着色器将分析一系列越来越小的缓冲区，并将输出缓冲区作为输入进行反馈，直到剩下 1 × 1 缓冲区为止。通常，会将这些值往外推出一点以调整场景中对象移动的速度。除非采取纠正措施，否则从屏幕边缘进入的附近物体仍可能会导致帧问题，尽管在下一帧中将很快得到纠正。</p>
<p>第二种方法还分析了深度缓冲区的值，制作了一个称为直方图（histogram）的图表，该图表记录了 z 深度沿范围的分布。除了找到紧密的近平面和远平面之外，在根本没有对象的位置，图形中可能会有空隙。通常添加到该区域的任何分区平面都可以捕捉到实际存在对象的位置，从而为层级贴图集提供更高的 z 深度精度。</p>
<p>在实践中，第一种方法是通用的，且快速的（通常在每帧1 ms范围内），并且效果良好，因此已在多种应用中被采用 <strong>[1405，1811]</strong> 。见图7.21。</p>
<img alt="" height="422" src="https://img-blog.csdnimg.cn/20201021133803674.png" width="744">

<blockquote>
<p>图 7.21  深度范围的影响。在左侧，未使用特殊处理来调整近平面和远平面。在右侧，SDSM用于查找更严格的边界。请注意每个图像左边缘附近的窗框，二楼花箱下方的区域以及一楼的窗户，由于松散的视野范围而导致的欠采样会导致伪像。可以用指数阴影贴图去渲染这些特定图像，但是提高深度精度的想法对于所有阴影贴图技术都是有用的。（图片由 Dawn Studios 的 Ready 提供，版权为 Sony Interactive Entertainment。）</p>
</blockquote>
<p>与单个阴影贴图一样，由于光照样本逐帧移动而造成的闪烁伪像是一个问题，并且还会随着对象在层级之间移动而变得更糟。可以使用多种方法来维护世界空间中的稳定采样点，每种方法都有自己的优势  <strong>[41，865，1381，1403，1678，1679，1810]</strong> 。当对象跨越两个阴影贴图之间的边界时，阴影质量可能会突然发生变化。一种解决方案是使视锥体稍微重叠。在这些重叠区域中获取的样本从两个相邻的阴影贴图中收集结果并进行混合  <strong>[1791]</strong> 。或者，可以通过使用抖动  <strong>[1381]</strong> 在这样的区域中采集单个样本。</p>
<p>由于它的流行，人们已经投入了大量的精力来提高其效率和质量 <strong>[1791，1964]</strong> 。如果阴影贴图的视锥体内部没有任何变化，则无需重新计算该阴影贴图。对于每种光线，可以通过找到哪些对象对光线可见以及其中哪些可以在接收器上投射阴影来预先计算阴影投射器列表  <strong>[1405]</strong> 。由于很难理解阴影是否正确，因此可以采用一些适用于层级和其他算法的快捷方法。一种技术是使用低级别的细节模型作为替代来进行实际的投射阴影  <strong>[652，1812]</strong> 。另一个方法是从考虑中移除小型遮挡物 <strong>[1381，1811]</strong> 。从理论上来说，距离较远的阴影贴图的更新可以不用做到逐帧更新，因为这样的阴影不太重要。但这个办法可能会引起大的移动物体的伪像，因此需要谨慎使用  <strong>[865，1389，1391，1678，1679]</strong> 。Day <strong>[329]</strong> 提出了从帧到帧“滚动”远距离贴图的想法，这种想法是每个静态阴影贴图的大部分都是可在帧与帧之间重用的，并且只有条纹可能会改变 ，因此需要渲染。DOOM（2016）等游戏维护着大量的阴影贴图集，但仅重新生成对象移动的那些贴图  <strong>[294]</strong> 。更远的层级阴影贴图可以设置为完全忽略动态对象，因为这样的阴影可能对场景的贡献很小。在某些环境中，可以使用高分辨率的静态阴影贴图代替这些更远的层级，从而可以显着减少工作量  <strong>[415，1590]</strong> 。稀疏纹理系统（sparse texture system）（第19.10.1节）可用于单个静态阴影贴图的巨大世界  <strong>[241、625、1253]</strong> 。层级阴影贴图可以与烘焙的光照贴图纹理或其他更适合特定情况的阴影技术结合使用  <strong>[652]</strong> 。Valient的演讲 <strong>[1811]</strong> 值得注意，因为它描述了针对各种视频游戏的不同阴影系统的自定义设置和技术。第 11.5.1 节详细讨论了预先计算的光和阴影算法。</p>
<p>创建多个单独的阴影贴图意味着要遍历每个几何贴图集。在一次通过将遮挡物渲染到一组阴影贴图的思路的基础上，已经建立了许多提高效率的方法。几何着色器可用于复制对象数据并将其发送到多个视图  <strong>[41]</strong> 。实例化的几何着色器允许将一个对象输出到多达32个的深度纹理中 <strong>[1456]</strong> 。多视口扩展可以执行诸如将对象渲染到特定纹理阵列切片（specific texture array slice） <strong>[41、154、530]</strong> 之类的操作。第 21.3.1 节在将其用于虚拟现实的上下文中将对它们进行更详细的讨论。视口共享技术的可能缺点是，必须将生成的所有阴影贴图的遮挡物沿着管线发送，而不是发送与每个阴影贴图相关的集合 <strong>[1791、1810]</strong> 。</p>
<p>在现实世界里，你自己当前便处在全球数十亿光源的阴影中。并且只有其中部分光源能照到你身上。在实时渲染中，如果所有光源始终处于活动状态，则包含多个光源的大型场景可能会被海量的计算淹没。如果视锥体内部有一定空间但眼睛看不到，则不需要计算遮挡此接收器空间的对象  <strong>[625，1137]</strong> 。Bittner 等人  <strong>[152]</strong> 使用眼睛观察方向的遮挡剔除（第19.7节）找到所有可见的阴影接收器，然后从灯光的角度将所有潜在的阴影接收器渲染到模板缓冲蒙版。此蒙版编码从光中看到哪些可见的阴影接收器。为了生成阴影贴图，它们使用遮挡剔除从灯光中渲染对象，并使用遮罩将没有接收器的对象剔除。各种剔除策略也可以用于照明。由于辐照度与距离的平方成正比，因此一种常见的技术是在某个阈值距离之后选择光源。例如，第 19.5 节中的入口剔除技术（portal culling technique）可以发现哪些光线会影响哪些单元。这是一个活跃的研究领域，因为其性能优势十分可观 <strong>[1330，1604]</strong> 。</p>
<h2 id="7-5-百分比渐近滤波-Percentage-Closer-Filtering"><a href="#7-5-百分比渐近滤波-Percentage-Closer-Filtering" class="headerlink" title="7.5 百分比渐近滤波 Percentage-Closer Filtering"></a>7.5 百分比渐近滤波 Percentage-Closer Filtering</h2><p>阴影贴图技术的简单扩展可以提供伪软阴影(pseudo-soft shadows)。此方法还可帮助改善分辨率问题，当单个光照样本单元覆盖许多屏幕像素时，这些问题会导致阴影看起来呈现块状。该解决方案类似于纹理放大（第6.2.1节）。但不同的是会获取四个最接近的样本，而不是从阴影贴图中获取一个样本。该技术不会在深度本身之间进行插值，而是将其与表面深度进行比较并得出结果。也就是说，将表面的深度分别与四个纹理像素深度进行比较，然后针对每个阴影贴图样本确定该点在光还是阴影下。然后对这些结果（即阴影的 0 和光的 1）进行双线性插值，以计算实际上对表面位置有多少贡献的光。这种滤波会产生人为的柔和阴影。这些半影的变化取决于阴影贴图的分辨率，相机位置和其他因素。例如，较高的分辨率可使边缘的柔化范围更窄。不过，有半影和平滑总比没有要好。</p>
<p>从阴影贴图中检索多个样本并混合结果的做法称为百分比渐近滤波（percentage-closer filtering，PCF） <strong>[1475]</strong> 。区域光产生柔和的阴影。到达表面上某个位置的光量取决于该位置可见的光区域的比例。PCF 试图通过逆过程来近似精确光（或方向光）的柔和阴影。它不是从某个表面位置找到该光的可见区域，而是从原始位置附近的一组表面位置中找到了点光源的可见性。见图7.22。名称“百分比渐近滤波”是指最终目标，即查找可见光所取样品的百分比。该百分比是然后用于遮蔽表面的光量。</p>
<img alt="" height="348" src="https://img-blog.csdnimg.cn/20201021204115215.png" width="614">

<blockquote>
<p>图 7.22 在左侧，区域光源的棕色线段表示形成半影的位置。对于接收器上的单个点 p，可以通过在区域光的表面上测试一组点并找出没有被任何遮挡物阻挡的点来计算接收到的照明量。在右侧，点光源不会投射半影。PCF 通过逆过程来近似区域光的效果：在给定位置，它将在阴影贴图的可比较区域上采样，以得出照亮多少个样本的百分比。红色椭圆表示阴影贴图上采样的区域。理想情况下，该磁盘的宽度与接收器和遮挡器之间的距离成比例。</p>
</blockquote>
<p>在 PCF 中，会在大约相同的深度，但在阴影贴图上的不同纹理位置上的曲面附近生成位置信息。接下来检查每个位置的可见性，然后将这些生成的布尔值（激活或未激活）混合在一起，以获得柔和的阴影。请注意，此过程是非物理的：此过程不是直接对光源进行采样，而是依赖于对表面本身进行采样的想法。到遮挡物的距离不会影响结果，因此阴影具有类似遮挡物大小的半影。尽管如此，该方法在许多情况下仍可提供合理的近似值。</p>
<p>一旦确定了要采样区域的宽度，以避免走样及伪像的方式进行采样就很重要。如何对附近的阴影贴图位置进行采样和滤波有多种不同的方法。这些方法包括要采样的区域的范围，要使用的样本数，采样模式以及如何加权结果。使用功能较差的 API，可以通过类似于双线性插值的特殊纹理采样模式来加速采样过程，该模式可以访问四个相邻位置。而不是混合结果，而是将四个样本中的每个样本与给定值进行比较，然后返回通过测试的比率  <strong>[175]</strong> 。然而，以规则的网格图案执行最近邻采样会产生明显的伪像。使用使结果模糊但尊重对象边缘的联合双边滤波器可以提高质量，同时避免阴影泄漏到其他表面上  <strong>[1343]</strong> 。有关此过滤技术的更多信息，请参见第 12.1.1 节。</p>
<p>DirectX 10 引入了对 PCF 的单指令双线性滤波的支持，从而提供了更为平滑的结果 <strong>[53、412、1709、1790]</strong> 。与最近邻采样相比，这提供了可观的视觉改进，但是来自常规采样的伪像仍然是一个问题。最小化网格图案的一种解决方案是使用预先计算的泊松分布图案对区域进行采样，如图 7.23 所示。这种分布将样本分散开，以使它们既不彼此靠近也不规则。众所周知，对于每个像素使用相同的采样位置，无论其分布如何，都可能会产生图案  <strong>[288]</strong> 。可以通过围绕样本中心随机旋转样本分布来避免此类伪像，从而将走样化为噪声。Casta No <strong>[235]</strong> 发现，泊松采样产生的噪声因其平滑，风格化的内容而特别引人注目。他提出了一种基于双线性采样的高效高斯加权采样方案。</p>
<img alt="" height="161" src="https://img-blog.csdnimg.cn/20201021204400419.png" width="621">

<blockquote>
<p>图 7.23   最左端显示使用最近邻采样的 4×4 网格模式的 PCF 采样。最右边显示磁盘上的 12 抽头 泊松采样模式。使用此模式对阴影贴图进行采样可在第二张图提供改进的结果，尽管仍然可以看到伪像。在第三张图，采样模式在像素之间围绕其中心随机旋转。结构化的阴影伪像会变成（几乎不令人反感的）噪音。（图片由ATI Research，Inc.的John Isidoro提供）</p>
</blockquote>
<p>自阴影问题和漏光（例如痤疮和 Peter Panning）在 PCF 中可能变得更糟。斜率比例偏差（Slope scale bias）基于样本与阴影的角度，只是根据其与光线的角度将表面推离光线。通过从表面上的单个位置在更大的区域中采样，某些测试样本可能会被真实的表面所阻塞。</p>
<p>一些不同的附加偏差值可以被成功地用来减少自阴影的风险。Burley <strong>[212]</strong> 描述了偏差锥（bias cone），其中每个样本都朝着与光到原始样本的距离成正比的方向移动。Burley 建议斜率为 2.0，同时具有较小的恒定偏差。参见图 7.24。</p>
<img alt="" height="202" src="https://img-blog.csdnimg.cn/20201021203805597.png" width="621">

<blockquote>
<p>图 7.24  附加阴影偏差方法。对于PCF，在原始样品位置（五个点的中心）周围采集了几个样本。所有这些样本都应激活。在左图中，形成了一个偏差锥，样本被向上移动。可以增加圆锥的陡度，以将右侧的样本拉到足够近的距离以进行照明，从而冒着其他地方（未显示）的其他样本的光漏现象增加的风险，这些其他样本确实被遮挡了。在中间的图中，所有样本都被调整为位于接收器的平面上。这对于凸面效果很好，但在凹面上可能适得其反，如左侧所示。在右图中，法线偏移偏差方法使样本沿着曲面的法线方向移动，与法线和灯光之间的角度的正弦成正比。对于中心样本，这可以认为是移动到原始表面上方的虚构表面。该偏差不仅会影响深度，还会更改用于测试阴影贴图的纹理坐标。</p>
</blockquote>
<p>Schüuler  <strong>[1585]</strong> ，Isidoro  <strong>[804]</strong> 和 Tuft <strong>[1790]</strong> 提出了基于观察得到的技术，即接收器本身的斜率应用于调整其余样本的深度。在这三者中，塔夫特的公式  <strong>[1790]</strong>  最容易应用于层级阴影贴图。Dou 等人 <strong>[373]</strong>  进一步完善和扩展了这个概念，考虑了 z 深度如何以非线性方式变化。这些方法假定附近的样本位置在三角形所形成的同一平面上。称为接收器平面深度偏差（receiver plane depth bias）或其他类似术语，由于在此假想平面上的位置确实在表面上，或者如果模型是凸面，则在该表面的前面，此技术在很多情况下都可以非常精确。如图 7.24 所示，凹面附近的样本可能会被隐藏。常量，斜率比例尺，接收器平面，视线偏移和法线偏移的组合已用于解决自阴影问题，尽管这仍然需要针对每种环境进行手动调整  <strong>[235，1391，1403]</strong> 。</p>
<p>PCF 的一个问题是，由于采样区域的宽度保持不变，因此阴影将显示出均匀柔和的阴影，且阴影的宽度相同。在某些情况下，这是可以接受的，但在封堵器和接收器之间有地面接触的地方，这似乎是不正确的。见图 7.25。</p>
<img alt="" height="236" src="https://img-blog.csdnimg.cn/2020102215021243.png" width="742">

<blockquote>
<p>图 7.25  百分比渐近滤波和百分比渐近软阴影。 左侧是带有少量 PCF 滤波的硬阴影。 在中间，为等宽的软阴影。 在右侧，当物体与地面接触时，宽度可变的软阴影具有适当的硬度。 （图片由NVIDIA Corporation提供。）</p>
</blockquote>
<h2 id="7-6-百分比渐近软阴影-Percentage-Closer-Soft-Shadows"><a href="#7-6-百分比渐近软阴影-Percentage-Closer-Soft-Shadows" class="headerlink" title="7.6 百分比渐近软阴影 Percentage-Closer Soft Shadows"></a>7.6 百分比渐近软阴影 Percentage-Closer Soft Shadows</h2><p>在 2005 年，Fernando <strong>[212，467，1252]</strong> 发表了一种有影响力的方法，称为“百分比渐近软阴影（Percentage-Closer Soft Shadows，PCSS）”。它通过在阴影图上搜索附近区域以找到所有可能的遮挡物来尝试解决软阴影问题。这些遮挡器与位置的平均距离用于确定样本区域的宽度：</p>
<img alt="" height="57" src="https://img-blog.csdnimg.cn/20201021211007217.png" width="412">

<p>其中 <img alt="d_{r}" class="mathcode" src="https://private.codecogs.com/gif.latex?d_%7Br%7D">  是接收器与光线的距离，并计算平均的遮挡物距离。换句话说，样本的表面积的宽度随着平均的遮挡物离接收器的距离越来越远、离光越来越近而增加。请查看图 7.22，并思考移动遮挡物的效果，看看这是如何发生的。图 7.2（第224页），7.25 和 7.26 显示了示例。</p>
<p>如果没有找到遮挡物，则该位置已完全照亮，无需进一步处理。类似地，如果该位置被完全遮挡，则处理可以结束。否则，将对感兴趣的区域进行采样，并计算出光线的近似贡献。为了节省处理成本，可以使用样本区域的宽度来改变采集的样本数量。可以实现其他技术，例如，对于不太可能重要的遥远的软阴影使用较低的采样率。</p>
<p>该方法的缺点是需要对阴影图的适当大小的区域进行采样才能找到遮挡物。使用旋转的泊松磁盘图案可以帮助隐藏欠采样的伪像  <strong>[865，1590]</strong> 。Jimenez <strong>[832]</strong> 注意到泊松采样在运动中可能会不稳定，并发现通过使用抖动和随机之间的中间函数形成的螺旋模式可以在帧与帧之间提供更好的结果。</p>
<p>Sikachev 等人  <strong>[1641]</strong> 详细讨论了使用 SM 5.0 中功能的 PCSS 的更快实现，该功能由 AMD 引入，并经常以接触硬化阴影（contact hardening shadows，CHS）的名称来称呼。这个新方法还解决了基本 PCSS 的另一个问题：半影的大小受阴影贴图分辨率的影响。见图 7.25。通过最先生成阴影贴图的 mipmap，然后选择最接近用户定义的世界空间内核大小的 mip 级别，可以将此问题最小化。采样一个 8×8 的区域以查找平均阻塞深度，仅需要16个GatherRed（）函数的纹理调用。一旦找到预估的半影，则将较高分辨率的 mip 级别用于阴影的锐利区域，而将较低分辨率的 mip 级别用于较柔和的区域。</p>
<p>CHS 已用于许多视频游戏中 <strong>[1351、1590、1641、1678、1679]</strong> ，并且研究仍在继续。例如，Buades 等人 <strong>[206]</strong> 提出了可分离的软阴影贴图（separable soft shadow mapping，SSSM），其中对网格采样的 PCSS 过程被分成可分离的部分，并且像素之间尽可能地重用元素。</p>
<p>事实证明，对于加速每个像素需要多个样本的算法有帮助的概念是分层的最小/最大阴影贴图（min/max shadow map）。虽然通常无法对阴影贴图的深度进行平均，但每个 mipmap 级别的最小值和最大值可能会很有用。也就是说，可以形成两个 mipmap，一个保存在每个区域中找到的最大 z-depth（有时称为HiZ），另一个保存最小的 z-depth。给定要采样的纹理像素位置，深度和面积，可以使用 mipmap 快速确定完全光照和完全阴影的条件。例如，如果纹理像素的 z 深度大于为 mipmap 的相应区域存储的最大 z 深度，则该纹理像素必须处于阴影状态-不需要其他样本。这种类型的阴影图使精确光可见性的任务更加有效  <strong>[357、415、610、680、1064、1811]</strong> 。</p>
<p>PCF 等方法通过对附近的接收器位置进行采样来工作。PCSS 通过查找附近遮挡器的平均深度来工作。这些算法没有直接考虑光源的面积，而是对附近的表面进行采样，并且受阴影贴图分辨率的影响。PCSS 理论背后的一个主要假设是，平均阻塞物（blocker）是对半影大小的合理估计 。当两个遮挡物（例如路灯和远处的山脉）部分遮挡同一像素的同一表面时，此假设将被破坏并可能导致伪像。理想情况下，我们要确定从单个接收器位置可见多少区域光源。一些研究人员已经使用 GPU 探索了反投影（backprojection）。这个想法是将每个接收器的位置视为一个视点，并将区域光源视为一个视平面，并将遮挡物投射到该平面上。Schwarz and Stamminger <strong>[1593]</strong> 和 Guennebaud 等人  <strong>[617]</strong>  总结了以前的工作并提供了自己的改进。Bavoil等人 <strong>[116]</strong> 采用另一种方法，使用深度剥离创建多层阴影贴图。反投影算法可以提供出色的结果，但是（到目前为止）较高的逐像素成本意味着它们尚未在交互式应用程序中得到采用。</p>
<h2 id="7-7-滤波阴影贴图-Filtered-Shadow-Maps"><a href="#7-7-滤波阴影贴图-Filtered-Shadow-Maps" class="headerlink" title="7.7 滤波阴影贴图 Filtered Shadow Maps"></a>7.7 滤波阴影贴图 Filtered Shadow Maps</h2><p>一种可以对生成的阴影贴图进行滤波的算法是 Donnelly 和 Lauritzen 的方差阴影贴图（variance shadow map，VSM） <strong>[368]</strong> 。该算法在一张贴图中存储深度，在另一张贴图中存储深度的平方。生成贴图时可以使用 MSAA 或其他反走样方案。可以对这些贴图进行模糊处理，mipmap，放置在求和区域表中  <strong>[988]</strong>  或任何其他方法。将这些贴图作为可滤波纹理的能力是一个巨大的优势，因为从它们中检索数据时，可以使用整个采样和滤波技术合集。</p>
<p>我们将在此处更深入地描述 VSM，以了解该过程的工作方式。同样，此类算法中的所有方法都使用相同类型的测试。有兴趣进一步了解该领域的读者可以查阅相关参考资料，我们也建议阅读 Eisemann 等人的书 <strong>[412]</strong> ，该书为此主题提供了更大的扩展。</p>
<p>首先，对于 VSM，在接收器的位置采样深度图（仅一次），以返回最近的光遮挡器的平均深度。当该平均深度 <img alt="\large M_{1}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20M_%7B1%7D">，被称为一阶矩（first moment），大于阴影接收器 <img alt="\large t" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20t"> 的深度时，该接收器被视为完全处于光线下。当平均深度小于接收者的深度时，将使用以下公式：</p>
<img alt="" height="74" src="https://img-blog.csdnimg.cn/20201022202103843.png" width="521">

<p>其中 <img alt="\large p_{max}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20p_%7Bmax%7D"> 是光中样本的最大百分比，<img alt="\large \sigma ^{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%5Csigma%20%5E%7B2%7D"> 是方差，<img alt="\large t" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20t"> 是接收器深度，<img alt="\large M_{1}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20M_%7B1%7D"> 是阴影图中的平均预期深度。深度平方阴影图的样本 <img alt="\large M_{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20M_%7B2%7D">，称为二阶矩（second moment），被用于计算方差：</p>
<img alt="" height="59" src="https://img-blog.csdnimg.cn/20201022203223724.png" width="470">

<p>值 <img alt="\large p_{max}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20p_%7Bmax%7D"> 是接收器可见度百分比的上限。实际照度百分比 <img alt="\large p" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20p"> 不能大于此值。这个上限来自切比雪夫不等式（Chebyshev’s inequality）的单面变体。该方程试图使用概率论来估计遮挡物在表面位置的分布超出表面到光的距离的程度。Donnelly 和 Lauritzen 证明，对于固定深度处的平面遮挡器和平面接收器，<img alt="\large p=p_{max}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20p%3Dp_%7Bmax%7D">，因此公式 7.7 可作为许多真实阴影情况的良好近似。</p>
<p>Myers <strong>[1251]</strong> 解释了关于这种方法为何起作用。在阴影边缘，区域上的差异会增加。深度差异越大，差异越大。因此，<img alt="\large (t-M_{1})^{2}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20%28t-M_%7B1%7D%29%5E%7B2%7D"> 项是可见度百分比的重要决定因素。如果此值刚好略高于零，则意味着平均遮挡器深度比接收器更稍微接近光线，然后 <img alt="\large p_{max}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20p_%7Bmax%7D"> 接近 1（完全照亮）。这将沿着半影完全照亮的边缘发生。进入半影，平均遮挡物深度更接近光源，因此该项变大并且 <img alt="\large p_{max}" class="mathcode" src="https://private.codecogs.com/gif.latex?%5Clarge%20p_%7Bmax%7D"> 减小。同时，方差本身在半影内变化，从沿边缘的几乎为零到最大的方差，在这些方差中，遮挡物的深度不同，并且面积均等。这些项相互抵消，以在半影上产生线性变化的阴影。与其他算法的比较请参见图 7.26。</p>
<img alt="" height="690" src="https://img-blog.csdnimg.cn/20201022212611925.png" width="742">

<blockquote>
<p>图 7.26 左上角是标准阴影贴图。右上角是透视阴影贴图，增加了观察者附近的阴影贴图纹理密度。左下角，百分比渐近的软阴影，当遮挡物到接收器的距离增加时，阴影变柔和。右下角是具有恒定软阴影宽度的方差阴影贴图，每个像素用单个方差贴图样本进行阴影处理。（图片由Nico Hempe，Yvonne Jung 和 Johannes Behr提供。）</p>
</blockquote>
<p>方差阴影贴图的一个重要特征是，它可以以优雅的方式处理由于几何形状而引起的表面偏差问题。Lauritzen  <strong>[988]</strong> 推导了如何使用表面的斜率修改二阶矩的值。偏差和来自数值稳定性的其他问题可能是方差贴图的问题。例如，公式 7.8 从另一个相似的值中减去一个大的值。这种类型的计算往往会放大底层数值的精确度不足问题。使用浮点纹理有助于避免此问题。</p>
<p>由于 GPU 的优化纹理功能得到了有效利用，因此整体 VSM 可以显着提高处理时间，从而提高图像质量。虽然 PCF 需要更多的样本，并因此需要更多的时间来避免在生成较柔和的阴影时产生噪声，但 VSM 只能使用一个高质量的样本来确定整个区域的效果并产生平滑的半影。这意味着在算法的限制内，可以在不增加成本的情况下任意地使阴影变得柔和。</p>
<p>与 PCF 一样，滤波内核的宽度决定了半影的宽度。通过找到接收器和最近的遮挡物之间的距离，可以改变内核宽度，从而产生令人信服的软阴影。mipmap 操作后的样本对于宽度缓慢增加的半影的覆盖率估算不佳，从而产生了盒状伪像。Lauritzen  <strong>[988]</strong> 详细介绍了如何使用求和区域表来产生更好的阴影。图 7.27 显示了一个示例。</p>
<img alt="" height="362" src="https://img-blog.csdnimg.cn/20201022212811180.png" width="743">

<blockquote>
<p>图 7.27 方差阴影贴图，其中到光源的距离从左到右增加。（图片来自 NVIDIA SDK 10 <strong>[1300]</strong> 示例，由 NVIDIA 公司提供。）</p>
</blockquote>
<p>当两个或多个遮挡物覆盖接收器且一个遮挡物靠近接收器时，沿半影区域的一个位置方差阴影贴图将分崩离析。来自概率理论的切比雪夫不等式（Chebyshev inequality）将产生与正确的光照百分比无关的最大光照值。最近的遮挡物（仅部分遮挡了光线）使方程的近似值偏离了目标。这会导致漏光（light bleeding，又称 light leaks），而被完全遮挡的区域仍会接收光。见图 7.28。通过在较小的区域上采集更多样本，可以解决此问题，将方差阴影贴图转变为 PCF 形式。与 PCF 一样，速度和性能之间也要取舍，但对于阴影深度复杂度较低的场景，方差贴图效果很好。Lauritzen <strong>[988]</strong> 提出了一种由艺术家控制的方法来改善该问题，该方法是将较低的百分比视为完全阴影，并将其余百分比范围重新映射为 0％ 至 100％。这种方法使漏光变暗，但总体上使半影变窄。尽管漏光是一个严重的限制，但 VSM 可以很好地从地形中产生阴影，因为这种阴影很少涉及多个遮挡物  <strong>[1227]</strong> 。</p>
<img alt="" height="255" src="https://img-blog.csdnimg.cn/20201022215837688.png" width="735">

<blockquote>
<p>图 7.28  在左侧，方差阴影贴图应用于茶壶。在右侧，三角形（未显示）在茶壶上投射阴影，从而在地面上的阴影中引起令人反感的伪像。（图片由马可·萨尔维（Marco Salvi）提供。）</p>
</blockquote>
<p>能够使用滤波技术快速产生平滑阴影的希望在滤波阴影贴图中引起了极大的兴趣。主要挑战是解决各种漏光问题。Annen 等人  <strong>[55]</strong>  介绍了卷积阴影贴图（convolution shadow map）。扩展了 Soler 和 Sillion 的平面接收器算法 <strong>[1673]</strong>  背后的思想，该思想是通过傅立叶展开来对阴影深度进行编码。与方差阴影贴图一样，可以对此类贴图进行滤波。该方法收敛于正确答案，从而减少了漏光问题。</p>
<p>卷积阴影贴图的一个缺点是需要计算和访问多个项，从而大大增加了执行和存储成本  <strong>[56，117]</strong> 。Salvi <strong>[1529，1530]</strong> 和 Annen 等人 <strong>[56]</strong> 同时并独立地提出了基于指数函数使用单个项的想法。该方法称为指数阴影贴图（exponential shadow map，ESM）或指数方差阴影贴图（exponential variance shadow map，EVSM），该方法将深度的指数及其二阶矩保存到两个缓冲区中。指数函数更接近于阴影贴图执行的阶跃函数（step function）（即是否在光线下），因此可以有效减少漏光伪像。它避免了卷积阴影贴图带来的另一个问题，即振铃（ringing），在此问题中，在超过原始遮挡器深度的特定深度处可能会发生轻微的漏光。</p>
<p>存储指数值的一个限制是，二阶矩值可能变得非常大，因此使用浮点数会超出范围。为了提高精度并允许指数函数更陡峭地下降，可以生成 z 深度以使其为线性 <strong>[117，258]</strong> 。</p>
<p>由于与卷积贴图相比，VSM 具有更高的质量，更低的存储量和更好的性能，因此，指数阴影贴图方法引起了三种滤波方法的最大兴趣。Pettineo <strong>[1405]</strong> 指出了其他一些改进，例如使用 MSAA 改善结果并获得一些有限的透明度的能力，并描述了如何使用计算着色器改善滤波性能。</p>
<p>最近，Peters 和 Klein <strong>[1398]</strong> 引入了矩阴影贴图（moment shadow mapping）。它提供了更好的图像质量，但是这是以使用四个或更多的矩（moments）为代价，从而增加了存储成本。可以通过使用 16 位整数存储矩来降低此成本。Pettineo <strong>[1404]</strong> 实现了这种新方法并将其与 ESM 进行了比较，从而提供了探索多种不同方法的代码基础。</p>
<p>层级阴影贴图技术可以应用于滤波后的贴图，以提高精度  <strong>[989]</strong> 。与标准层级贴图相比，层级 ESM 的一个优势是可以为所有层级设置单个偏差因子 <strong>[1405]</strong> 。Chen 和 Tatarchuk  <strong>[258]</strong>  详细介绍了层级 ESM 遇到的各种漏光问题和其他伪像，并提出了一些解决方案。</p>
<p>可以将过滤后的地图视为 PCF 的一种廉价形式，只需少量样本即可。像 PCF 一样，此类阴影具有恒定的宽度。这些过滤的方法都可以与 PCSS 结合使用，以提供可变宽度的半影  <strong>[57，1620，1943]</strong> 。矩阴影贴图的扩展还包括提供光散射和透明效果的功能  <strong>[1399]</strong> 。</p>
<h2 id="7-8-体积阴影技术-Volumetric-Shadow-Techniques"><a href="#7-8-体积阴影技术-Volumetric-Shadow-Techniques" class="headerlink" title="7.8 体积阴影技术 Volumetric Shadow Techniques"></a>7.8 体积阴影技术 Volumetric Shadow Techniques</h2><p>半透明物体会衰减并改变光的颜色。对于某些透明对象集，可以使用类似于 5.5 节中讨论的技术来模拟这种效果。例如，在某些情况下，可以生成第二种阴影贴图。半透明对象将呈现给第二种阴影贴图，并存储最接近的深度和颜色或 Alpha 覆盖范围。如果接收器没有被不透明的阴影贴图遮挡，则将测试透明深度贴图，如果遮挡了，则根据需要检索颜色或覆盖范围  <strong>[471，1678，1679]</strong> 。这个想法使人联想到第 7.2 节中的阴影和光投影，所存储的深度避免了投影到半透明物体和光之间的接收器上。此类技术无法应用于半透明对象本身。</p>
<p>自阴影对于真实渲染对象（例如头发和云朵）非常重要，在这些对象中，对象很小或半透明。单深度阴影贴图不适用于这些情况。Lokovic 和Veach  <strong>[1066]</strong> 首先提出了深度阴影贴图（deep shadow maps）的概念，其中每个阴影贴图的纹理像素都存储了光如何随深度下降的函数。通常通过一系列不同深度的样本来近似此功能，每个样本都具有不透明度值。贴图中包含给定位置深度的两个样本用于查找阴影效果。GPU 的挑战在于有效地生成和计算此类函数。这些算法使用类似的方法，并且遇到了一些与顺序无关的透明性算法（第5.5节）所遇到的类似挑战，例如，如何紧凑地存储并原样表示每个函数所需的数据。</p>
<p>Kim 和 Neumann <strong>[894]</strong> 率先提出了基于 GPU 的方法，他们将其称为不透明阴影贴图。仅存储不透明度的贴图是在一组固定的深度下生成的。Nguyen 和 Donnelly  <strong>[1274]</strong> 提供了此方法的更新版本，生成的图像如图 719 页上的图 17.2 所示。但是，深度截面都是平行且均匀的，因此，由于线性插值，需要很多截面来隐藏截面之间的不透明度伪像。Yuksel 和 Keyser <strong>[1953]</strong> 通过创建更紧密地遵循模型形状的不透明度贴图来提高效率和质量。这样做使他们减少了所需的层数，因为对最终图像的每一层计算都更为重要。</p>
<p>为了避免必须依赖固定的截面设置，目前已经提出了更多的自适应技术。Salvi 等人  <strong>[1531]</strong> 引入了自适应体积阴影贴图（adaptive volumetric shadow maps），其中每个阴影贴图纹理像素都存储了不透明度和层深度。像素着色器操作用于在光栅化数据流（表面不透明度）时进行有损压缩​​。这避免了需要无限制的内存容量来收集所有样本并在一组中进行处理。该技术类似于深度阴影贴图  <strong>[1066]</strong> ，但压缩步骤是在像素着色器中动态完成的。将函数表示形式限制为固定的少量不透明度/深度对，可以使GPU上的压缩和检索效率更高  <strong>[1531]</strong> 。由于需要读取，更新和写回曲线，因此该成本比简单的混合要高，并且它取决于表示曲线的点个数。在这种情况下，此技术还需要支持 UAV 和 ROV 功能的最新硬件（第 3.8 节的内容）。有关示例，请参见图7.29。</p>
<img alt="" height="481" src="https://img-blog.csdnimg.cn/20201023134238742.png" width="742">

<blockquote>
<p>图 7.29  使用自适应体积阴影贴图进行头发和烟雾渲染 <strong>[1531]</strong> 。（经 Marco Salvi 和 Intel Corporation 许可转载，版权为Intel Corporation，2010。）</p>
</blockquote>
<p>自适应体积阴影映射方法用于 GRID2 游戏中的逼真的烟雾渲染，平均成本低于2 ms /帧  <strong>[886]</strong> 。Först 等人  <strong>[509]</strong> 描述并提供了用于实现视频游戏深度阴影图的代码。他们使用链表存储深度和 Alpha，并使用指数阴影贴图在光照和阴影区域之间提供软过渡。</p>
<p>阴影算法的探索仍在继续，各种算法和技术的综合变得越来越普遍。例如，Selgrad等。 <strong>[1603]</strong> 研究存储具有链接列表的多个透明样本，并使用具有分散写入的计算着色器来构建地图。他们的工作使用深度阴影图概念以及滤波后的贴图和其他元素，从而为提供高质量的软阴影提供了更通用的解决方案。</p>
<h2 id="7-9-不规则-Z-缓冲区阴影-Irregular-Z-Buffer-Shadows"><a href="#7-9-不规则-Z-缓冲区阴影-Irregular-Z-Buffer-Shadows" class="headerlink" title="7.9 不规则 Z 缓冲区阴影 Irregular Z-Buffer Shadows"></a>7.9 不规则 Z 缓冲区阴影 Irregular Z-Buffer Shadows</h2><p>由于多种原因，各种阴影贴图方法很受欢迎。它们的成本是可以预测的，并且可以很好地适应不断增加的场景大小，最坏的情况是与图元数量成线性关系。它们依靠光栅化来定期采样灯光的世界视野，从而将它们很好地映射到 GPU 上。但是，由于这种离散采样，出现了问题，因为眼睛看到的位置与光线看到的位置不是一一对应的。当光以比眼睛更少的频率采样表面时，会出现各种走样问题。即使采样率相当，也存在偏差问题，因为在与眼睛所见位置稍有不同的位置采样了表面。</p>
<p>阴影体积提供了一种精确的分析解决方案，因为光线与表面的相互作用会产生一组三角形，这些三角形定义了给定位置是被照明还是处于阴影中。当在 GPU 上实现时，算法的不可预测的成本是一个严重的缺点。近年来  <strong>[1648]</strong> 所探索的改进令人着迷，但目前没有证据表明在商业应用中有采用这些方法。</p>
<p>从长远来看，另一种分析阴影测试方法可能具有潜力：光线追踪（ray tracing）。其基本思想在第 11.2.2 节中进行了详细描述，它的基本原理非常简单，尤其是对于阴影而言。光线从接收器位置射向光。如果发现任何阻挡光线的物体，则接收器处于阴影中。快速射线追踪器的大部分代码专用于生成和使用分层数据结构，以最大程度地减少每条射线所需的对象测试数量。在动态场景的每个框架上构建和更新这些结构的方法有着数十年的历史，也是一个持续的研究领域。</p>
<p>另一种方法是使用 GPU 的光栅化硬件来查看场景，但不只是 z 深度，还存储了有关光的每个网格中遮挡物边缘的附加信息 <strong>[1003，1607]</strong>  。例如，假设在每个阴影贴图纹理像素处存储与网格单元重叠的三角形列表。这样的列表可以通过保守光栅化来生成，其中如果三角形的任何部分与像素重叠，而不仅与像素的中心重叠，三角形都会生成一个片元（第 23.1.2 节）。这种方案的一个问题是通常需要限制每个纹理像素的数据量，这反过来可能导致确定每个接收器位置的状态不准确。考虑到现代 GPU 的链表原理  <strong>[1943]</strong> ，每个像素存储更多数据当然是可能的。</p>
<p>但是，除了物理内存限制外，每个纹理像素在列表中存储可变数据量的问题还在于，GPU 的处理效率可能变得极低，因为单个warp 可能会包含一些片元线程，这些线程需要检索和处理许多项， 而其余的线程则处于空闲状态，无需进行任何工作。构建着色器以避免动态 “if” 语句和循环导致的线程发散对性能来说至关重要。</p>
<p>在阴影图中存储三角形或其他数据并针对它们测试接收器位置的另一种方法是翻转问题，存储接收器位置，然后针对每个三角形测试三角形。Johnson 等人首先探讨了保存接收机位置的概念。 <strong>[839]</strong>  以及 Aila 和 Laine  <strong>[14]</strong> ，被称为不规则 z 缓冲区（irregular z-buffer，IZB）。名称有点误导，因为缓冲区本身具有阴影贴图的正常，规则形状。相反，缓冲区的内容是不规则的，因为每个阴影贴图纹理像素将在其中存储一个或多个接收器位置，或者可能根本没有。参见图 7.30。</p>
<img alt="" height="611" src="https://img-blog.csdnimg.cn/20201023192754240.png" width="744">

<blockquote>
<p>图 7.30  不规则 Z 缓冲区。在左上方，从眼睛观看的图像在像素中心生成了一组点。显示了形成立方体面的两个三角形。右上角为这些点在光源的视角中的显示情况。在左下角，将插入一个阴影贴图网格。对于每个纹理像素，将生成其网格单元内所有点的列表。在右下方，通过保守地对其进行栅格化来对红色三角形执行阴影测试。在触摸的每个纹理像素（以浅红色显示）时，列表中所有点均相对于三角形进行测试，以判断灯光的可见性。（底部的光栅图像由 Timo Aila 和 Samuli Laine 提供  <strong>[14]</strong> 。）</p>
</blockquote>
<p>使用 Sintorn 等人  <strong>[1645]</strong> 提出的方法，还有 Wyman 等 [1930，1932]，一种多 pass 算法创建了IZB，并测试了其内容在灯光下的可见性。首先，从眼睛渲染场景，以找到从眼睛看到的表面的 z 深度。这些点将转换为灯光的场景视图，并由此设置灯光视锥的紧密边界。然后将这些点放置在光源的 IZB 中，每个点都放在其对应纹理像素的列表中。请注意，有些列表可能是空的，是灯光可以看到的空间，但是眼睛看不到任何表面。遮罩保守地光栅化到灯光的 IZB，以确定是否隐藏了任何点，等等。保守栅格化可确保即使三角形不覆盖光纹素的中心，也将针对可能重叠的点进行测试。</p>
<p>可见性测试在像素着色器中进行。测试本身可以可视化为光线追踪的一种形式。从图像点的位置到光源会产生一条光线。如果一个点在三角形内并且比三角形平面更远，则该点将被隐藏。一旦光栅化所有遮挡物后，将使用可见性结果对表面进行着色。该测试也称为视锥追踪（frustum tracing），因为三角形可以认为是定义视锥，该视锥会查看检查点是否包含在视锥中。</p>
<p>仔细的编码对于使此方法与 GPU 兼容至关重要。Wyman 等人 <strong>[1930，1932]</strong> 注意到它们的最终版本比初始原型快两个数量级。这种性能提升的一部分是直接的算法改进，例如剔除表面法线背离光线（因此始终不照明）的图像点，并避免为空纹理像素生成片元。其他性能提升来自改善 GPU 的数据结构，以及通过在每个纹理像素中使用较短的，相似长度的点列表来最大程度地减少线程差异。图 7.30 显示了一个带有长列表的低分辨率阴影图，用于说明目的。理想情况是每个列表一个图像点。分辨率越高，列表越短，但遮挡器生成的片元数量也越多。</p>
<p>从图 7.30 的左下方图像可以看出，由于透视效应，地面上可见点的密度在左侧明显比右侧更高。通过将更多的光的贴图分辨率聚焦在观察视角附近，使用层级阴影贴图有助于减少这些区域中的列表大小。</p>
<p>这种方法避免了其他方法的采样和偏差问题，并提供了完全清晰的阴影。出于审美和感官上的原因，通常需要柔和的阴影，但附近的遮挡物（例如 Peter Panning）可能会有偏差问题。Story 和 Wyman <strong>[1711，1712]</strong> 探索了混合阴影技术。其核心思想是使用遮挡物距离混合 IZB 和 PCSS 阴影，当遮挡物靠近时使用硬阴影的计算结果，而在更远的地方使用软阴影的计算结果。参见图 7.31。阴影质量通常对于附近的物体最为重要，因此，仅对选定的子集使用此技术，就可以降低 IZB 成本。此解决方案已成功用于视频游戏中。本章将从这样的图像开始，如第 224 页的图 7.2 所示。</p>
<img alt="" height="210" src="https://img-blog.csdnimg.cn/20201023195505906.png" width="734">

<blockquote>
<p>图 7.31  在左侧，PCF 为所有对象提供均匀柔和的阴影。在中间，PCSS 通过与遮挡物的距离使阴影变柔和，但是与箱子左上角重叠的树枝阴影会产生伪像。在右边，来自 IZB 的清晰阴影和来自 PCSS 的柔和阴影提供了改进的结果  <strong>[1711]</strong> 。（图片来自育碧的“全境封锁”。）</p>
</blockquote>
<h2 id="7-10-其他应用-Other-Applications"><a href="#7-10-其他应用-Other-Applications" class="headerlink" title="7.10 其他应用 Other Applications"></a>7.10 其他应用 Other Applications</h2><p>将阴影贴图视为定义一定的空间，将光与暗分开，也可以帮助确定对象的哪些部分需要阴影。Gollent <strong>[555]</strong> 讲解了 CD Projekt 的地形阴影系统如何为每个区域计算仍然被遮挡的最大高度，然后可以将该最大高度用于阴影，不仅可以遮挡地形，还可以遮挡场景中的树木和其他元素。为了找到每个高度，为太阳绘制可见区域的阴影图。然后检查每个地形的高度场位置是否有阳光的可见性。如果在阴影中，则通过将世界高度增加一个固定的步长，直到看到太阳，然后执行二进制搜索，来估计太阳首次可见的高度。换句话说，我们沿着垂直线行进，然后进行迭代以缩小与阴影图的表面相交的位置，从而将明暗分开。对相邻的高度进行内部插值以在任何位置找到此遮挡高度。在图 7.32 中可以看到用于地形高度场的软阴影的此技术的示例。在第 14 章中，我们将看到更多使用光线步进（ray marching）穿过明暗区域的方法。</p>
<img alt="" height="414" src="https://img-blog.csdnimg.cn/2020102320245778.png" width="735">

<blockquote>
<p>图 7.32  为每个高度场位置计算的地形以首次看到太阳的高度为单位。请注意阴影边缘的树木是如何正确产生阴影的  <strong>[555]</strong> 。（CD PROJEKT ®，Witcher ®是CD PROJEKT Capital Group的注册商标。The Witcher © 游戏CD PROJEKT SA由CD PROJEKT SA开发。保留所有权利。The Witcher 游戏基于 Andrzej Sapkowski 的小说。所有其他版权和商标均为其各自所有者的财产。）</p>
</blockquote>
<p>值得一提的最后一种方法是渲染屏幕空间阴影。由于分辨率有限，阴影贴图通常无法在小要素上产生准确的遮挡。这在渲染人脸时尤其成问题，因为我们特别容易注意到它们上的任何视觉伪像。例如，渲染发光的鼻孔（当不需要时）看起来是不协调的。虽然使用仅针对感兴趣区域的高分辨率阴影贴图或单独的阴影贴图可以提供帮助，但另一种可能性是利用已经存在的数据。在大多数现代渲染引擎中，从摄像机角度来看的深度缓冲区（来自较早的预渲染）在渲染期间可用。存储在其中的数据可以视为高度场。通过迭代采样该深度缓冲区，我们可以执行光线步进过程（第 6.8.1 节），并检查朝向光的方向是否被遮挡。尽管代价高昂，因为它涉及到重复采样深度缓冲区，但这样做可以为剪辑场景中的特写镜头提供高质量的结果，在剪辑场景中通常需要花费毫秒的时间。该方法由 Sousa 等人提出  <strong>[1678]</strong> ，并在当今的许多游戏引擎中普遍使用  <strong>[384，1802]</strong> 。</p>
<p>总结整章，到目前为止，某种形式的阴影贴图（shadow mapping）是用于将阴影投射到任意表面形状上的最常用算法。当在大面积（例如室外场景）中投射阴影时，层级阴影贴图可提高采样质量。通过 SDSM 为近平面找到合适的最大距离可以进一步提高精度。百分比渐进滤波（PCF）使阴影更柔和，百分比渐进软阴影（PCSS）及其变体使近处阴影更硬，不规则的 z 缓冲区可提供精确的硬阴影。过滤后的阴影贴图可提供快速的软阴影计算，并且在遮挡物远离接收器（如地形）时，效果特别好。最后，屏幕空间技术可用于更高的精度，尽管成本很高。</p>
<p>在本章中，我们重点介绍了当前在应用程序中使用的关键概念和技术。其中每个技术都有自己的优势，具体的选择取决于世界的大小，构图（静态内容还是动画），材质类型（不透明，透明，头发或烟雾）以及灯光的数量和类型（静态光源或动态光源；局部光源或远距离光源；点光源，聚光灯，或区域光），以及诸如基础纹理可以隐藏任何伪像的程度之类的因素。GPU 的功能不断发展和完善，因此我们希望在未来的几年中会继续出现与硬件良好匹配的新算法。例如，第 19.10.1 节中描述的稀疏纹理技术已应用于阴影贴图存储，以提高分辨率  <strong>[241、625、1253]</strong> 。</p>
<p>Sintorn，Kampe等人 <strong>[850，1647]</strong> 以一种创新的方法探索了将光的二维阴影贴图转换为三维三维像素集的想法（小盒子；请参见第13.10节）。使用体素的优点是可以将其分类为亮或暗，因此需要的存储量最少。高度压缩的稀疏体素八叉树表示法可存储大量灯光和静态遮挡物的阴影。Scandolo 等人 <strong>[1546]</strong> 将其压缩技术与使用双阴影图的基于间隔的方案相结合，从而提供了更高的压缩率。Kasyan <strong>[865]</strong> 使用体素圆锥追踪（第13.10节）从区域光生成软阴影。有关示例，请参见图 7.33。更多的圆锥形阴影显示在第 585 页的图 13.33 中。</p>
<img alt="" height="709" src="https://img-blog.csdnimg.cn/20201023202825479.png" width="735">

<blockquote>
<p>图 7.33  上方是使用基本的软阴影近似生成的图像。下方是场景体素化时，使用视锥线跟踪的基于体素的区域光阴影。请注意，汽车的阴影要多得多。照明也因一天中的时间变化而有所不同。（图片由Crytek  <strong>[865]</strong> 提供。）</p>
</blockquote>
<h3 id="进一步阅读和资源-Further-Reading-and-Resources"><a href="#进一步阅读和资源-Further-Reading-and-Resources" class="headerlink" title="进一步阅读和资源 Further Reading and Resources"></a>进一步阅读和资源 Further Reading and Resources</h3><p>本章的重点是基本原理以及阴影算法需要什么质量（可预测的质量和性能）才能在交互式渲染中使用。我们避免了在渲染领域完成研究的过度详尽的分类，因为有两本书已经解决了这个问题。Eisemann等人的《实时阴影》（《Real-Time Shadows 》）一书。 <strong>[412]</strong> 直接关注交互式渲染技术，讨论了各种算法及其优势和成本。SIGGRAPH 2012 课程提供了本书的摘录，同时还增加了对较新作品的引用  <strong>[413]</strong> 。可从其网站 <a target="_blank" rel="noopener" href="http://www.realtimeshadows.com/">www.realtimeshadows.com</a> 上获得其 SIGGRAPH 2013 课程的演示文稿。Woo 和 Poulin 的《阴影算法数据挖掘器》 （Shadow Algorithms Data Miner  <strong>[1902]</strong> ）概述了用于交互式和批处理渲染的多种阴影算法。这两本书都提供了该领域数百篇研究文章的参考。</p>
<p>塔夫特的成对文章  <strong>[1791，1792]</strong>  很好地概述了常用的阴影映射技术及其所涉及的问题。Bjørge  <strong>[154]</strong> 提出了一系列适用于移动设备的流行阴影算法，以及比较各种算法的图像。里尔（Lilley）的演讲 <strong>[1046]</strong> 对实用阴影算法进行了扎实而广泛的概述，重点是 GIS 系统的地形渲染。Pettineo  <strong>[1403，1404]</strong> 和 Casta〜no <strong>[235]</strong>  的博客文章因其实用技巧和解决方案以及演示代码库而特别有价值。Scherzer 等人 <strong>[1558]</strong> 简要总结了专门针对硬阴影的作品。Hasenfratz 等人对软阴影算法的研究 <strong>[675] ，</strong>虽然已过时，但在一定程度上涵盖了广泛的早期工作。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B8%B2%E6%9F%93/" rel="tag"># 渲染</a>
              <a href="/tags/RealTimeRendering/" rel="tag"># RealTimeRendering</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/21/OtherStudy/UI%E4%BC%98%E5%8C%96%E6%8F%92%E4%BB%B6/" rel="prev" title="Unity UI优化工具">
      <i class="fa fa-chevron-left"></i> Unity UI优化工具
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/22/RealTimeRender4/2/" rel="next" title="RealTimeRendering 2">
      RealTimeRendering 2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="SOHUCS"></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E9%98%B4%E5%BD%B1-Chapter-7-Shadows"><span class="nav-number">1.</span> <span class="nav-text">第7章 阴影 Chapter 7 Shadows</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%B9%B3%E9%9D%A2%E9%98%B4%E5%BD%B1-Planar-Shadows"><span class="nav-number">1.1.</span> <span class="nav-text">7.1 平面阴影 Planar Shadows</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-%E6%8A%95%E5%B0%84%E9%98%B4%E5%BD%B1-Projection-Shadows"><span class="nav-number">1.1.1.</span> <span class="nav-text">7.1.1 投射阴影 Projection Shadows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-%E8%BD%AF%E9%98%B4%E5%BD%B1-Soft-Shadows"><span class="nav-number">1.1.2.</span> <span class="nav-text">7.1.2 软阴影 Soft Shadows</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E6%9B%B2%E9%9D%A2%E4%B8%8A%E7%9A%84%E9%98%B4%E5%BD%B1-Shadows-on-Curved-Surfaces"><span class="nav-number">1.2.</span> <span class="nav-text">7.2 曲面上的阴影 Shadows on Curved Surfaces</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E9%98%B4%E5%BD%B1%E4%BD%93-Shadow-Volumes"><span class="nav-number">1.3.</span> <span class="nav-text">7.3 阴影体 Shadow Volumes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE-Shadow-Maps"><span class="nav-number">1.4.</span> <span class="nav-text">7.4 阴影贴图 Shadow Maps</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1-%E5%88%86%E8%BE%A8%E7%8E%87%E5%A2%9E%E5%BC%BA-Resolution-Enhancement"><span class="nav-number">1.4.1.</span> <span class="nav-text">7.4.1 分辨率增强 Resolution Enhancement</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E7%99%BE%E5%88%86%E6%AF%94%E6%B8%90%E8%BF%91%E6%BB%A4%E6%B3%A2-Percentage-Closer-Filtering"><span class="nav-number">1.5.</span> <span class="nav-text">7.5 百分比渐近滤波 Percentage-Closer Filtering</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-%E7%99%BE%E5%88%86%E6%AF%94%E6%B8%90%E8%BF%91%E8%BD%AF%E9%98%B4%E5%BD%B1-Percentage-Closer-Soft-Shadows"><span class="nav-number">1.6.</span> <span class="nav-text">7.6 百分比渐近软阴影 Percentage-Closer Soft Shadows</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-%E6%BB%A4%E6%B3%A2%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE-Filtered-Shadow-Maps"><span class="nav-number">1.7.</span> <span class="nav-text">7.7 滤波阴影贴图 Filtered Shadow Maps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-%E4%BD%93%E7%A7%AF%E9%98%B4%E5%BD%B1%E6%8A%80%E6%9C%AF-Volumetric-Shadow-Techniques"><span class="nav-number">1.8.</span> <span class="nav-text">7.8 体积阴影技术 Volumetric Shadow Techniques</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-9-%E4%B8%8D%E8%A7%84%E5%88%99-Z-%E7%BC%93%E5%86%B2%E5%8C%BA%E9%98%B4%E5%BD%B1-Irregular-Z-Buffer-Shadows"><span class="nav-number">1.9.</span> <span class="nav-text">7.9 不规则 Z 缓冲区阴影 Irregular Z-Buffer Shadows</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-10-%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8-Other-Applications"><span class="nav-number">1.10.</span> <span class="nav-text">7.10 其他应用 Other Applications</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB%E5%92%8C%E8%B5%84%E6%BA%90-Further-Reading-and-Resources"><span class="nav-number">1.10.1.</span> <span class="nav-text">进一步阅读和资源 Further Reading and Resources</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">VisionXie</p>
  <div class="site-description" itemprop="description">生活在树上，始终热爱大地，升入天空。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VisionXie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <script>
  NexT.utils.loadComments(document.querySelector('#SOHUCS'), () => {
    var appid = 'cyvS0HjaG';
    var conf = '26c6eae6e21dfb5a6535a5e53425e9ec';
    var width = window.innerWidth || document.documentElement.clientWidth;
    if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
    } else {
      var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})});
    }
  });
  </script>
  <script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>

</body>
</html>
